#+TODO: TODO(t@) BLOCK(b@) | DONE(d!)
#+STARTUP: indent logdone logdrawer content lognoteclock-out
# ------------------------------------------------------
#+TITLE: Project Planning: tree_sitter_noir
#+LANGUAGE: en

** Taxy Notes
https://github.com/alphapapa/taxy.el
https://www.gnu.org/software/emacs/manual/html_node/cl/Structures.html

Programmable rules to put arbitrary things (objects) in nested groups.

- Dynamic :: automatic runtime classification based on object's attributes.
- Reusable :: taxy definitions storable in variables, reusable elsewhere.

Programmatically, taxys are structs so they may be stored in variables and used in other structs. Be sure to copy the root taxy with ~taxy-emptied~ before filling in such a use-case.

*** Creating taxys

Create a taxy with ~make-taxy~.

#+begin_src elisp
(make-taxy :name "Numbery"
           :description "A silly taxonomy of numbers."
           :predicate #'numberp
           :then #'ignore
           :taxys (list ...))
#+end_src

~:predicate~ function determines if an object is in that taxy. If it is ~taxy-fill~ adds the object to that taxy's descendent ~:taxys~ (if present), otherwise to the taxy's own ~:items~. Default is ~identity~.

~:then~ function processes an object after it's added to that taxy's ~:items~. If non-nil is returned that value is applied to other taxys at the same level until one of their ~:then~ functions returns nil, or no more taxys remain. Default is ~ignore~.

Returning =nil= from ~:then~ means that taxy has "consumed" the object. If you use ~identity~ (for example) instead of ~ignore~ then the taxy doesn't "consume" the object making it eligible to be taken into subsequent taxys or appear in the parent taxy's items.

*** Populating taxys

Call ~taxy-fill~ with created taxy from ~make-taxy~ and a list of objects to fill the taxy's hierarchy.

*Note*: ~taxy-fill~ modifies the taxy given to it, filling it's ~:items~ and those of ~:taxys~. If using a statically defined taxy (e.g. one defined with ~defvar~), you should pass ~taxy-fill~ a taxy copied with ~taxy-emptied~, which recursively copies a taxy without ~:items~.

~taxy-plain~ returns a taxy with only relevant fields included.

~taxy-mapcar~ can replace items in a taxy.

** Development
:LOGBOOK:
CLOCK: [2026-02-18 Wed 18:52]--[2026-02-18 Wed 21:25] =>  2:33
- - Review parser.rs, associated TODO notes.
  - Start updating (very basic so far) noir_grammar.org; will mark all subsequent items therein for update afterwards.
  - Workflow to nicely view diffs for grammar changes.
CLOCK: [2026-02-16 Mon 18:11]--[2026-02-16 Mon 20:13] =>  2:02
- - Start reviewing grammar changes.
  - Refamiliarise with noir_grammar.org.
  - Git commands to get tags between prior release and current.
  - Git commands to review difference betwern frontend parser files.
:END:

*** Tree-sitter
**** Testing

- =test/corpus= :: CST assertions.
- =test/highlight= ([[https://tree-sitter.github.io/tree-sitter/3-syntax-highlighting.html#unit-testing][src]]) :: highlight selector positions.
- =test/tags= ([[https://tree-sitter.github.io/tree-sitter/4-code-navigation.html#unit-testing][src]]) :: tag assertions.
- =test/vocabulary= :: Noir source-code for parsing, assertion that Noirc will parse.

**** Queries

- =queries/highlights.scm= :: highlights.
- =queries/locals.scm= :: local variables.
- =queries/injections.scm= :: injections.

***** Syntax
Source: [[https://tree-sitter.github.io/tree-sitter/using-parsers/queries/1-syntax.html][tree-sitter query syntax]]

Queries consist of one or more /patterns/ defined as an s-expression. **Patterns** match sets of nodes in the CST according to their type (rule name resulting in a **named node**), and may optionally have any number of additional patterns which match children of the initial node type.

**Child patterns** can be prefixed with **field names** to limit said pattern to the field name of the /parent/.

**Negate** fields by prefixing them with =!=, only nodes which lack a negated field will be matched.

**Anonymous nodes** cannot be matched with the s-expression syntax, instead their contents (as they have no name) must be matched between double-quotes.

**Wildcard** nodes may be matched with =(_)= which matches any **named** node, or =_= which matches any **named or anonymous** node.

**Error** nodes are created by the parser when it encounters text it does not recognise, they look like =(ERROR)= and can be queried like normal nodes.

TODO: Missing nodes https://tree-sitter.github.io/tree-sitter/using-parsers/queries/1-syntax.html#the-missing-node

****** Examples

Match a ~binary_expression~ who has two children, both of which are ~number_literal~\s.
#+begin_example
(binary_expression (number_literal) (number_literal))
#+end_example

Match an ~assignment_expression~ which has a field 'left' which has a child ~member_expression~.
#+begin_example
(assignment_expression
  left: (member_expression))
#+end_example

Match a ~binary_expression~ which (1) has a field 'operator' that has an anonymous node with the contents ~!=~, and (2) has a field 'right' which has a child ~null~.
#+begin_example
(binary_expression
  operator: "!="
  right: (null))
#+end_example

Match any **named** node inside ~call~.
#+begin_example
(call (_))
#+end_example

***** Operators
Source: [[https://tree-sitter.github.io/tree-sitter/using-parsers/queries/2-operators.html][tree-sitter operators]]

**Captures** allow one to refer to specific regions of a pattern by a custom name for further use elsewhere. Capture names come /after/ the nodes they refer to and begin with =@=.

**Quantifications** allow matching sequences of sibling nodes, they are supplied postfix to the nodes pattern, can be combined with captures, and are:
  - =+= :: match /one or more/ repetitions.
  - =*= :: match /zero or more/ repetitions.
  - =?= :: match /zero or one/ repetitions (i.e. /optional/).

**Groups** of sequential sibling nodes can be formed by surrounding patterns with parentheses. Groups can be combined with captures.

**Alternations** are defined within =[]= and specify a list of alternative patterns.

**Anchors** =.= constrain where child-patterns are matched in their parents. Anchors may be placed before the first child-pattern, in the middle of two child-patterns, or at the end after all child-patterns and **only affect named nodes**.
  - Start :: child-pattern only matches if it is the /first/ named node.
  - Middle :: child-patterns only match if immediately adjacent.
  - End :: child-pattern only matches if it is the /last/ named node.
    
****** Examples

Match any assignment of ~function~ to an ~identifier~ and **capture** the ~identifier~ node under the name ~the-function-name~.
#+begin_example
(assignment_expression
  left: (identifier) @the-function-name
  right: (function))
#+end_example

Match ~class_declaration~ and capture all ~decorator~ nodes under the name ~the-decorator~, as well as an ~identifier~ in field 'name' under the name ~the-name~.
#+begin_example
(class_declaration
  (decorator)* @the-decorator
  name: (identifier) @the-name)
#+end_example

Match a ~comment~ which is directly followed by (sibling to) a ~function_declaration~.
#+begin_example
(
  (comment)
  (function_declaration)
)
#+end_example

Match a comma-delimited series of ~number~ nodes.
#+begin_example
(
  (number)
  ("," (number))*
)
#+end_example

This pattern has an anchor at the start, and matches an ~array~ node at most once, with the first child ~identifier~ being captured with name ~the-element~.
#+begin_example
(array . (identifier) @the-element)
#+end_example

The same pattern, without the anchor, would over and over for each ~identifier~ in ~array~ and ~the-element~ would capture all of them.
#+begin_example
(array (identifier) @the-element)
#+end_example

Match any named node under the name ~last-expression~ so long as it is the last node (child) in a ~block~.
#+begin_example
(block (_) @last-expression .)
#+end_example

Match a ~dotted_name~ where an ~identifier~ is captured under name ~prev-id~, and an ~identifier~ is captured under name ~next-id~ but **only if** said identifiers are immediately adjacent to each other.
#+begin_example
(dotted_name
  (identifier) @prev-id
  .
  (identifier) @next-id)
#+end_example

So given =a.b.c.d= only =a.b=, =b.c=, and =c.d= will match. Without the anchor =a.c=, and =b.d= would also be matched.

***** Predicates and Directives
Source: [[https://tree-sitter.github.io/tree-sitter/using-parsers/queries/3-predicates-and-directives.html#predicates][tree-sitter predicates and directives]]

Note: The tree-sitter CLI implements these, they are not directly part of the tree-sitter C API and so their support may depend on the eventual target. If that target uses the Rust crate or WebAssembly bindings they are supported for example.

**Predicates** allow specifying arbitrary conditions and metadata and are written within s-expressions. The predicate is enclosed within =#?=. Capture names within predicates and bindings are prefixed with =@=.

- ~#eq?~ ([[https://tree-sitter.github.io/tree-sitter/using-parsers/queries/3-predicates-and-directives.html#the-eq-predicate][src]]): test single capture or /string/.
  :: 2 params: (1) capture name; (2) capture name or string.
- ~#match?~ ([[https://tree-sitter.github.io/tree-sitter/using-parsers/queries/3-predicates-and-directives.html#the-match-predicate][src]]): test /regular expression/ value.
  :: 2 params: (1) capture name; (2) regular expression (as a string).
- ~#any-of?~ ([[https://tree-sitter.github.io/tree-sitter/using-parsers/queries/3-predicates-and-directives.html#the-any-of-predicate][src]]): test multiple /string/ values.
  :: 1 + N params: (1) capture name; (N) space separated strings.
- ~#is?~ ([[https://tree-sitter.github.io/tree-sitter/using-parsers/queries/3-predicates-and-directives.html#the-is-predicate][src]]): test presence of given property.
  :: 1 param: (1) property name.
- ~#is-not?~: test absence of given property.
  :: 1 param: (1) property name.

Predicates ~#eq?~, and ~#match?~, and ~#any-of?~ can be prefixed with:
  - =not-= to test their complement.

Predicates ~#eq?~, and ~#match?~ can be prefixed with:
  - =any-= to test /any/ of the associated nodes.
  - =any-not-= to test the complement of =any-=.

Quantifiers, by default, will only match when all nodes satisfy the pattern so =any-=-prefixed predicates are most useful in combination with them.

*************** TODO What is a 'property'? Do they mean a 'field'?
*************** END

**Directives** are the same as predicates except they are wrapped in =#!= and have side-effects.

- ~#set!~ ([[https://tree-sitter.github.io/tree-sitter/using-parsers/queries/3-predicates-and-directives.html#the-set-directive][src]]): associate key-value pairs with a pattern.
  :: 2 params: (1) key-name to set; (2) value to set.
- ~#select-adjacent!~ ([[https://tree-sitter.github.io/tree-sitter/using-parsers/queries/3-predicates-and-directives.html#the-select-adjacent-directive][src]]): filter text associated with a capture so that only nodes adjacent to another capture are preserved.
  :: 2 params: (1) capture name; (2) capture name.
- ~#strip!~ ([[https://tree-sitter.github.io/tree-sitter/using-parsers/queries/3-predicates-and-directives.html#the-strip-directive][src]]): remove matched regular expression text from a capture.
  :: 2 params: (1) capture name to strip text from; (2) regular expression.
  
*************** TODO More on select-adjacent, I don't yet get it
Examples for select adjacent and strip in code navigation docs: https://tree-sitter.github.io/tree-sitter/4-code-navigation.html#examples
*************** END
    
****** Examples

(c) Match any ~identifier~ node which has contents equal to string =self=.
#+begin_example
((identifier) @variable.builtin
  (#eq? @variable.builtin "self"))
#+end_example

Match any ~pair~ whose =key= field has the same contents as it's =value= field, i.e. whose key and pair have the same values.
#+begin_example
(
  (pair
    key: (property_identifier) @key-name
    value: (identifier) @value-name)
  (#eq? @key-name @value-name)
)
#+end_example

Match an empty ~comment~ within a group of comments. A quantifier is used here to constrain the pattern (initial) to only those groups of 1 or more comments.
#+begin_example
((comment)+ @comment.empty
  (#any-eq? @comment.empty "//"))
#+end_example

Match ~identifier~ nodes who are written in =ALL_CAPS_SNAKECASE=.
#+begin_example
((identifier) @constant
  (#match? @constant "^[A-Z][A-Z_]+"))
#+end_example

(js) Initially match ~identifier~ nodes who are builtin variables, but because of ~#is-not?~ ultimately match builtin variables who are not local.
#+begin_example
((identifier) @variable.builtin
  (#match? @variable.builtin "^(arguments|module|console|window|document)$")
  (#is-not? local))
#+end_example

(lua) Match any ~comment~ that contains a Doxygen-style comment (regex) and then set the =injection.language= key of that ~comment~ to string =doxygen=.
#+begin_example
((comment) @injection.content
  (#lua-match? @injection.content "/[*\/][!*\/]<?[^a-zA-Z]")
  (#set! injection.language "doxygen"))
#+end_example

***** Highlights
Source: https://tree-sitter.github.io/tree-sitter/3-syntax-highlighting.html#highlights

Assign arbitrary highlight names using catures, the highlight names can be dot-separated.

***** Locals
Source: https://tree-sitter.github.io/tree-sitter/3-syntax-highlighting.html#local-variables

Keep track of local scopes and variables so the appropriate entities are highlighted consisently.

Only specific named captures can be used.
  - ~@local.scope~: syntax node introduces new scope.
  - ~@local.definition~: syntax node contains /name/ of definition within current local scope.
  - ~@local.reference~: syntax node contains /name/ which may (or not) refer to an earlier definition in some enclosing scope.

When highlighting a file tree-sitter keeps track of the scopes which contain any given position, and the definitions within that scope. For example, when processing a syntax node captured as =local.reference= tree-sitter will try find a definition for a name that matches the nodes text; if it finds one it will ensure the /reference/ and /definition/ are coloured the same.

Highlights can access locals query information, for example to disable a pattern for nodes identified as local use the predicate ~(#is-not? local)~ in the pattern.

***** TODO Injections
Source: https://tree-sitter.github.io/tree-sitter/3-syntax-highlighting.html#language-injection

*** Scratch

2025/05/19 2:25 pm
Currently looking at Program = Module top-level, added two headlines Program, Module simply trying to get proper documentation. Basically, is:
       // Noirc: Program.
        source_file: ($) => repeat($._statement),

        // Noirc: Module.
        _statement: ($) => choice($._expression_statement, $._declaration_statement),
in rendered grammar correct? Specifically the COMMENTS. I think the comments might've been from old parser-combinator frontend.

2025/05/19 2:31 pm
Looking at ATTRIBUTES. Let's get that into hithere.js (2025/05/20: hard since re-review of lexer somewhat required, so save this for later I guess).

2025/05/19 2:34 pm
Perhaps also look at simply getting a basic org-export to HTML up and online. It can have only the styling it has now. Mostly to link to people to show (at a coarse level) what the final /documentation/ will look like.

2025/05/24 4:02 pm
Currently depth first PatternNoMut -> StructPattern (looking at ln 130 of pattern.rs for path before parse_struct_pattern)
Part StructPattern is now going through Path from parse_path onwards
Now currently at PathGenerics which has a call to parse_generic_type_args which is Noirc (GenericTypeArgs) so after finishing docs for PathGenerics will need to start looking at GenericTypeArgs.
Got all of GenericTypeArgs set to SPEC, looking at IdentifierPattern (directly after, so double check "up the tree" from GenericTypeArgs I haven't skipped anything) since I really need to get the identifier rule in the grammar to begin testing stuff.

NB: Modern :callstack: formatting under Function (for documenting)

Also l

Blockers:
- InternedPattern

Re-reviewed (done)
- Attributes
- Pattern
- TupplePattern
- PatternList

2025/05/25 2:01 am
Need to add basic structure to the tree sitter grammar so it can reach the point of a function body, and a let binding within that. Currently I cannot write and run tests because we don't have the top-level items to reach down.

So, look at getting whatever is needed for a function body, and then what goes inside etc so we can do some basic TypeExpressions tests.

1073 in lexer.rs for good comment tests (and more)

2025/06/05 5:03 pm
Comments rules and external scanner done. Upon refreshing my mind, SHOULD to continue on the ATTRIBUTES crusade to get that complete, but will instead continue on StatementKind > LetStatement > Pattern > PatternOrSelf

2025/06/10 4:58pm
Since Impl's children (at least one of them, TypeImpl) depend on Function I'm going to look at Function and mark Impl blocked until then since it need be so for testing.

From: https://doc.rust-lang.org/reference/glossary.html?highlight=constraint#bound
Bounds are constraints on a type or trait. For example, if a bound is placed on the argument a function takes, types passed to that function must abide by that constraint.

From: https://doc.rust-lang.org/reference/patterns.html#r-patterns.intro
Patterns are used to match values against structures and to, optionally, bind variables to values inside these structures. They are also used in variable declarations and parameters for functions and closures.

2025/06/12 6:17pm
Trying to depth-first for Function has resulted in A LOT of stuff, so.. a lot of moving parts. Looks like Global is simpler (in terms of apparent nesting) so going to change tack to that for now.



2025/07/14 2:32 pm
CONTINUE FROM ItemKind Function!!!!!!
- need to look at Block
- need to look at FunctionParameters

Need to look at Pattern next (I say as I am adding required semicolon stuff and see pattern is part of LetStatement)

Looking at Block continue from the parse_statement_in_block bits, want to make sure not duplicating work here. It's all coming together just remain thorough!

Need to look at the semicolon terminating stuff for BlockExpression

2025/07/15 11:52pm
At the point where I need to do some restructuring for ExpressionStatement. I've got the list of StatementKinds which require a terminating semimcolon now I need ts rules that match this structure. So repeated statements (with semicolons) then an expression statement etc.

BlockExpression > Statement

TODO: be sure to add a test that correctly differentiates between an if expression being used as a statement versus as an expression-statement.

For ExpressionStatement still need to do the terminating ; afterwards which is currently an error

Where else can IfExpression be reached from? Can we wrap it in ExpressionStatement should it be followed by a ';'?


2025/07/24 03:47am


head/tail notes so i can stop derping out:

~head~ - display first lines of a file
  - param ~-n COUNT~ to display only first ~n~ lines.

~tail~ - display last part of a file
  - param ~-n COUNT~ refers to line ~n~
  - numbers given with leading ~+~ are relative to the beginning of the input, numbers with leading ~-~ are relative to the end of the input



1. what version of git is magit using (and print that on startup or something)
2. other stuff to speedup magit? cos it's annoyingly fucking slow
3. any way to have a shortcut command to stage certain files so i dont have to manually select them every time?

Perhaps a new % sign in my font, the % is a little hard to read sometimes. Maybe it's because it's narrow? 1234%.

*** Grammar Areas

Areas to tackle to construct the tree-sitter grammar.

**** Top-level

General top-level items need doing (macro) so micro-level structures can be tested. Currently got a bunch of micro-level structures but not enough macro-level.

Program contains Module which contains InnerDocComments and Item. Comments can appear anywhere, so Item is effectively our top-level.

**** Use and Paths



Need to document how Use and Path interact in the sense that it's a big cluster fuck, and that incldues PathKind and PathNoTurbofish shite.

**** Patterns

Identifier patterns: https://doc.rust-lang.org/reference/patterns.html#r-patterns.ident.bare

**** Impl

Impl > TypeImpl > Generics
                > Type
                > TypeImplBody > TypeImplItem > OuterDocComments
                                              > Attributes
                                              > Modifiers
                                              > Function
                               
     > TraitImpl > Generics
                 > Path
                 > GenericTypeArgs
                 > Type
                 > TraitImplBody > TraitImplItem > TraitImplType
                                                 > TraitImplConstant
                                                 > TraitImplFunction

TraitImplType > identifier
              > Type

TraitImplConstant > identifier
                  > OptionalTypeAnnotation

TraitImplFunction > Attributes
                  > Modifiers
                  > Function

***** EBNF

Remember 'GenericTypeArgs' = WhereClause.


TypeImpl = 'impl' Generics Type TypeImplBody

TypeImplBody = '{' TypeImplItem* '}'
TypeImplItem = OuterDocComments Attributes Modifiers Function


TraitImpl = 'impl' Generics Path GenericTypeArgs 'for' Type TraitImplBody

TraitImplBody = '{' TraitImplItem* '}'
TraitImplItem
    = TraitImplType
    | TraitImplConstant
    | TraitImplFunction
TraitImplType = 'type' identifier ( ':' Type )? ';'
TraitImplConstant = 'let' identifier OptionalTypeAnnotation ';'
TraitImplFunction = Attributes Modifiers Function
                  
**** Function

Function > identifier
         > Generics
         > FunctionParameters > FunctionParametersList > FunctionParameter > Visibility
                                                                           > PatternOrSelf
                                                                           > Type
         > Visibility
         > Type
         > WhereClause
         > Block

PatternOrSelf > Pattern 
              > SelfPattern

PatternNoMut > InternedPattern > interned_pattern
             > TuplePattern > PatternList > Pattern
             > StructPattern > Path
                             > StructPatternFields > StructPatternField > identifier
                                                                        > Pattern
             > IdentifierPattern > identifier

**** Expression Hierarchy

Term > UnaryOp
     > Term
     > AtomOrUnaryRightExpression > Atom
                                  > UnaryRightExpression > CallExpression
                                                         > MemberAccessOrMethodCallExpression
                                                         > CastExpression
                                                         > IndexExpression

CallExpression > Atom
               > CallArguments

MemberAccessOrMethodCallExpression > MemberAccessExpression > Atom
                                                            > identifier
                                   > MethodCallExpression > Atom
                                                          > CallArguments
                                                          > identifier

CastExpression > Atom
               > Type

IndexExpression > Atom
                > Expression

Atom > Literal
     > ParenthesesExpression > UnitLiteral/
                             > ParenthesizedExpression > Expression
                             > TupleExpression > Expression
     > UnsafeExpression > Block
     > PathExpression > VariableExpression > Path
                      > ConstructorExpression > Type
                                              > ConstructorFields > ConstructorField
                                                                  > Expression
                                                                  > identifier
     > IfExpression > ExpressionExceptConstructor
                    > Block
                    > IfExpression*
     > Lambda
     > ComptimeExpression > Block
     > UnquoteExpression > Expression
                         > identifier
     > TypePathExpression > PrimitiveType
                          > identifier
                          > GenericTypeArgs
     > AsTraitPath
     > ResolvedExpression > unquote_marker
     > InternedExpression > interned_expr
     > InternedStatementExpression > interned_statement

**** Statement / Literal Conflict

Block > Statement > BreakStmt
                  > ContinueStmt
                  > ReturnStmt
                  > LetStmt
                  > ComptimeStmt
                  > ConstrainStmt
                  > ForStmt
                  > AssignStmt
                  > IfExpression
                  > Block
                  > ExpressionStmt > Expression > Identifier
                                                > BinaryExpression
                                                > Literal

Literal > QuoteExpression/
        > ArrayExpression > ArrayLiteral > StandardArrayLiteral > ArrayElements > Expression
                                         > RepeatedArrayLiteral > Expression
                                                                > TypeExpression
        > SliceExpression > ArrayLiteral
        > BlockExpression > Block

BinaryExpression > Expression

SliceExpression > ArrayExpression

*** Classification Semantics
:PROPERTIES:
:CUSTOM_ID: h:9255C4E4-03B0-4A3B-B3AE-454FF2A53D57
:END:

=statement=: an action which has no return value. More precisely it's /execution/ does /something/. May be comprised of other semantic components (like an expression). Can further be discriminated into definitions and declarations.
  - =compound=: can contain other statements.
  - =simple=: cannot contain other statements.

=expression=: an action which has a return value, more precisely it's /evaluation/ produces a /value/.

=declaration=: a type of statement which specifies only the type of a thing. There is no value or body associated.

=definition=: a type of statement which is a declaration (so, the type of a thing) but also an associated value or body, e.g. in the case of a variable, or function respectively.

=expression statement=: an expression used where a statement is expected. In a C like language a statement terminator =;= typically follows which immediately discards the expression's value. It's use is in if the expression executes side-effects as part of it's evaluation.


Note that (typically) /formally/ =declaration= typically always means the above (informal) =definition= meaning and there is no such distinction between definition and declaration.


https://en.wikipedia.org/wiki/Statement_(computer_science)
https://en.wikipedia.org/wiki/Expression_(computer_science)
https://en.wikipedia.org/wiki/Declaration_(computer_programming)

*** EBNF Patterns

EBNF descriptions and their best associated tree-sitter grammar DSL translations.

**** Wrapped Optional-List with Delimiters

Common pattern where an optional list is wrapped by some tokens (e.g. parentheses), and the list itself allows an optionally trailing delimiter (e.g. a comma).

Two further variants where the list allows zero-or-more =*= delimit-repeated elements, or optionally one-more =?= delimited element.

#+begin_example
Foos = '(' FoosList? ')'
FoosList = Lorem ( ',' Lorem )? ','?
#+end_example

This tree-sitter rule flattens EBNF =Foos= and =FoosList=. Since FoosList is optional in the Foos rule =sepBy= is used instead of =sepBy1=, the latter of which would require at least one occurrence. Finally =Lorem= is another rule unto itself.

#+begin_src js
seq(
    '(',
    sepBy($.lorem, ','),
    optional(','),
    ')',
)
#+end_src

**** TODO Items in Body
e.g.     /// TraitBody = '{' ( OuterDocComments TraitItem )* '}'

Are there other places like struct/impl/enum/function bodies where this can be reduced?

*** Grammar Changelog

Upstream grammar changes to Noir.

**** v0.36.0 to v1.0.0-beta.19

- [X] where_clause.rs
- [X] module.rs

***** TODO eat_non_underscore_ident changes
:LOGBOOK:
- State "TODO"       from              [2026-02-19 Thu 18:36]
:END:

A bunch of nodes now use eat_non_underscore_ident versus just eat_ident, do we want to enforce that at the ts grammar level? Seems like extra complexity for no gain to me.

- [ ] Trait
- [ ] ModOrContract
  
***** Traits

****** TODO Is it worth it enforcing traits cannot be lone underscore identifiers?
:LOGBOOK:
- State "TODO"       from              [2026-02-19 Thu 15:13]
:END:

Probably not. TS grammar doesn't have to be compiler-level correct (and cannot be as previously discovered). If it doesn't add too much complexity to the compiled parser then sure.

Line 29 of traits.rs for v1.0.0-beta.19 noir shows it's all non-underscore identifiers.

****** TODO Review diff of parser/traits.rs
:LOGBOOK:
- State "TODO"       from              [2026-02-18 Wed 23:27]
:END:

- [ ] Looks like there's new trait syntax from the EBNF, current tests also fail at loci which appears to introduce said new syntax: noir/noir_stdlib/src/hash/mod.nr        183,4 - 186,0
  
**** TODO Misc
:LOGBOOK:
- State "TODO"       from              [2026-02-18 Wed 20:11] \\
  Viewing diffs in ediff, kinda hard to get the commit associated with a change in this way. Would need to open in magit and blame, so just collecting this without commit attribution.
:END:

parser.rs
~parse_program_with_dummy_file~
~for_str_with_dummy_file~
(94) token: SpannedToken -> LocatedToken
(96) Span -> Location

(104) Comments for a statement are now tracked (for reasons), apparently ~unsafe~ expressions can be commented in their containing statements?
#+begin_src
    /// The current statement's comments.
    /// This is used to eventually know if an `unsafe { ... }` expression is commented
    /// in its containing statement. For example:
    ///
    /// ```noir
    /// // Safety: test
    /// let x = unsafe { call() };
    /// ```
#+end_src

(125) lexer can be configured to skip lexing comments (false, don't skip by default)

Update Parser.eat_kind's docs in noir_grammar.org because eat_kind has slightly changed (LocatedToken). Also need to double check the self.token.kind() function it's talking about hasn't changed.

(278) some new function eat_non_underscore_ident, may affect grammar not clear yet.

(356) FmtStrFragment in eat_fmt_str

***** TODO eat_attribute_start, eat_inner_attribute_start
:LOGBOOK:
- State "TODO"       from              [2026-02-18 Wed 20:47] \\
  Consequential behaviour?
:END:

(393) eat_attribute_start, see the comment here, consequences?
(412) eat_inner_attribute_start comments and the entire function

***** TODO eat_unquote_marker
:LOGBOOK:
- State "TODO"       from              [2026-02-18 Wed 20:45] \\
  Looks potentially important.
:END:

(380) eat_unquote_marker, did this actually replace eat_comma{s} or just a diff quirk?

***** TODO LocatedToken vs SpannedToken
:LOGBOOK:
- State "TODO"       from              [2026-02-18 Wed 20:25] \\
  Difference
:END:

***** TODO skip_to_recovery_point, location_since
:LOGBOOK:
- State "TODO"       from              [2026-02-18 Wed 20:49] \\
  Recovery points might change grammar structure, but unsure yet so maybe this is important.
:END:

(550) recovery points =;=, =}=, =EOF=.

***** TODO modifiers_not_followed_by_an_item new requirement
:LOGBOOK:
- State "TODO"       from              [2026-02-18 Wed 20:51] \\
  Consequential?
:END:

(675) mutable_not_followed_by_an_item

*** Coverage TODOs

It's a bit hard (currently) to track general-coverage TODOs within =noir_grammar.org= itself, and I have yet to dive-deep into org-agenda which might be able to construct such a view. However there are a lot of other TODOs specific to each headline they are under. Here is a general "overview" of areas of the grammar that need to be done as a way to "save progress" for when future Jordan comes back to work on =noir_grammar.org=.

**** TODO Accomodations for validate_secondary_attributes in parser logic
:LOGBOOK:
- State "TODO"       from              [2026-02-19 Thu 16:11]
:END:

Appears in various parers, anything actually needed that concerns the tree-sitter grammar?
- [ ] Trait

**** TODO Workflow for updating grammar sources and checking for new changes
:LOGBOOK:
- State "TODO"       from              [2026-02-18 Wed 19:00]
:END:

1. [ ] Update submodule
2. [ ] Examine changelog notes from each tag between release then and now?
   :: e.g. via ~git tag -l "v*" --sort=version:refname   --merged v1.0.0-beta.19   --no-merged v0.36.0~ executed in noir submodule
3. [ ] (instead of/in-addition to) look at diff between frontend files themselves from release then/now? Or maybe that first and then changelog notes for anything missed?

**** TODO Document git sparse checkout submodule of noir
:LOGBOOK:
- State "TODO"       from              [2026-02-16 Mon 18:15]
:END:

I cannot remember how I set up that submodule and assured that it was a sparse checkout, silly past me for not making note of this. Or maybe I did and it's somewhere not immediately obvious (also bad). Re-figure that out and make note of it.

***** Very rough

o - submodules
l - list them
press enter on noir, it'll open a new magit for that submodule with said submodule as the git project in question
^^ at this point you can also examine why (at least at time of writing) its marked as dirty and remove those changes so the tree is clean etc

now we're on the submodule as a repo, we want to checkout a new commit. At time of writing that'll be tag (for commit 99bb8b5):
v1.0.0-beta.18

f
u
^^ to fetch latest information from remote

b
b
v1.0.0-beta.18
RET

----

list all non-nightly tags between tag A and B. Ignores nightly tag spam as those don't begin with "v" and we enforce pattern match on tags starting with "v"

git tag -l "v*" --sort=version:refname   --merged v1.0.0-beta.18   --no-merged v0.36.0

**** TODO Organise PROJECT.org and noir_grammar.org
:LOGBOOK:
- State "TODO"       from              [2026-02-18 Wed 18:50]
:END:

How much of noir_grammar.org can be chipped away as verbose/unneeded, how much of PROJECT.org can be cleaned up. Should the files be merged? Etc etc.

**** TODO Automatically install the associated Nargo for the current language grammar
:LOGBOOK:
- State "TODO"       from              [2026-02-16 Mon 18:53]
:END:

Required because various project commands like ~just test-vocab~ execute nargo and if it's out of sync (like just now I still have nargo 0.36.0 against noir v1.0.0-beta.18) then it's obviously not going to work. This is really just a pre-run sanity check that the Noir source is valid according to Noir itself but I think it's still important all the time, but not urgent.

This should be part of project's justfile and runbook

**** TODO The other fields in tree-sitter.json for email, domain, funding etc
:LOGBOOK:
- State "TODO"       from              [2026-02-16 Mon 18:17]
:END:

General project polish in a sense, low priority though.

**** TODO Migrate to QuickJS instead of requiring Bun
From v0.26.1 I think we don't need a JS runtime of any kind now (explicitly) which simplifies project dependencies so let's migrate to that approach

**** TODO Use Supertypes instead of underscore containers since they handle the same thing and result in a less verbose grammar.js definition?
See this recent commit that actually explains how supertypes and friends work: https://github.com/tree-sitter/tree-sitter/pull/4825/changes

**** TODO ExpressionStatement requires some grammar re-structuring

The addition of ExpressionStatement as-is results in rule conflicts, and while those conflicts could be solved with some precedence settings they shouldn't really be happening in the first place I feel. Let's table ExpressionStatement for now and continue with other things and once all the known places Statement is elucidated appropriate action can be taken.

If it is only as seen now then we probably inline each =;= for each StatementKind and have Statements within a Block have the final Statement mark =;= optional.

**** TODO UseTree grammar refinement

Not happy with how UseTree CST is, use_list feels different to use_alias and the docs in my org file are a bit out of sync (see pgd also) with how UseTree is parsed, mostly because it's a bunch of nesting etc. The grammar works and is correct (aside from some perhaps edge cases, and more testing for alias) but since I plan to redo how that CST is constructed I won't bother making the further tests for it right now.

**** TODO Integrate effects of validate_secondary_attributes into grammar?

Some items call ~validate_secondary_attributes~ at the top of their parser function, is there a realistic gain to implementing those effects into the ts grammar?

Affected nodes:
- ModOrContract
- Struct

**** TODO Literal grammar.js to tangled hithere.js

Finish converting the various forms that are in the literal =grammar.js= to tangled versions (currently in) =hithere.js=.

- [-] Declarations
  - [ ] Function definition
  - [X] Visibility modifier
  - [X] Function modifiers
  - [ ] Parameter list (i.e. function parameters)
  - [ ] Block
  - [ ] Attribute
  - [ ] Use tree
  - [ ] Attribute path
- [ ] Expressions
  - [ ] Identifier
- [-] Top-of-file
  - [ ] REG_ALPHANUMERIC
  - [ ] REG_NUMERIC
  - [ ] REG_ASCII_PUNCTUATION
  - [X] Modifiers
  - [ ] Numeric types

**** TODO Contribute EBNF grammar changes and new additions to upstream Noirc

- [ ] [[file:noir_grammar.org::#h:65B0176B-B46F-4679-8535-C504870AC048][ident]] :: identifier regex (but might need to convert into EBNFs weird xD or whatever stuff)
- [ ] [[file:noir_grammar.org::#h:54ACA91F-70A8-4121-A799-F872DDCAF240][bool]]
- [ ] [[file:noir_grammar.org::#h:F5A79701-65C9-4FEA-83D8-2413C585A5FA][ItemVisibility]] :: don't need to specify 'nothing'
- [ ] [[file:noir_grammar.org::#h:02355489-DDCD-4E67-BB39-5DF3F0BC0A8A][TraitConstant]] :: see inline task at target for proper EBNF
- [ ] [[file:noir_grammar.org::#h:96FCF9AD-3B89-451B-B84D-90A7A625B56D][PathKind]] ::  see inline task at target
- [ ] [[file:noir_grammar.org::#h:ADB184CE-E43C-423B-803F-DE1679A91829][Use]] :: see inline task at target
- [ ] [[file:noir_grammar.org::#h:A051D0D5-7007-4DF8-83B7-FB4EFF9C383E][PathNoTurbofish]] :: see inline task at target

**** TODO Rename ts rules for ItemKind items so they are xxx_item
i.e. function becomes function_item etc

**** TODO Rename struct_field_list and struct_field_item
Rename to field_declaration_list and field_declaration respectively? We already know they are for structs because they are inside a struct_item

**** TODO Duplicate production locuses e.g. if_expression

IfExpression is under Statement, and also under Expression. Now that is the case in the literal EBNF but it likely doesn't have to be the case in the tree-sitter grammar. Once the grammar is done look at de-duplicating this if it is applicable. However of course tests where expression-statement is to be expected need to still pass.

***** TODO ParenthesizedTypeExpression and ParenthesizedExpression

**** TODO Decide on rule names for ConstructorExpression and StructPattern
Very similar rules, any possible merging and unification of naming style for fields?

**** TODO Function return type similar to lambda return type
I've decided to wrap the -> into the rule, we do this for parameters, bodies and a bunch of other constructs so why not for return type? Function still needs the return_type field so also take a similar approach there unless I change my mind. See: Lambda.

**** TODO Impl type object generics, parameters or arguments?
Parameters being a declaration of what it can accept, arguments being concrete things passed in. For syntax like: impl<T> Option<T> {}    is the T in Option<T> a type /parameter/ or a type /argument/. It's an argument right? If so, adjust CST accordingly.

Also add a test for this into Noirc impls.rs

**** TODO Attribute content and str content potential external scanner
Found when trying to parse Noir stdlib locus referenced in this commit, because line_comment is (correctly) an extra (and thus can occur anywhere), URLs within strings are being incorrectly parsed as line comments within said strings which break the parser. In order to tell the external scanner that line comments (if we're within a string) are not actually line comments we need to add a rule (string_content) to the external scanner so we can check if we're within it (string_content), and if we are to refuse creating a line_comment at this point.
    noir/noir_stdlib/src/ec/tecurve.nr      136,54 - 137,73
    but also actually at line 30 (or off-by-1 ts line 29)
    
**** TODO Unquote
Added quote via external scanner but it keeps everything quoted. Add unquote to the scanner and unskip the associated tests (as well as update their CSTs) accordingly.

*** Debugging

Using either =gdb= raw on the CLI or =dape= in Emacs, interfacing with =gdb= via Debug Adapter Protocol.

Gdb =s= will step over/in the next logical line of source code. It will step into function calls if it knows where to find the source for it.

=n= is like =s= except it will /never/ step into functions.

Build the =scanner_debug.c= file which is a minimal template to invoke the scanner in a way which is easily debuggable. Trying to do so via the tree-sitter cli doesn't work. Build command is in script =debug_scanner.sh=.

**** Dape

#+begin_example
watch valid_symbols
watch (uint8_t)state->pound_count
watch (uint8_t)pounds
watch (char)lexer->lookahead
#+end_example

**** Gdb

#+begin_example
set breakpoint pending on
b tree_sitter_noir_external_scanner_scan
r
display (char)lexer->lookahead
display (uint8_t)state->pound_count
display (uint8_t)pounds
display *valid_symbols@(TOKENTYPE_NR)
#+end_example

*** DONE Clean up external scanner logic for block comment content
CLOSED: [2025-06-05 Thu 16:37]

=scanner.c= It works, and correctly (by current tests and parser complexity) fine. I hastily put it together so I think a bit of DRYing up may be warranted but DRY can be taken way too far so it could also be perfectly valid as-is. Either way, not a major concern right now at all and more of a "polish" item once the grammar is complete.

*** TODO When noir_grammar.org is opened have transclusion for Grammar heading run

Want to trigger transclusion on that subheading and all it's children only (by default) because babel tangle or saving the file triggers export so we could accidentally export a partially constructed grammar.js if those transclusions are not automatically made.

To be clear those transclusions are the targets to other js source blocks for the tree-sitter js dsl.

*** DONE Update tree-sitter 0.25.8 to 0.26.5
CLOSED: [2026-02-16 Mon 17:26]
:LOGBOOK:
CLOCK: [2026-02-16 Mon 17:11]--[2026-02-16 Mon 17:54] =>  0:43
- No action taken to change anything in the grammar itself, just updated the tree-sitter version in the project and re-built and re-ran all tests (which pass). Incremental improvements from the latest tree-sitter features should be done separately later.
CLOCK: [2026-02-13 Fri 20:28]--[2026-02-13 Fri 21:21] =>  0:53
- Read all changelog items from 0.25.8 to 0.26.5 and made note of (probably) important ones.
CLOCK: [2026-02-10 Tue 21:25]--[2026-02-10 Tue 21:50] =>  0:25
:END:

- https://github.com/tree-sitter/tree-sitter/releases/tag/v0.25.9
- https://github.com/tree-sitter/tree-sitter/releases/tag/v0.25.10
- https://github.com/tree-sitter/tree-sitter/releases/tag/v0.26.1
- https://github.com/tree-sitter/tree-sitter/releases/tag/v0.26.2
- https://github.com/tree-sitter/tree-sitter/releases/tag/v0.26.3
- https://github.com/tree-sitter/tree-sitter/releases/tag/v0.26.4
- https://github.com/tree-sitter/tree-sitter/releases/tag/v0.26.5

**** v0.25.9

Reserved words DSL
- https://github.com/tree-sitter/tree-sitter/pull/3896
- https://github.com/tree-sitter/tree-sitter/pull/4650
- https://github.com/tree-sitter/tree-sitter/pull/4661

Allow ERROR nodes to match when they're children in queries
- https://github.com/tree-sitter/tree-sitter/pull/4748
- https://github.com/tree-sitter/tree-sitter/pull/4747

Error when generating parser with indirectly recursive single state transitions
- https://github.com/tree-sitter/tree-sitter/pull/4790
- https://github.com/tree-sitter/tree-sitter/pull/4786

Use correct state id when adding terminal states to non terminal extras
- https://github.com/tree-sitter/tree-sitter/pull/4794
- https://github.com/tree-sitter/tree-sitter/pull/4792

**** v0.26.1

feat: remove the need of an external JS runtime for processing grammars
- https://github.com/tree-sitter/tree-sitter/pull/3780

docs: add more information on supertype nodes for grammars and queries
- https://github.com/tree-sitter/tree-sitter/pull/4825

Warn about unreachable variables
- https://github.com/tree-sitter/tree-sitter/issues/4565
- https://github.com/tree-sitter/tree-sitter/pull/4567

feat: Only evaluate grammar.js to grammar.json
- https://github.com/tree-sitter/tree-sitter/pull/4601

fix(docs): update test command flag from -f to -i
- https://github.com/tree-sitter/tree-sitter/pull/4263

fix(highlight): account for multiple rows in highlight testing assertions
- https://github.com/tree-sitter/tree-sitter/pull/4333

feat(cli): add grammar-path to various subcommands
- https://github.com/tree-sitter/tree-sitter/pull/4358

feat(cli): rebuild parsers by default when --grammar-path is passed.
- https://github.com/tree-sitter/tree-sitter/pull/4498

feat(test): allow cst as expected output of test case
- https://github.com/tree-sitter/tree-sitter/pull/4633

feat(cli): allow users to specify dynamic libraries directly
- https://github.com/tree-sitter/tree-sitter/pull/4645

tree-sitter version with no arguments displays current version / feat(cli): Version updates (#4179)
- https://github.com/tree-sitter/tree-sitter/issues/4179
- https://github.com/tree-sitter/tree-sitter/pull/4205

fix(cli): show rule names for rules with metadata / Allow regex to be used for reserved words
- https://github.com/tree-sitter/tree-sitter/pull/4739

***** Misc

[[https://github.com/tree-sitter/tree-sitter/pull/4213][#4213]] Ignore external tokens that are zero-length and extra
[[https://github.com/tree-sitter/tree-sitter/pull/4276][#4276]] fix(cli): properly escape invisible characters in parse error output
[[https://github.com/tree-sitter/tree-sitter/pull/4284][#4284]] fix(make): make install shouldnâ€™t fail when a parser bundles no queries
[[https://github.com/tree-sitter/tree-sitter/pull/4338][#4338]] Add @generated to parser.c header
[[https://github.com/tree-sitter/tree-sitter/pull/4466][#4466]] docs: mention ~ and $HOME for parser-directories
[[https://github.com/tree-sitter/tree-sitter/pull/4512][#4512]] build(rust): use $CARGO_PKG_RUST_VERSION when generating bindings
[[https://github.com/tree-sitter/tree-sitter/pull/4509][#4509]] fix(docs): replace TSInput by TSInputEdit in "Advanced Parsing"
[[https://github.com/tree-sitter/tree-sitter/pull/4712][#4712]] feat(lib): add lldb pretty-printers for some C lib types
[[https://github.com/tree-sitter/tree-sitter/pull/4744][#4744]] fix(lib): check if an ERROR node is named before assuming it's the builtin error node
[[https://github.com/tree-sitter/tree-sitter/pull/4769][#4769]] feat(test): pin fixture grammars to specific commits
[[https://github.com/tree-sitter/tree-sitter/pull/4764][#4764]] fix(cli): canonicalize --lib-path arguments
[[https://github.com/tree-sitter/tree-sitter/pull/4232][#4232]] Place APIs for generating grammars from a file behind a feature flag
[[https://github.com/tree-sitter/tree-sitter/pull/4117][#4117]] Remove tree-sitter dependency from tree-sitter-generate
[[https://github.com/tree-sitter/tree-sitter/pull/4847][#4847]] build: add static and shared targets to Makefile
[[https://github.com/tree-sitter/tree-sitter/pull/4846][#4846]] feat: add API for editing points and ranges
[[https://github.com/tree-sitter/tree-sitter/pull/4647][#4647]] docs: update options for generate command
[[https://github.com/tree-sitter/tree-sitter/pull/4877][#4877]] fix(lib): account for unreachable patterns with children
[[https://github.com/tree-sitter/tree-sitter/pull/4889][#4889]] feat: add option to disable parse state optimizations
[[https://github.com/tree-sitter/tree-sitter/pull/5076][#5076]] fix(docs): final updates before 0.26.1
[[https://github.com/tree-sitter/tree-sitter/pull/5100][#5100]] Add "containing range" APIs to QueryCursor rebased

**** v0.26.4

fix(cli): increase verbosity of tree-sitter init -u updates
- https://github.com/tree-sitter/tree-sitter/pull/5178

feat(cli): concurrent builds of the same grammar on different locations on disk
- https://github.com/tree-sitter/tree-sitter/pull/5174

*** DONE Update tree-sitter from 0.24.3 to 0.25.3
CLOSED: [2025-04-22 Tue 16:43]

Part of updating tree-sitter means taking advantage of improvements. I skimmed the release notes a few weeks ago and there's some good stuff (especially with putting generated bindings somewhere other than top-level).

**** DONE Changelog goodies
CLOSED: [2025-04-22 Tue 15:28]

***** Actively useful

****** Internal ABI bump to 15

Language name, version, supertype info, and reserved words are added to the parsers. Requires =tree-sitter.json= to get this information from.

****** Add reserved keywords to grammar DSL

Implemented: https://github.com/tree-sitter/tree-sitter/pull/3896

******* TODO Take advantage of this for Noir's grammar

****** RustRegex added to grammar DSL

Supports more powerful regex features than JavaScript's.

Implemented: https://github.com/tree-sitter/tree-sitter/pull/4076

****** Set output directory for generated binding sources

Implemented: https://github.com/tree-sitter/tree-sitter/pull/2614

****** CLI version subcommand to bump version in all generated binding sources

Implemented: https://github.com/tree-sitter/tree-sitter/pull/3786

****** CLI parse command pretty print output

Provide ~--cst~ or ~-c~ to ~parse~ subcommand.

Implemented: https://github.com/tree-sitter/tree-sitter/pull/3762

****** CLI test filter by name

Provide ~--include~ of test names to ~test~ subcommand.

Implemented: https://github.com/tree-sitter/tree-sitter/pull/4095

****** Show parse times, and edit times in testing output

Implemented: https://github.com/tree-sitter/tree-sitter/pull/3939
Implemented: https://github.com/tree-sitter/tree-sitter/pull/4016

****** CLI parse, highlight, query, tag, accept arguments from stdin

Implemented: https://github.com/tree-sitter/tree-sitter/pull/4054

***** Good to know about

****** Schema for tree-sitter.json

Implemented: https://github.com/tree-sitter/tree-sitter/pull/3947
Schema: https://tree-sitter.github.io/tree-sitter/assets/schemas/config.schema.json

****** Query nodes with MISSING

Implemented: https://github.com/tree-sitter/tree-sitter/pull/3887

****** CLI HTML output classes instead of inline styles

Implemented: https://github.com/tree-sitter/tree-sitter/pull/3879

****** Get SuperType information

Implemented: https://github.com/tree-sitter/tree-sitter/pull/3938

****** JSON parser generate errors

Implemented: https://github.com/tree-sitter/tree-sitter/pull/4048

****** More detailed project boilerplate generation

Useful to just see what extra configuration might be good.

Implemented: https://github.com/tree-sitter/tree-sitter/pull/4142

****** Support Bun single-file executable

Implemented: https://github.com/tree-sitter/tree-sitter/pull/3905
Related: https://github.com/tree-sitter/tree-sitter-typescript/pull/318

****** Guidance on common DSL node naming conventions

Implemented: https://github.com/tree-sitter/tree-sitter/pull/4148/files
