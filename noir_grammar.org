#+TODO: TODO(t@) TOIMPL(i@) SPEC(r@) BLOCK(b@) UPGR(u@) | DONE(d!)
#+STARTUP: indent logdone logdrawer content lognoteclock-out
# ------------------------------------------------------
#+NOIR_TEMPLATE_URL: https://github.com/noir-lang/noir/blob/%h/%p#L%lC%c-L%lC%s
# ------------------------------------------------------
#+TITLE: Noir Tree-sitter Grammar
#+AUTHOR: Jordan Ellis Coppard
#+LANGUAGE: en
#+OPTIONS: ^:{}

All notes currently against upstream commit {{{keyword(NOIR_VERSION)}}}.

Noir's syntax isn't officially specified currently; expected given the language is pre 1.0. So, here are notes and links to compiler infrastructure to ascertain language minutia.

* Compiler                                                            :noirc:
:PROPERTIES:
:ID:       9405296D-1F11-4E7E-8306-401487D24999
:END:

Noir's compiler frontend performs parsing and lexing at the same time; the parser internally lexes the target file(s).

*************** TODO Needs updating to v1.0.0-beta.19
:LOGBOOK:
- State "TODO"       from              [2026-02-18 Wed 21:07] \\
  Token, Span, SpannedToken are different in v1.0.0-beta.19 so this needs updating.
:END:
The lexer transforms an iterator of characters into an iterator of ~SpannedToken~; each ~Token~ having a ~Span~ (delimited region in source file). ~Spans~ are owned by AST nodes which forms the (initial) parsing result.
*************** END

Concerning Noir's frontend compiler:
- Tag =node= being used as a non-terminal symbol.
- Tag =leaf= used as a terminal symbol.

** Lexing

TODO: Rename this header, idk?

*** Code whitespace

Whitespace is not significant in Noir.
#+transclude: [[file:noir/compiler/noirc_frontend/src/lexer/lexer.rs][Lexer::eat_whitespace()]]  :lines 703-704 :src rust

Newline, tab, carriage return, ASCII space.
#+transclude: [[file:noir/compiler/noirc_frontend/src/lexer/lexer.rs][Lexer::is_code_whitespace()]]  :lines 699-700 :src rust

** Parsing
:PROPERTIES:
:CUSTOM_ID: h:DB42728E-09AF-4189-B2BE-E48853E5C1D9
:END:

Parser entry at [[file:noir/compiler/noirc_frontend/src/parser/parser.rs::pub fn parse_program(source_program: &str, file_id: FileId)][parse_program]] yields tuple ~(ParsedModule, Vec<ParserError>)~.
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/mod.rs::pub struct ParsedModule {][ParsedModule struct]]  :lines 1-4 :src rust

~ItemKind~ enum reveals some basic top-level structure.
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/mod.rs::pub enum ItemKind {][ItemKind enum]]  :lines 1-14 :src rust

** Structure

Subtree layout here is for documentation, does not represent 1:1 Noir's AST.

*** DONE Program
CLOSED: [2026-02-18 Wed 21:04]
:PROPERTIES:
:CUSTOM_ID: h:A8A4AE5F-6FDB-4091-87DA-E4BCE320452C
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2026-02-18 Wed 21:04]
- State "TODO"       from "DONE"       [2026-02-18 Wed 21:02] \\
  Update parser function and EBNF search.
- State "DONE"       from "TODO"       [2025-05-25 Sun 17:51]
:END:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser.rs::fn parse_program(&mut self)][parse_program()]]

#+name: ,ebnf_program
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser.rs::/// Program =][Program doc]]  :lines 1- :src fundamental :end "pub(crate) fn parse_program"

*** DONE Module
CLOSED: [2026-02-19 Thu 20:02]
:PROPERTIES:
:CUSTOM_ID: h:649C4EE8-8F15-4F45-8EA6-3AD48A893930
:END:
:LOGBOOK:
- State "DONE"       from "SPEC"       [2026-02-19 Thu 20:02] \\
  No apparent change.
- State "SPEC"       from "TODO"       [2025-05-25 Sun 17:52]
:END:

This /is/ ~ParsedModule~ (see: [[#h:DB42728E-09AF-4189-B2BE-E48853E5C1D9][Parsing]]). So a Module represents one parsed source-file, but they may appear inline (see: [[#h:9204514E-E5FC-488B-8066-66F0D9AF0C85][ModOrContract]]).

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser.rs::fn parse_module(&mut self, nested: bool)][parse_module()]]

#+name: ,ebnf_module
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser.rs::/// Module =][Module doc]]  :lines 1- :src fundamental :end "pub(crate) fn parse_module("

*** TODO DocComments                                               :pseudo:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-06-05 Thu 16:59]
- State "TODO"       from              [2025-05-25 Sun 20:33] \\
  Restructure, putting {Inner,Outer}DocComments under this.
:END:

InnerDocComments and OuterDocComments only differ in the ~DocStyle~ associated (see [[#h:E866B8E1-2736-4A62-938B-0FD416C4A088][comment lexing]]). They are both comprised of [[#h:E866B8E1-2736-4A62-938B-0FD416C4A088][comment]], are both allowed at top-level, and have effectively identical parsing. For brevity, they are parsed generally via:

Calls [[#h:AC5A6E2C-59EC-44C6-9D1E-52553E56C3F9][eat_kind]] with ~TokenKind::{Inner,Outer}DocComment~, so matched tokens from lexing are [[#h:155F78B1-495B-4F49-BFED-82369979A23E][line_comment]] and [[#h:5B512D17-7FD5-4FD5-B4AA-C1B27A9E6FCA][block_comment]] so long as they have ~DocStyle::{Inner,Outer}~.

A string of the matched comments contents is then returned. The contents (see lexing) exclude the glue-token prefix and (closing suffix for block comments).

**** UPGR InnerDocComments
:PROPERTIES:
:CUSTOM_ID: h:C58B2CB4-FF62-49BB-AFFD-1BADF4462B9D
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-06-05 Thu 16:57]
:END:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/doc_comments.rs::fn parse_inner_doc_comments(&mut self)][parse_inner_doc_comments()]], [[file:noir/compiler/noirc_frontend/src/parser/parser/doc_comments.rs::fn parse_inner_doc_comment(&mut self)][parse_inner_doc_comment()]]

#+name: ,ebnf_inner_doc_comments
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/doc_comments.rs::6][InnerDocComments doc]]  :lines 6-6 :src fundamental

*************** TODO Look at BorrowedToken
Not strictly related to this headline only, just while looking around. In token.rs enum BorrowedToken represents a token in noirs grammar. So, all the token types are there.
*************** END

**** UPGR OuterDocComments
:PROPERTIES:
:CUSTOM_ID: h:FB5478BF-5E66-4686-931B-733349F83FD8
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-06-05 Thu 16:57]
:END:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/doc_comments.rs::fn parse_outer_doc_comments(&mut self)][parse_outer_doc_comments()]], [[file:noir/compiler/noirc_frontend/src/parser/parser/doc_comments.rs::fn parse_outer_doc_comment(&mut self)][parse_outer_doc_comment()]]

#+name: ,ebnf_outer_doc_comments
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/doc_comments.rs::19][OuterDocComments doc]]  :lines 19-19 :src fundamental

*** TODO Item
:PROPERTIES:
:CUSTOM_ID: h:8CC1D239-66B1-45A9-BB71-66AF07161479
:END:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/item.rs::fn parse_module_items(&mut self, nested: bool)][parse_module_items()]], [[file:noir/compiler/noirc_frontend/src/parser/parser/item.rs::fn parse_module_item_in_list(&mut self, nested: bool)][parse_module_item_in_list()]], [[file:noir/compiler/noirc_frontend/src/parser/parser/item.rs::fn parse_item(&mut self)][parse_item()]]

#+name: ,ebnf_item
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/item.rs::87][Item doc]]  :lines 87-87 :src fundamental

- Parsed without separator (~Parser::parse_module_items~).
- ~Parser::parse_module_item_in_list~.

**** UPGR ItemKind
:PROPERTIES:
:CUSTOM_ID: h:D661B191-E117-4EB9-B6F7-322B7B67A79F
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-07-23 Wed 00:27]
:END:

- [[#h:AE3747A8-8CA3-4B6D-AF09-3553CE24CD70][InnerAttribute]]
- [[#h:FF901AEF-D40D-44AB-9BA6-C324F3531088][Attribute]]
- [[#h:2A9D09A5-2E52-4B8C-ABA1-0B3B953F093C][Modifiers]]
- [[#h:ADB184CE-E43C-423B-803F-DE1679A91829][Use]]
- [[#h:9204514E-E5FC-488B-8066-66F0D9AF0C85][ModOrContract]]
- [[#h:A53DF633-322A-464B-9947-E56B64A112C7][Struct]]
- [[#h:954A182F-703F-48FC-85D3-37C11EC959A3][Implementation]]
- [[#h:6C38714F-76B7-4472-A776-36023EB84873][Trait]]
- [[#h:C21A19F9-DC0C-4F17-9739-B92412D0C4FF][Global]]
- [[#h:220925BB-96BF-4D6F-B7E1-EA39B98A8F05][TypeAlias]]
- [[#h:B3C4609F-307A-42A1-B420-DBBAB6CDE6E5][Function]]

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/item.rs::fn parse_item_kind(&mut self)][parse_item_kind()]]

*************** TODO Some attribute thing from ages ago idk
TODO: Does this mean that in a list of attributes #[foo] #[bar] #![bing] #[bong] that foo and bar are grouped as attributes, the inner attribute bing breaks that group, and then bong is itself in another group later on? Given that inner attribute makes parse_item_kind return early.
*************** END

#+name: ,ebnf_item_kind
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/item.rs::97][ItemKind doc]]  :lines 97-108 :src fundamental

***** UPGR Attributes
:PROPERTIES:
:ID:       DA6150E7-E986-4749-A481-A95FF1368B74
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-06-05 Thu 20:03]
- State "TODO"       from              [2025-06-05 Thu 18:56] \\
  To contain Attributes and InnerAttribute
:END:

Calls [[#h:AC5A6E2C-59EC-44C6-9D1E-52553E56C3F9][eat_kind]] with ~TokenKind::{Attribute,InnerAttribute}~, so matched tokens from lexing are [[#h:22DB13A6-D91E-4240-8711-10ED6DEE1C6E][attribute]].

*************** TODO In Noir's AST are these really "declarations"? Organise as appropriate later
I don't see such a thing yet, but given how closely Noir is modelled after Rust's syntax I'll bin these as declarations /for now/
*************** END
*************** TODO Organise this info from old attributes notes and structure
Primary or Secondary; depending on how many can be applied to a function.

- Primary: one (alters a functions ACIR output).
- Secondary: unlimited.

  [[file:noir/compiler/noirc_frontend/src/lexer/token.rs][FunctionAttribute]]
*************** END
*************** TODO Include tag, inner, and primary/secondary as part of tree-sitter parser or nah?
*************** END
*************** TODO Attribute splits on ( and ) as sub-tokens?
*************** END
*************** TODO Attributes further captures
Attributes have some further captures in the Noir lexer, e.g. `foreign` captures a name afterwards. So do that also (and for the secondary attributes).
*************** END

****** UPGR InnerAttribute                                        :leaf:
:PROPERTIES:
:CUSTOM_ID: h:AE3747A8-8CA3-4B6D-AF09-3553CE24CD70
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "SPEC"       [2025-06-05 Thu 20:03]
- State "SPEC"       from "TODO"       [2025-06-05 Thu 19:10]
:END:
:pgd:
+ [[#h:22DB13A6-D91E-4240-8711-10ED6DEE1C6E][attribute]] (token, with ~TokenKind::InnerAttribute~)
:end:

Parser (sop): [[file:noir/compiler/noirc_frontend/src/parser/parser/item.rs::if let Some(kind) = self.parse_inner_attribute() {][parse_inner_attribute() parent]]
Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/attributes.rs::pub(super) fn parse_inner_attribute(&mut self)][parse_inner_attribute()]]
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/attributes.rs::11][InnerAttribute doc]]  :lines 11-11 :src fundamental

*************** TODO Relevance of this old comment and associated GH issue?
Can be any valid [[SecondaryAttribute]] and is purely a syntactical convenience to apply to it's container versus attribute definitions piled at containers definition. See [[https://github.com/noir-lang/noir/issues/5875][issue]] for more.
*************** END

****** UPGR Attribute                                             :leaf:
:PROPERTIES:
:CUSTOM_ID: h:FF901AEF-D40D-44AB-9BA6-C324F3531088
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "SPEC"       [2025-06-05 Thu 20:03]
- State "SPEC"       from "TODO"       [2025-06-05 Thu 19:16]
:END:
:pgd:
+ (rep0) [[#h:22DB13A6-D91E-4240-8711-10ED6DEE1C6E][attribute]] (token, with ~TokenKind::Attribute~)
:end:

Parser (sop): [[file:noir/compiler/noirc_frontend/src/parser/parser/item.rs::let attributes = self.parse_attributes();][parse_attributes() parent]]
Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/attributes.rs::pub(super) fn parse_attributes(&mut self)][parse_attributes()]], [[file:noir/compiler/noirc_frontend/src/parser/parser/attributes.rs::fn parse_attribute(&mut self)][parse_attribute()]]
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/attributes.rs::20][Attributes doc]]  :lines 20-20 :src fundamental

In parent all the parsed attributes are collected.

***** UPGR Modifiers
:PROPERTIES:
:CUSTOM_ID: h:2A9D09A5-2E52-4B8C-ABA1-0B3B953F093C
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "SPEC"       [2025-07-14 Mon 14:54]
- State "SPEC"       from "TODO"       [2025-05-20 Tue 18:06]
:END:

#+name: modifier_unconstrained
#+begin_src js :rule unconstrained_modifier
'unconstrained'
#+end_src

#+name: modifier_comptime
#+begin_src js :rule comptime_modifier
'comptimez'
#+end_src

#+name: modifier_mut
#+begin_src js :rule mutable_modifier
'mut'
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/modifiers.rs::fn parse_modifiers(&mut self, allow_mutable: bool)][parse_modifiers()]]

#+name: ,ebnf_modifiers
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/modifiers.rs::17][Modifiers doc]]  :lines 17-17 :src fundamental

*************** TODO Apparently Traits call parse_modifiers
Using eglot to show the call hierarchy Traits apparently call this parser, so when we ge to Traits have a looksey I guess.
*************** END

****** DONE ItemVisibility
CLOSED: [2026-02-18 Wed 23:19]
:PROPERTIES:
:CUSTOM_ID: h:F5A79701-65C9-4FEA-83D8-2413C585A5FA
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2026-02-18 Wed 23:19] \\
  No change.
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "SPEC"       [2025-07-14 Mon 14:56]
- State "SPEC"       from "DONE"       [2025-06-05 Thu 20:14] \\
  Don't actually have any tests for this yet
- State "DONE"       from "TODO"       [2024-11-01 Fri 19:56]
:END:

#+name: item_visibility
#+begin_src js :rule visibility_modifier :arg $ :ast ItemVisibility
seq('pub', optional('(crate)'))
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/item_visibility.rs::fn parse_item_visibility(&mut self)][parse_item_visibility()]]

Failure for this rule to parse is a type of visibility in the sense that the default visibility is private if unspecified.

#+name: ,ebnf_item_visibility
#+begin_src fundamental
ItemVisibility = ( 'pub' | 'pub' '(' 'crate' ')' )?
#+end_src

Original EBNF: [[file:noir/compiler/noirc_frontend/src/parser/parser/item_visibility.rs::9][ItemVisibility doc]]

***** UPGR Use
:PROPERTIES:
:CUSTOM_ID: h:ADB184CE-E43C-423B-803F-DE1679A91829
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-06-08 Sun 17:35]
:END:

#+name: use
#+begin_src js :rule use_item :arg $ :ast Use
seq(
    optional(<<r("item_visibility")>>),
    'use',
    field('decl', <<r("use_variants")>>),
    ';',
)
#+end_src

#+name: use_variants
#+begin_src js :rule __use_variants :arg $ :ast UseTree
choice(
    <<r("identifier")>>,
    <<r("use_list")>>,
    alias(<<r("use_variants_scoped")>>, $.path),
)
#+end_src

#+name: use_variants_scoped
#+begin_src js :rule __use_variants_scoped :arg $ :ast UseTree
seq(
    optional(
        field('scope', choice(
            <<r("use_variants")>>,
            <<r("path_kind")>>,
        ),
    )),
    choice(
        seq(
            '::',
            choice(
                field('name', <<r("identifier")>>),
                field('list', <<r("use_list")>>),
            ),
        ),
        // Inlined Noirc UseTreeAs.
        seq(
            'as',
            field('alias', <<r("identifier")>>),
        ),
    ),
)
#+end_src

#+name: use_list
#+begin_src js :arg $ :ast UseTreeList
seq(
    '{',
    sepBy(<<r("use_variants")>>, ','),
    optional(','),
    '}',
)
#+end_src

#+name: use_alias
#+begin_src js :rule use_as :arg $ :ast UseTreeAs
seq(
    optional(
        field('scope', choice(
            <<r("identifier")>>,
            <<r("path_kind")>>,
        ),
    )),
    'as',
    field('alias', <<r("identifier")>>),
)
#+end_src

*************** TODO Use rules cleanup
So as written this form no-longer errors when expected (see tests). But those tests, while they did error, didn't error in the expected places so the prior rules weren't super correct either. As-is currently at the time of this commit =use_alias= could be put into =use_variants_scoped= but then recursion (since that rule goes back to =use_variants=) would be allowed and it's a bit unclear if that is allowed in Noir. Need to get Noirc compiler methods so we can test syntax more easily. I already know how to do that but the focus is now on completing the grammar and incremental refinements can be done later.
*************** END

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/item.rs::if self.eat_keyword(Keyword::Use) {][parse_use_tree() parent callsite]], [[file:noir/compiler/noirc_frontend/src/parser/parser/use_tree.rs::pub(super) fn parse_use_tree(&mut self)][parse_use_tree()]]
Types: [[file:noir/compiler/noirc_frontend/src/ast/statement.rs::pub struct UseTree {][UseTree struct]]
Only [[#h:F5A79701-65C9-4FEA-83D8-2413C585A5FA][ItemVisibility]] modifier applicable, all other [[#h:2A9D09A5-2E52-4B8C-ABA1-0B3B953F093C][Modifiers]] are parse errors ([[#h:14698757-D7C8-4966-B84E-5DA1CAE3011E][see more]]).

#+name: ,ebnf_use
#+begin_src fundamental
/// Use = 'use' PathKind UseTree ';'
///
/// UseTree = PathIdentifiers ( '::' '{' UseTreeList? '}' )?
///
/// UseTreeList = UseTree ( ',' UseTree )* ','?
#+end_src
Original EBNF: [[file:noir/compiler/noirc_frontend/src/parser/parser/use_tree.rs::12][Use doc, UseTree doc, UseTreeList doc]]

Only initial [[#h:96FCF9AD-3B89-451B-B84D-90A7A625B56D][PathKind]] is parsed. Any subsequent appearance of PathKind keywords are considered identifiers as PathKind's parser is never called again and any ~kind~ params are hardcoded to ~PathKind::Plain~.

*************** TODO ItemKind docs as appropriate
Parsed [[file:noir/compiler/noirc_frontend/src/ast/statement.rs::pub struct UseTree {][UseTree struct]] is returned as ~ItemKind::Import~ which is [[file:noir/compiler/noirc_frontend/src/ast/statement.rs::pub fn desugar(self, root: Option<Path>, visibility: ItemVisibility)][considered a statement]] however we will narrow and use the declaration sub-category of a statement and name this rule as such.

^^ where did I find ItemKind::Import, and is that documentation beneficial?
*************** END
*************** TODO Upstream commit to fix the doc comment for Use as mentioned in this subheading
   parse_use_tree manually calls parse_path_kind which gets the path kind, and then parse_use_tree_without_kind which calls parse_path_after_kind. The latter function is as it says, the rest of the path after kind and this pattern is (essentially) the same as PathNoTurbofish so EBNF rule for Use stating PathKind PathNoTurbofish implies a paths' kind is parsed twice when it isn't, so that part of the rule is wrong.
*************** END

****** UPGR UseTree
:PROPERTIES:
:CUSTOM_ID: h:19EAD845-0134-41CA-85BA-2E09E10D479B
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-06-08 Sun 17:35]
:END:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/use_tree.rs::pub(super) fn parse_use_tree_without_kind(][parse_use_tree_without_kind()]]

Resulting UseTree kind is either a Path or a List.

After call to [[#h:7BA3BCB8-65F3-4001-8B02-2F904B014F87][parse_path_after_kind]] variable ~trailing_double_colon~ set to true if either: =::= is encountered OR there are no path segments and parameter ~kind~ is NOT ~PathKind::Plain~. Variable ~trailing_double_colon~ determines if an attempt to parse ~UseTreeKind::List~ is made or not.

Parameter ~nested~ is true if UseTreeList makes a recursive call, otherwise default is false.

If ~trailing_double_colon~ and ={= then via [[#h:8E0DC05B-1ED6-47BE-9589-64DC06FAECCA][parse_many]] split at =,= repeatedly parsing [[#h:0C07D74C-165A-4128-BF20-EF7E937F7CAA][UseTreeList]] until =}=.

Eventually, through UseTreeLists recurive calls, ~trailing_double_colon~ will be true and [[#h:E818DDE4-D341-4AEC-B785-028949A4B4A7][UseTreeAs]] will be parsed.

****** UPGR UseTreeList
:PROPERTIES:
:CUSTOM_ID: h:0C07D74C-165A-4128-BF20-EF7E937F7CAA
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-06-08 Sun 17:35]
:END:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/use_tree.rs::let use_trees = self.parse_many(][parse_use_tree_in_list() parent callsite]], [[file:noir/compiler/noirc_frontend/src/parser/parser/use_tree.rs::fn parse_use_tree_in_list(&mut self)][parse_use_tree_in_list()]]

****** UPGR UseTreeAs
:PROPERTIES:
:CUSTOM_ID: h:E818DDE4-D341-4AEC-B785-028949A4B4A7
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-06-08 Sun 17:35]
:END:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/use_tree.rs::fn parse_path_use_tree_end(&mut self, mut prefix: Path, nested: bool)][parse_path_use_tree_end()]]

If no path segments it's an error. Otherwise the last path segment constructed by [[#h:7BA3BCB8-65F3-4001-8B02-2F904B014F87][parse_path_after_kind]] has it's ident (which luckily /is/ [[#h:65B0176B-B46F-4679-8535-C504870AC048][ident]]) popped, and we eat the keyword =as= followed by an [[#h:65B0176B-B46F-4679-8535-C504870AC048][ident]].

Functionally this is just checking =as= followed by an ident.

*************** TODO This needs an EBNF comment
Make it so.
*************** END

***** DONE ModOrContract
CLOSED: [2026-02-19 Thu 20:10]
:PROPERTIES:
:CUSTOM_ID: h:9204514E-E5FC-488B-8066-66F0D9AF0C85
:END:
:LOGBOOK:
CLOCK: [2026-02-19 Thu 19:48]--[2026-02-19 Thu 20:10] =>  0:22
- Review Module, ModOrContract.
- State "DONE"       from "UPGR"       [2026-02-19 Thu 20:09] \\
  No apparent change.
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-06-08 Sun 21:02]
:END:

#+name: mod_or_contract
#+begin_src js :rule module_or_contract_item :arg $ :ast ModOrContract
seq(
    optional(<<r("item_visibility")>>),
    choice('mod', 'contract'), // TODO: Discriminate kind into a field?
    field('name', <<r("identifier")>>),
    choice(
        ';',
        field('body', $.item_list),
    ),
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/item.rs::if let Some(is_contract) = self.eat_mod_or_contract() {][parse_mod_or_contract() parent callsite]], [[file:noir/compiler/noirc_frontend/src/parser/parser/module.rs::pub(super) fn parse_mod_or_contract(][parse_mod_or_contract()]]

#+name: ,ebnf_mod_or_contract
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/module.rs::/// ModOrContract][ModOrContract doc]]  :lines 1- :src fundamental :end "pub(super) fn parse_mod_or_contract("

Only the [[#h:F5A79701-65C9-4FEA-83D8-2413C585A5FA][ItemVisibility]] modifier is applicable, all other [[#h:2A9D09A5-2E52-4B8C-ABA1-0B3B953F093C][Modifiers]] are parse errors. Eat =mod= or =contract= keywords, ~validate_secondary_attributes~. If the brace group is not hit it's a ~ItemKind::ModuleDecl~ (declaration), otherwise a real submodule.

i.e. =mod foo;= is a module declaration and =mod { let x = 123; }= is a real module.

***** UPGR Struct
:PROPERTIES:
:CUSTOM_ID: h:A53DF633-322A-464B-9947-E56B64A112C7
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "SPEC"       [2025-07-14 Mon 14:51]
- State "SPEC"       from "DONE"       [2025-06-08 Sun 23:43] \\
  Need to test generics also.
- State "DONE"       from "TODO"       [2025-06-08 Sun 23:43]
:END:

#+name: struct
#+begin_src js :rule struct_item :arg $ :ast Struct
seq(
    optional(<<r("item_visibility")>>),
    'struct',
    field('name', <<r("identifier")>>),
    field('type_parameters', optional(<<r("generic_parameters")>>)),
    choice(
        field('body', $.struct_field_list), // TODO: If this is similar to others, e.g. Impl or Enum we can reduce it to one.
        ';', // Empty struct.
    ),
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/item.rs::if self.eat_keyword(Keyword::Struct) {][parse_struct() parent callsite]], [[file:noir/compiler/noirc_frontend/src/parser/parser/structs.rs::fn parse_struct(][parse_struct()]]
Types: [[file:noir/compiler/noirc_frontend/src/ast/structure.rs::pub struct NoirStruct {][NoirStruct struct]]
Only [[#h:F5A79701-65C9-4FEA-83D8-2413C585A5FA][ItemVisibility]] modifier applicable, all other [[#h:2A9D09A5-2E52-4B8C-ABA1-0B3B953F093C][Modifiers]] are parse errors ([[#h:14698757-D7C8-4966-B84E-5DA1CAE3011E][see more]]).

~empty_struct~ ([[file:noir/compiler/noirc_frontend/src/parser/parser/structs.rs::fn empty_struct(][src]]) is a [[file:noir/compiler/noirc_frontend/src/ast/structure.rs::pub struct NoirStruct {][NoirStruct]] with no ~fields~, it may still have a ~name~, associated ~attributes~, ~visibility~, and ~generics~.

#+name: ,ebnf_struct
#+begin_src fundamental
/// Struct = 'struct' identifier Generics ( ';' | ( '{' StructField* '}' ) )
#+end_src
Original EBNF: [[file:noir/compiler/noirc_frontend/src/parser/parser/structs.rs::12][Struct doc]]

*************** TODO validate_secondary_attributes for parse_struct
*************** END
*************** TODO Struct BNF wrong
Semicolon empty struct, and leading visibility modifier.
*************** END

****** UPGR StructField
:PROPERTIES:
:CUSTOM_ID: h:AE5E66EF-9D42-49F2-853D-5C1E7763416E
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-06-08 Sun 23:43]
:END:

#+name: struct_field
#+begin_src js :rule struct_field_item :arg $ :ast StructField
seq(
    // OuterDocComments are extras.
    optional(<<r("item_visibility")>>),
    field('name', <<r("identifier")>>),
    ':',
    field('type', <<r("type")>>),
)
#+end_src

#+name: struct_field_list
#+begin_src js :arg $
seq(
    '{',
    sepBy(<<r("struct_field")>>, ','),
    optional(','),
    '}',
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/structs.rs::let fields = self.parse_many(][parse_struct_field() parent callsite]], [[file:noir/compiler/noirc_frontend/src/parser/parser/structs.rs::fn parse_struct_field(&mut self)][parse_struct_field()]]
Types: [[file:noir/compiler/noirc_frontend/src/ast/structure.rs::pub struct StructField {][StructField struct]]

Since [[#h:8E0DC05B-1ED6-47BE-9589-64DC06FAECCA][parse_many]] is used, and our callsite does not check, a trailing comma (the separator in use) is accepted.

#+name: ,ebnf_struct_field
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/structs.rs::14][StructField doc]]  :lines 14-14 :src fundamental

*************** TODO If this is general enough and in-use elsewhere like Impl or Enum then reduce it to 1.
*************** END
*************** TODO BNF for StructField is wrong
Parses item visibility. Update at remote after grammar is done.
*************** END

***** UPGR Implementation
:PROPERTIES:
:CUSTOM_ID: h:954A182F-703F-48FC-85D3-37C11EC959A3
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "BLOCK"      [2025-07-22 Tue 23:40]
- State "BLOCK"      from "TODO"       [2025-06-10 Tue 16:59] \\
  One child depends on Function and Function is also a top-level ItemKind so BLOCK until Function is done.
:END:

#+begin_example
impl <generics> object_type<generics> where where_clauses { ... methods ... }
impl <generics> trait_name<trait_generics> for object_type where where_clauses { ... items ... }
#+end_example

#+name: impl
#+begin_src js :rule impl_item :arg $
seq(
    'impl',
    field('type_parameters', optional(<<r("generic_parameters")>>)),
    // If this optional matches it's a TraitImpl, otherwise a TypeImpl.
    optional(seq(
        field('trait', choice(
            <<r("identifier_or_path_no_turbofish")>>,
            <<r("generic_type")>>,
        )),
        'for',
    )),
    field('type', <<r("type")>>),
    optional(<<r("where")>>),
    // TODO: Rename and reduce trait_impl_body rule name.
    field('body', <<r("trait_impl_body")>>),
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/item.rs::if self.eat_keyword(Keyword::Impl) {][parse_impl() parent callsite]], [[file:noir/compiler/noirc_frontend/src/parser/parser/impls.rs::fn parse_impl(&mut self)][parse_impl()]]
Types: [[file:noir/compiler/noirc_frontend/src/parser/parser/impls.rs::pub(crate) enum Impl {][Impl enum]], [[file:noir/compiler/noirc_frontend/src/ast/traits.rs::pub struct TypeImpl {][TypeImpl struct]], [[file:noir/compiler/noirc_frontend/src/ast/traits.rs::pub struct NoirTraitImpl {][NoirTraitImpl struct]]
Only the [[#h:F5A79701-65C9-4FEA-83D8-2413C585A5FA][ItemVisibility]] modifier is applicable, all other [[#h:2A9D09A5-2E52-4B8C-ABA1-0B3B953F093C][Modifiers]] are parse errors.

=impl= eaten before parse_impl called, within ~parse_impl~: ~parse_generics~, ~parse_type_or_error~ then eat =for= (kw). If eaten try and parse TraitImpl, otherwise TypeImpl. For immediate children {Type,Trait}Impl their Generics are parsed here as is Path and GenericTypeArgs but the latter two indirectly via Type. Return type ~UnresolvedTypeData::Named~ from ~parse_type_or_error~ is unwrapped if =for= is eaten. That enumerant captures Path and GenericTypeArgs ([[file:noir/compiler/noirc_frontend/src/ast/mod.rs::Named(Path, GenericTypeArgs, /*is_synthesized*/ bool),][src]]).

In ~parse_impl~: variable =generics= (Generics) is at the 'impl' item level, =object_type= (Type) depends on whether TypeImpl or TraitImpl.

If =for= keyword is eaten and a pattern match on an ~UnresolvedType::Named~ can be made then the Path, and GenericTypeArgs that form that enum are destructured into variables =trait_name= and =trait_generics= respectively and TraitImpl's parser is called.

~UnresolvedType::Named~ ([[file:noir/compiler/noirc_frontend/src/ast/mod.rs::Named(Path, GenericTypeArgs, /*is_synthesized*/ bool),][src]]): struct type, or a type variable. Full enum: ~Named(Path, GenericTypeArgs)~.

****** UPGR TypeImpl
:PROPERTIES:
:CUSTOM_ID: h:2C79F6AF-9B0D-4246-809D-D5D91C742F09
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TOIMPL"     [2025-07-22 Tue 23:40]
- State "TOIMPL"     from "TODO"       [2025-06-09 Mon 14:34] \\
  Simple wrapper function.
:END:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/impls.rs::fn parse_type_impl(][parse_type_impl()]]

*************** TODO BNF error, whereclause is missing?
*************** END

******* UPGR TypeImplBody
:PROPERTIES:
:CUSTOM_ID: h:4E657C7B-45FD-45D0-84B2-DB55C1D09192
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TOIMPL"     [2025-07-22 Tue 23:40]
- State "TOIMPL"     from "TODO"       [2025-06-09 Mon 14:41]
:END:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/impls.rs::fn parse_type_impl_body(&mut self)][parse_type_impl_body()]]

Via [[#h:8E0DC05B-1ED6-47BE-9589-64DC06FAECCA][parse_many]] inline split without separator until =}= calls [[file:noir/compiler/noirc_frontend/src/parser/parser/impls.rs::fn parse_type_impl_method(&mut self)][parse_type_impl_method()]] which is a parser utility function for error recovery, there a lambda defines the parsing for each TypeImplItem.

******* UPGR TypeImplItem
:PROPERTIES:
:CUSTOM_ID: h:268CE151-7A1D-48ED-A6ED-40219D809438
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-07-22 Tue 23:39]
:END:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/impls.rs::fn parse_type_impl_method(&mut self)][parse_type_impl_method()]]

Parser is a lambda on call to ~parse_item_in_list~. Modifiers parsed here allow all except mutable ([[file:noir/compiler/noirc_frontend/src/parser/parser/impls.rs::let modifiers = parser.parse_modifiers(][src]]).

****** UPGR TraitImpl
:PROPERTIES:
:CUSTOM_ID: h:EBF1C149-1814-4314-AAFB-C5CF198DA61D
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-07-22 Tue 23:39]
:END:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/impls.rs::return Impl::TraitImpl(self.parse_trait_impl(][parse_trait_impl() parent callsite]], [[file:noir/compiler/noirc_frontend/src/parser/parser/impls.rs::fn parse_trait_impl(][parse_trait_impl()]]

*************** TODO BNF mistake in TraitImpl?
Is the where clause meant to be absent there?
*************** END

******* UPGR TraitImplBody
:PROPERTIES:
:CUSTOM_ID: h:AE12BD3E-D350-4D0C-88E7-2FC471E9FB9C
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-07-22 Tue 23:39]
:END:

#+name: trait_impl_body
#+begin_src js :arg $ :ast TraitImplBody
seq(
    // TODO: Rename this CST rule?
    '{',
    // Inlined Noirc: TraitImplItem.
    repeat(choice(
        // OuterDocComments are extras.
        // Attributes only (strictly) associated with TraitImplFunction but that's too narrow for the raw grammar.
        <<r("attribute")>>,
        <<r("trait_impl_type")>>,
        alias(<<r("trait_impl_constant")>>, <<r("let_statement")>>),
        <<r("function")>>, // TraitImplFunction.
    )),
    '}',
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/impls.rs::fn parse_trait_impl_body(&mut self)][parse_trait_impl_body()]]

Via [[#h:8E0DC05B-1ED6-47BE-9589-64DC06FAECCA][parse_many]] inline split without separator until =}= calls [[file:noir/compiler/noirc_frontend/src/parser/parser/impls.rs::fn parse_trait_impl_item(&mut self)][parse_trait_impl_item()]] which is a parser utility function for error recovery, calls to [[file:noir/compiler/noirc_frontend/src/parser/parser/impls.rs::fn parse_trait_impl_item_kind(&mut self)][parse_trait_impl_item_kind()]] which /is/ [[#h:E070D1E3-2377-4041-96A0-C4DA104E9A9C][TraitImplItem]].

*************** TODO Rename this CST rule?
*************** END

******* TraitImplItem
:PROPERTIES:
:CUSTOM_ID: h:E070D1E3-2377-4041-96A0-C4DA104E9A9C
:END:
:LOGBOOK:
- State "TOIMPL"     from "SPEC"       [2025-06-09 Mon 01:48]
- State "SPEC"       from "TODO"       [2025-06-09 Mon 01:48]
:END:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/impls.rs::fn parse_trait_impl_item_kind(&mut self)][parse_trait_impl_item_kind()]]
Types: [[file:noir/compiler/noirc_frontend/src/ast/traits.rs::pub enum TraitImplItemKind {][TraitImplItemKind enum]]

Simple wrapper which calls parsers for pgd types in order.

******* UPGR TraitImplType
:PROPERTIES:
:CUSTOM_ID: h:D3AE715D-AC3E-494A-9E32-0BAD666C2302
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "SPEC"       [2025-07-22 Tue 23:38]
- State "SPEC"       from "TODO"       [2025-07-22 Tue 19:04] \\
  Parser examined
:END:

#+name: trait_impl_type
#+begin_src js :arg $ :ast TraitImplType
seq(
    // TODO: Rename this CST rule?
    'type',
    field('name', <<r("identifier")>>),
    '=',
    // TODO: What name for this CST node? It's not an associated type surely?
    field('alias', <<r("type")>>),
    ';',
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/impls.rs::fn parse_trait_impl_type(&mut self)][parse_trait_impl_type()]]

*************** TODO Rename CST rule?
*************** END
*************** TODO EBNF is wrong it looks like?
Parser says it can eat an assign so it should be === and not =:=.
*************** END

******* UPGR TraitImplConstant
:PROPERTIES:
:CUSTOM_ID: h:400F4495-94E9-4549-9E85-9FECC5F69E7A
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "SPEC"       [2025-07-22 Tue 23:38]
- State "SPEC"       from "TODO"       [2025-07-22 Tue 19:17] \\
  Parser examined.
:END:

#+name: trait_impl_constant
#+begin_src js :arg $ :ast TraitImplConstant
seq(
    // TODO: Rename this CST rule?
    'let',
    field('name', <<r("identifier")>>),
    <<field__type_annotation>>,
    '=',
    field('value', <<r("expression")>>),
    ';',
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/impls.rs::fn parse_trait_impl_constant(&mut self)][parse_trait_impl_constant()]]

Extremely similar to [[#h:FD70AFA1-5D45-434E-A9D0-7E8F6DD38058][LetStatement]] and [[#h:02355489-DDCD-4E67-BB39-5DF3F0BC0A8A][TraitConstant]]. In the former's case we don't allow =mut= here and it's an identifier not a pattern; in the latter's case the type annotation is optional and not required.

*************** TODO Rename this CST rule?
*************** END
*************** TODO EBNF is wrong
Parser states it requires an assignment so need ='=' Expression= in the EBNF.
*************** END

******* UPGR TraitImplFunction
:PROPERTIES:
:CUSTOM_ID: h:668ACDEF-C6C3-46B2-AF64-3907253E7EA6
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-07-22 Tue 19:33]
:END:

This rule can be reduced to just [[#h:B3C4609F-307A-42A1-B420-DBBAB6CDE6E5][Function]] because:
  1. We put [[id:DA6150E7-E986-4749-A481-A95FF1368B74][Attributes]] at the containing rule instead, same as we do elsewhere, otherwise an entire CST node would be required to wrap them (and we can query direct adjacents anyway).
  2. Even though the parser says use of the [[#h:F5A79701-65C9-4FEA-83D8-2413C585A5FA][ItemVisibility]] modifier is a parse error we just call Function since the alternative is duplicating multiple complex rules just to remove the optional ItemVisibility. Probably not worth it in the long run.

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/impls.rs::fn parse_trait_impl_function(&mut self)][parse_trait_impl_function()]]

***** DONE Trait
CLOSED: [2026-02-19 Thu 18:58]
:PROPERTIES:
:CUSTOM_ID: h:6C38714F-76B7-4472-A776-36023EB84873
:END:
:LOGBOOK:
- State "DONE"       from "UPGR"       [2026-02-19 Thu 18:58] \\
  Apparent update to v1.0.0-beta.19 no more errors currently.
CLOCK: [2026-02-19 Thu 15:29]--[2026-02-19 Thu 18:56] =>  3:27
- - Finish review of traits.rs and further nested logic like bounds and generics.
  - Implement updates to latest grammar as it appears from parser frontend.
CLOCK: [2026-02-18 Wed 23:09]--[2026-02-18 Wed 23:50] =>  0:41
- - Skimming parser/traits.rs; basic outline of what has changed and what I need to do tomorrow.
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TOIMPL"     [2025-07-14 Mon 02:33]
- State "TOIMPL"     from "TODO"       [2025-07-10 Thu 15:34] \\
  parse_trait() examined
:END:

#+name: trait
#+begin_src js :rule trait_item :arg $ :ast Trait
seq(
    optional(<<r("item_visibility")>>),
    'trait',
    field('name', <<r("identifier")>>),
    field('type_parameters', optional(<<r("generic_parameters")>>)),
    choice(<<r("trait_tail_alias")>>, <<r("trait_tail")>>),
)
#+end_src

#+name: trait_tail
#+begin_src js :rule __trait_tail :arg $
seq(
    field('bounds', optional(seq(':', <<r("trait_bounds")>>))),
    optional(<<r("where")>>),
    field('body', alias(<<r("trait_body")>>, $.declaration_list)),
)
#+end_src

#+name: trait_tail_alias
#+begin_src js :rule __trait_tail_alias :arg $
seq(
    field('bounds', seq('=', <<r("trait_bounds")>>)),
    optional(<<r("where")>>),
    ';',
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/item.rs::if self.eat_keyword(Keyword::Trait) {][parse_trait() parent callsite]], [[file:noir/compiler/noirc_frontend/src/parser/parser/traits.rs::pub(crate) fn parse_trait(][parse_trait()]]
Types: [[file:noir/compiler/noirc_frontend/src/ast/traits.rs::pub struct NoirTrait {][NoirTrait struct]]
Only [[#h:F5A79701-65C9-4FEA-83D8-2413C585A5FA][ItemVisibility]] modifier applicable, all other [[#h:2A9D09A5-2E52-4B8C-ABA1-0B3B953F093C][Modifiers]] are parse errors ([[#h:14698757-D7C8-4966-B84E-5DA1CAE3011E][see more]]).
Traits can be aliases of others.

#+name: ,ebnf_trait
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/traits.rs::/// Trait =][Trait doc]]  :lines 1- :src fundamental :end "pub(crate) fn parse_trait("

****** DONE TraitBody
CLOSED: [2026-02-19 Thu 18:47]
:PROPERTIES:
:CUSTOM_ID: h:EE2A95CB-6562-465A-A80F-4D2DB57E91DA
:END:
:LOGBOOK:
- State "DONE"       from "UPGR"       [2026-02-19 Thu 18:47] \\
  No apparent error.
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "BLOCK"      [2025-07-26 Sat 00:36]
- State "BLOCK"      from "TOIMPL"     [2025-07-12 Sat 20:37] \\
  Blocked on TraitFunction, the rest is done
- State "TOIMPL"     from "TODO"       [2025-07-10 Thu 15:47] \\
  Parser functions examined
- State "TODO"       from              [2025-07-10 Thu 15:37]
:END:

#+name: trait_body
#+begin_src js :rule __trait_declaration_list :arg $ :ast TraitBody
seq(
    '{',
    // OuterDocComments are extras.
    repeat(
        // Inlined Noirc: TraitItem.
        choice(
            <<r("trait_type")>>,
            <<r("trait_constant")>>,
            // Noirc: TraitFunction allows optional function bodies.
            <<r("function")>>,
            <<r("function_signature")>>,
        ),
    ),
    '}',
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/traits.rs::fn parse_trait_body(&mut self)][parse_trait_body()]], [[file:noir/compiler/noirc_frontend/src/parser/parser/traits.rs::fn parse_trait_item_in_list(&mut self)][parse_trait_item_in_list()]]

Via [[#h:8E0DC05B-1ED6-47BE-9589-64DC06FAECCA][parse_many]] split without separator until =}=: calls [[file:noir/compiler/noirc_frontend/src/parser/parser/traits.rs::fn parse_trait_item_in_list(&mut self)][parse_trait_item_in_list()]].

#+name: ,ebnf_trait_body
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/traits.rs::/// TraitBody =][TraitBody doc]]  :lines 1- :src fundamental :end "fn parse_trait_body"

****** DONE TraitItem
CLOSED: [2026-02-19 Thu 18:46]
:PROPERTIES:
:CUSTOM_ID: h:7D8A8173-EDB3-4E00-8483-DC25607F69E7
:END:
:LOGBOOK:
- State "DONE"       from "UPGR"       [2026-02-19 Thu 18:46] \\
  No apparent error.
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TOIMPL"     [2025-07-12 Sat 20:17]
- State "TOIMPL"     from "TODO"       [2025-07-10 Thu 15:51] \\
  Parser examined
- State "TODO"       from              [2025-07-10 Thu 15:47]
:END:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/traits.rs::fn parse_trait_item(&mut self)][parse_trait_item()]]
Types: [[file:noir/compiler/noirc_frontend/src/ast/traits.rs::pub enum TraitItem {][TraitItem enum]]

Simple wrapper to the parsers of it's three AST types. For the three child AST types tree-sitter grammar fields for CST nodes can be inspired by enum member field names of ~TraitItem~.

#+name: ,ebnf_trait_item
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/traits.rs::/// TraitItem][TraitItem doc]]  :lines 1- :src fundamental :end "fn parse_trait_item("

****** DONE TraitType
CLOSED: [2026-02-19 Thu 18:34]
:PROPERTIES:
:CUSTOM_ID: h:A05394C2-0FFE-431B-8686-AA12F4876025
:END:
:LOGBOOK:
- State "DONE"       from "UPGR"       [2026-02-19 Thu 18:34] \\
  No apparent errors.
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "SPEC"       [2025-07-12 Sat 20:22]
- State "SPEC"       from "TODO"       [2025-07-10 Thu 15:57] \\
  Parser examined, ts grammar written
- State "TODO"       from              [2025-07-10 Thu 15:55]
:END:

#+name: trait_type
#+begin_src js :arg $ :ast TraitType
seq(
    'type',
    field('name', <<r("identifier")>>),
    field('bounds', optional(seq(':', <<r("trait_bounds")>>))),
    ';',
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/traits.rs::fn parse_trait_type(&mut self)][parse_trait_type()]]

#+name: ,ebnf_trait_type
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/traits.rs::/// TraitType =][TraitType doc]]  :lines 1- :src fundamental :end "fn parse_trait_type("

*************** TODO EBNF mistake upstream, correct
:LOGBOOK:
- State "TODO"       from              [2026-02-19 Thu 18:31]
:END:
~( ':' TraitBounds )~ should have a ~?~ at the end as in the parser function if no trait bounds are parsed it allows that to be empty with Vec::new()
*************** END

****** DONE TraitConstant
CLOSED: [2026-02-19 Thu 18:40]
:PROPERTIES:
:CUSTOM_ID: h:02355489-DDCD-4E67-BB39-5DF3F0BC0A8A
:END:
:LOGBOOK:
- State "DONE"       from "UPGR"       [2026-02-19 Thu 18:40] \\
  No apparent errors.
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "SPEC"       [2025-07-12 Sat 20:22]
- State "SPEC"       from "TOIMPL"     [2025-07-10 Thu 16:17] \\
  Parser examined, ts grammar written
- State "TODO"       from              [2025-07-10 Thu 16:03]
:END:

#+name: trait_constant
#+begin_src js :arg $ :ast TraitConstant
seq(
    <<r("tmp__let_to_type")>>,
    // Noirc: still listed on EBNF but parser logic always throws an error if included now (TODO: Upstream clarification).
    // optional(seq(
    //     '=', // We don't want '=' part of the CST node for the (default) value.
    //     field('value', <<r("expression")>>),
    // )),
    ';',
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/traits.rs::fn parse_trait_constant(&mut self)][parse_trait_constant()]]
Based-on: Rust's [[https://doc.rust-lang.org/reference/items/constant-items.html#grammar-ConstantItem][ConstantItem]]

#+name: ,ebnf_trait_constant
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/traits.rs::/// TraitConstant =][TraitConstant doc]]  :lines 1- :src fundamental :end "fn parse_trait_constant("

*************** TODO If parsing = Expression is always an error why is it part of the grammar?
:LOGBOOK:
- State "TODO"       from              [2026-02-19 Thu 18:39]
:END:
Why is it part of the EBNF node if parsing ~= Expression~ is always an error now?

They've correctly added ~?~ to that EBNF group but now if assign is parsed it's always an error even if a literal is used (backed up by compiler behaviour and tests too)
*************** END

****** DONE TraitFunction
CLOSED: [2026-02-19 Thu 18:44]
:LOGBOOK:
- State "DONE"       from "UPGR"       [2026-02-19 Thu 18:44] \\
  No apparent change, but also yet to look at Function-proper which this is effectively aliased to.
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "BLOCK"      [2025-07-26 Sat 00:36]
- State "BLOCK"      from "TODO"       [2025-07-10 Thu 16:28] \\
  Parser examined, is it similar to Function so we can share rules? Once Function done implement this ts rule
- State "TODO"       from              [2025-07-10 Thu 16:19]
:END:

Grammar rule placed at [[#h:B3C4609F-307A-42A1-B420-DBBAB6CDE6E5][Function]] instead. Parser logic here makes this identical to Function except this has an optional body, and only ~Pattern::Identifier~ allowed in parameters.

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/traits.rs::fn parse_trait_function(&mut self)][parse_trait_function()]]

Optional body, allows =self=. Only ~Pattern::Identifier~ allowed in parameters, any other pattern is a parse error.

#+name: ,ebnf_trait_function
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/traits.rs::/// TraitFunction =][TraitFunction doc]]  :lines 1- :src fundamental :end "fn parse_trait_function("

*************** TODO ItemVisibility::Private is only a warning not an error
:LOGBOOK:
- State "TODO"       from              [2026-02-19 Thu 18:42]
:END:
Parser source suggests it should be a compile error but in reality it's a warning only. Currently ignored in grammar. If this becomes an error may consider removing visibility modifiers at this locus (might also not as it'll require duplicating a rule).
*************** END
*************** TODO Consider the parameters Pattern::Identifier restriction for inclusion into ts grammar?
Any value in that, similar to other strict requirements elsewhere. May be more technically correct but also increases parser complexity, and at what /real world/ benefit.
*************** END
*************** TODO This can almost DEFINITELY be de-duplicated with Function when Function is more complete.
TraitFunction = Modifiers Function

results in the same behaviour for normal Function (as understood currently) except this allows optional body (unsure if normal function does, but we need to split those up into definition/declaration etc anyway). So FOR NOW its got it's entirely own ts rule (TraitFunction) but once Function is done I expect we can just de-duplicate this entirely and use a simple alias to have the CST be named ~trait_function~ or something.
*************** END

***** UPGR Global
:PROPERTIES:
:CUSTOM_ID: h:C21A19F9-DC0C-4F17-9739-B92412D0C4FF
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-07-14 Mon 14:30]
:END:

#+name: global
#+begin_src js :rule global_item :arg $ :ast Global
seq(
    optional(<<r("item_visibility")>>),
    optional(alias(<<r("global_item_modifiers")>>, $.modifiers)),
    'global',
    field('name', <<r("identifier")>>),
    <<field__type_annotation>>,
    '=',
    <<r("expression")>>,
    ';',
)
#+end_src

#+name: global_item_modifiers
#+begin_src js
repeat1(choice(
    'mut',
    'comptime',
))
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/item.rs::if self.eat_keyword(Keyword::Global) {][parse_global() parent callsite]], [[file:noir/compiler/noirc_frontend/src/parser/parser/global.rs::fn parse_global(][parse_global()]]
Types: [[file:noir/compiler/noirc_frontend/src/ast/statement.rs::pub struct LetStatement {][LetStatement struct]]
All [[#h:2A9D09A5-2E52-4B8C-ABA1-0B3B953F093C][Modifiers]] except =unconstrained= are applicable.

Parsing of identifier, only in this case, uses [[file:noir/compiler/noirc_frontend/src/parser/parser/global.rs::fn ident_to_pattern(ident: Ident, mutable: bool)][ident_to_pattern()]] which is a simple function I speculate exists because the mutable modifier appears /before/ keyword =global= but with LetStatement's it appears after =let=. For us, there's no change it's just an identifier.

#+name: ,ebnf_global
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/global.rs::15][Global doc]]  :lines 15-15 :src fundamental

*************** TODO validate_secondary_attributes in parse_global, any consequence for us?
*************** END
*************** TODO it looks like just =global;= is valid but.. do we want to support that?
If no ident is eaten but a semicolon follows a LetStatement is returned from parse_global
*************** END

***** TOIMPL Type
:PROPERTIES:
:CUSTOM_ID: h:B3490B7C-F387-49C7-BF94-DC9CE8AC3581
:END:
:LOGBOOK:
- State "TOIMPL"     from "TODO"       [2024-11-16 Sat 18:26]
:END:

- [[#h:C23E374A-42EF-467D-AE3D-548D880712D8][PrimitiveType]]
- [[#h:39A2690C-319F-4F34-A139-8549D70FCF26][ParenthesesType]]
- [[#h:FAB3845D-97FD-454B-B8C8-09FEEB41FC3D][ArrayOrSliceType]]
- [[#h:C1EF6337-B3F1-44D9-B5E6-FF5A0215FCC5][MutableReferenceType]]
- [[#h:96043AA8-9EC3-4E80-AA5D-CBFFE60A9072][FunctionType]]
- [[#h:08118263-BDC8-4589-8EF9-1F0490B62F34][TraitAsType]]
- [[#h:5B4FDF39-09B2-4C07-A2B5-3A3D6BEDD4B7][AsTraitPathType]]
- [[#h:F2E3D7E1-0978-44DF-A49E-EBE348F9D973][UnresolvedNamedType]]

#+name: type
#+begin_src js :rule _type :arg $
choice(
    <<r("primitive_type")>>,
    $._parentheses_type,
    <<r("array_or_slice_type")>>,
    <<r("mutable_reference_type")>>,
    <<r("function_type")>>,
    // TODO: TraitAsType, AsTraitPathType, UnresolvedNamedType
    <<r("identifier_or_path_no_turbofish")>>,
    // parser/types.rs:58-61
    <<r("generic_type")>>,
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_type(&mut self)][parse_type()]], [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_type_or_error(&mut self)][parse_type_or_error()]]

TODO: Look at enum ~UnresolvedTypeData~, read the doc string and look at it's elements. Good stuff.
#+transclude: [[file:noir/compiler/noirc_frontend/src/ast/mod.rs][foobar]]  :lines 104-106 :src foo

TODO: Path from lexer.rs ~next_token()~ to the point where it checks for keywords.
TODO: Put lookup_keyword under it's own heading and transclude the contents verbatim

When lexing [[file:noir/compiler/noirc_frontend/src/lexer/token.rs::fn lookup_keyword(word: &str)][lookup_keyword()]] determines keyword tokens ~Keyword~ which are later parsed:

:callstack:
- [-] [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_unresolved_type_data(&mut self)][parse_unresolved_type_data()]]
    - [ ] [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_str_type(&mut self)][parse_str_type()]]
    - [ ] [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_fmtstr_type(&mut self)][parse_fmtstr_type()]]
    - [ ] [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_comptime_type(&mut self)][parse_comptime_type()]]
    - [ ] [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_resolved_type(&mut self)][parse_resolved_type()]]
    - [ ] [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_interned_type(&mut self)][parse_interned_type()]]
  - [ ] [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_parentheses_type(&mut self)][parse_parentheses_type()]]
  - [ ] [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_array_or_slice_type(&mut self)][parse_array_or_slice_type()]]
  - [ ] [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parses_mutable_reference_type(&mut self)][parses_mutable_reference_type()]]
  - [ ] [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_function_type(&mut self)][parse_function_type()]]
  - [ ] [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_trait_as_type(&mut self)][parse_trait_as_type()]]
  - [ ] [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_as_trait_path_type(&mut self)][parse_as_trait_path_type()]]
  - [ ] [[file:noir/compiler/noirc_frontend/src/parser/parser/path.rs::fn parse_path_no_turbofish(&mut self)][parse_path_no_turbofish()]]
    - [ ] [[file:noir/compiler/noirc_frontend/src/parser/parser/generics.rs::fn parse_generic_type_args(&mut self)][parse_generic_type_args()]]
:end:

****** BLOCK PrimitiveType
:PROPERTIES:
:CUSTOM_ID: h:C23E374A-42EF-467D-AE3D-548D880712D8
:END:
:LOGBOOK:
- State "BLOCK"      from "TODO"       [2024-11-15 Fri 19:40] \\
  Explored the parsing function for all its subtypes, but there are some non-trivial recursive dependencies (going back to Type) and also some quoted and interned stuff so blocked for now.
:END:
:pgd:
- [[#h:B5115CEE-F6AE-4BB2-82EE-13F65B7EDC43][FieldType]]
- [[#h:8343D34F-D36E-4E46-A343-A9A99A1F3200][IntegerType]]
- [[#h:57CAEB11-8421-4186-A495-818CC08D5810][BoolType]]
- [[#h:C405DA7F-97A3-4DCF-8946-7480E43D2CC2][StringType]]
- [[#h:12C0CC82-5210-45ED-97F4-0266E1CAA6F1][FormatStringType]]
- [[#h:98FC5657-8034-42F7-A263-3172EFEEEB23][ComptimeType]] (TODO: Not viable in AST, see heading for more ignoring for now but leaving here)
- [[#h:87984AE0-613D-4D9A-A64D-D3FD8BD51C98][ResolvedType]] (TODO: Also ignore, similar reasons for now)
- [[#h:21789349-305A-46D0-8D87-D7B8647482CF][InternedType]] (TODO: Also ignore, similar reasons for now)
:end:

#+name: primitive_type
#+begin_src js :arg $
choice(
    // <<r("field_type")>>,
    <<r("int_type")>>,
    <<r("bool_type")>>,
    <<r("str_type")>>,
    <<r("fmt_str_type")>>,
    // TODO: ComptimeType (blocked for now).
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_primitive_type(&mut self)][parse_primitive_type()]]

*************** TODO Convention is to have all primitive types be a single node, do we keep that?
Double check other grammars none appear to go deeper on primitive types (intentionally). So for example =i32= or =Field= is an IntegerType and FieldType respectively but none actually make a CST node called that and instead both would be PrimitiveType. I suppose you can get the match region when tagging to determine what it is, or there's just too many nodes for primitives since convention shows people _do_ have CST nodes for arrays, unit types, etc. I'll follow convention for now and make all the primitive types anonymous nodes by default.
*************** END

******* UPGR FieldType                                           :leaf:
:PROPERTIES:
:CUSTOM_ID: h:B5115CEE-F6AE-4BB2-82EE-13F65B7EDC43
:END:
:LOGBOOK:
- State "UPGR"       from "SPEC"       [2026-02-19 Thu 21:47] \\
  v1.0.0-beta.19 Noir, this might not exist anymore (merged into integer suffix type perhaps)
- State "SPEC"       from "TOIMPL"     [2025-05-24 Sat 22:10]
- State "TOIMPL"     from "TODO"       [2024-11-03 Sun 12:24]
:END:

#+name: field_type
#+begin_src js :rule __field_type
'Field'
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_field_type(&mut self)][parse_field_type()]]

******* TODO IntegerType                                         :leaf:
:PROPERTIES:
:CUSTOM_ID: h:8343D34F-D36E-4E46-A343-A9A99A1F3200
:END:
:LOGBOOK:
- State "TODO"       from "SPEC"       [2026-02-18 Wed 20:42] \\
  v1.0.0-beta.19 changes implementation properties. Re-review callstack, all documentation herein. See parser.rs::308 eat_int now.
- State "SPEC"       from "TOIMPL"     [2025-05-24 Sat 22:10]
- State "TOIMPL"     from "TODO"       [2024-11-03 Sun 14:50]
:END:
:pgd:
+ =i= OR =u=
+ =1= OR =8= OR =16= OR =32= OR =64=
:end:

#+name: int_type
#+begin_src js :rule __integer_type
choice(...INTEGER_TYPES)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_int_type(&mut self)][parse_int_type()]]

Both signed and unsigned: 1, 8, 16, 32, and 64 bits.
#+transclude: [[file:noir/compiler/noirc_frontend/src/ast/mod.rs::61][IntegerBitSize::allowed_sizes()]]  :lines 61-65 :src rust

*************** TODO Is there a bug in this version of Noir that doesn't allow 16-bit integers? See the above transclude missing ~Self::Sixteen~.
*************** END

:callstack:
- [X] [[file:noir/compiler/noirc_frontend/src/parser/parser.rs::fn eat_int_type(&mut self)][eat_int_type()]]
  - nb :: [[file:noir/compiler/noirc_frontend/src/lexer/token.rs::enum IntType][Token::IntType]] from [[#h:B7763FFE-9685-45F5-A414-66F9E47F3E1D][Lexing]].
- [X] [[file:noir/compiler/noirc_frontend/src/ast/mod.rs::fn from_int_token(][UnresolvedTypeData::from_int_token()]]
  - [X] [[file:noir/compiler/noirc_frontend/src/ast/mod.rs::fn try_from(value: u32)][IntegerBitSize::try_from()]]
:end:

1. If [[file:noir/compiler/noirc_frontend/src/ast/mod.rs::fn from_int_token(][UnresolvedTypeData::from_int_token()]]'s call to [[file:noir/compiler/noirc_frontend/src/ast/mod.rs::fn try_from(value: u32)][IntegerBitSize::try_from()]] succeeds an ~UnresolvedTypeData::Integer~ is returned.
2. [[file:noir/compiler/noirc_frontend/src/ast/mod.rs::fn try_from(value: u32)][IntegerBitSize::try_from()]] validates given numeric bit-size component and returns matching ~IntegerBitSize~, otherwise returning invalid bit-size parse error.

******** Lexing
:PROPERTIES:
:CUSTOM_ID: h:B7763FFE-9685-45F5-A414-66F9E47F3E1D
:END:

:callstack:
- [[file:noir/compiler/noirc_frontend/src/lexer/lexer.rs::fn next_token(&mut self)][Lexer::next_token()]]
  - [[file:noir/compiler/noirc_frontend/src/lexer/lexer.rs::fn eat_alpha_numeric(&mut self, initial_char: char)][Lexer::eat_alpha_numeric()]]
    - [[file:noir/compiler/noirc_frontend/src/lexer/lexer.rs::fn eat_word(&mut self, initial_char: char)][Lexer::eat_word()]]
      - [[file:noir/compiler/noirc_frontend/src/lexer/lexer.rs::fn lookup_word_token(][Lexer::lookup_word_token()]]
:end:
Parser: [[file:noir/compiler/noirc_frontend/src/lexer/token.rs::fn lookup_int_type(word: &str)][IntType::lookup_int_type()]]

1. Signed or unsigned if ~word~ starts with =i= or =u= respectively.
2. Remaining string ~word~ contents attempt parse into bit-size 32-bit integer.
3. [[file:noir/compiler/noirc_frontend/src/lexer/token.rs::enum IntType][Token::IntType]] created with signedness and bit-size value.

******* SPEC BoolType                                                  :leaf:
:PROPERTIES:
:CUSTOM_ID: h:57CAEB11-8421-4186-A495-818CC08D5810
:END:
:LOGBOOK:
- State "SPEC"       from "TOIMPL"     [2025-05-24 Sat 22:13]
- State "TOIMPL"     from "TODO"       [2024-11-03 Sun 12:21]
:END:
:pgd:
+ =bool= (kw)
:end:

#+name: bool_type
#+begin_src js :rule __bool_type
'bool'
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_bool_type(&mut self)][parse_bool_type()]]

Parses the literal /keyword/ =bool= *and not* literal words =true= or =false=.

******* UPGR StringType
:PROPERTIES:
:CUSTOM_ID: h:C405DA7F-97A3-4DCF-8946-7480E43D2CC2
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "BLOCK"      [2025-07-25 Fri 01:30]
- State "BLOCK"      from "TODO"       [2024-11-16 Sat 18:26] \\
  TypeExpression completion.
:END:

#+name: str_type
#+begin_src js :rule __string_type :arg $
seq(
    'str',
    '<',
    <<r("type_expr")>>,
    '>',
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_str_type(&mut self)][parse_str_type()]]

******* UPGR FormatStringType
:PROPERTIES:
:CUSTOM_ID: h:12C0CC82-5210-45ED-97F4-0266E1CAA6F1
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "SPEC"       [2025-07-25 Fri 01:30]
- State "SPEC"       from "TOIMPL"     [2025-05-24 Sat 22:16]
- State "TOIMPL"     from "TODO"       [2024-11-16 Sat 18:24]
:END:

#+name: fmt_str_type
#+begin_src js :rule __format_string_type :arg $
seq(
    'fmtstr',
    field('type_arguments', <<r("type_arguments")>>),
)
#+end_src

*************** TODO Move TypeArguments elsewhere
*************** END

#+name: type_arguments
#+begin_src js :arg $ :ast "Ours: TypeArguments"
seq(
    '<',
    <<r("type_expr")>>,
    ',',
    <<r("type")>>,
    '>',
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_fmtstr_type(&mut self)][parse_fmtstr_type()]]

TypeArguments parsed inline parse_fmtstr_type.

Return ~AST::UnresolvedTypeData::FormatString~.

*************** TODO Keep this under primitive type or somewhere else?
*************** END

******* TODO ComptimeType
:PROPERTIES:
:CUSTOM_ID: h:98FC5657-8034-42F7-A263-3172EFEEEB23
:END:
:LOGBOOK:
- State "TODO"       from              [2025-06-08 Sun 23:36] \\
  Found snippets of these, they can exist literally in source.
- State "TOIMPL"     from "TODO"       [2024-11-15 Fri 19:29]
:END:
:pgd:
- =Expr= (kw)
- =Quoted= (kw)
- =TopLevelItem= (kw)
- =Type= (kw)
- =TypedExpr= (kw)
- =StructDefinition= (kw)
- =TraitConstraint= (kw)
- =TraitDefinition= (kw)
- =TraitImpl= (kw)
- =UnresolvedType= (kw)
- =FunctionDefinition= (kw)
- =Module= (kw)
- =CtString= (kw)
:end:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_comptime_type(&mut self)][parse_comptime_type()]]

All ComptimeTypes returned as ~AST::UnresolvedTypeData::Quoted(X)~ where ~X~ is [[file:noir/compiler/noirc_frontend/src/hir_def/types.rs::pub enum QuotedType {][QuotedType]].
#+transclude: [[file:noir/compiler/noirc_frontend/src/hir_def/types.rs::282][QuotedType]]  :lines 282-296 :src rust

*************** TODO This feels strage, are those literal keywords allowed in source?
This feels like stuff a preprocessing step would inline or something. If one can literally write these keywords and them be valid then sure.

2025/05/24: this is metaprogramming quoted type HIR(?) stuff, these cannot appear as literal keywords I'm 99% sure so not adding them for now.
*************** END
*************** TODO Check out hir_def/types.rs enum Type, good docs.
*************** END

******* BLOCK ResolvedType
:PROPERTIES:
:CUSTOM_ID: h:87984AE0-613D-4D9A-A64D-D3FD8BD51C98
:END:
:LOGBOOK:
- State "BLOCK"      from "TODO"       [2024-11-16 Sat 18:25] \\
  Clarity on QuotedType stuff.
:END:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_resolved_type(&mut self)][parse_resolved_type()]]

*************** TODO Non-concrete token kinds lookup, so get to this later.
i.e. no literal string keyword that lookup_keyword matches.
*************** END

******* BLOCK InternedType
:PROPERTIES:
:CUSTOM_ID: h:21789349-305A-46D0-8D87-D7B8647482CF
:END:
:LOGBOOK:
- State "BLOCK"      from "TODO"       [2024-11-16 Sat 18:25] \\
  Clarity on InternedType stuff.
:END:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::pub(super) fn parse_interned_type(&mut self)][parse_interned_type()]]

*************** TODO Non-concrete token kinds lookup, so get to this later.
i.e. no literal string keyword that lookup_keyword matches.
*************** END

****** SPEC ParenthesesType
:PROPERTIES:
:CUSTOM_ID: h:39A2690C-319F-4F34-A139-8549D70FCF26
:END:
:LOGBOOK:
- State "SPEC"       from "BLOCK"      [2025-05-24 Sat 22:48] \\
  Type isn't really a blocker, as Type becomes more complete so will the types which recursive with it. In this case only TupleType does.
- State "BLOCK"      from "TODO"       [2024-11-16 Sat 17:09] \\
  Type completion.
:END:

#+name: parentheses_type
#+begin_src js :rule _parentheses_type :arg $
choice(
    <<r("unit_type")>>,
    <<r("tuple_type")>>,
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_parentheses_type(&mut self)][parse_parentheses_type()]]

******* SPEC Unit{Literal,Type}                                       :alias:
:PROPERTIES:
:CUSTOM_ID: h:9653A5E5-2857-4FB4-8698-5D9F6F0E8755
:END:
:LOGBOOK:
- State "SPEC"       from "TOIMPL"     [2025-05-20 Tue 17:11]
- State "TOIMPL"     from "TODO"       [2024-11-15 Fri 20:24]
:END:

#+name: unit_type
#+begin_src js :ast "UnitLiteral, UnitType (ours)"
seq('(', ')')
#+end_src

Parser: /only in parents inline/
Callsites:
  - [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::return Some(UnresolvedTypeData::Unit);][in parse_parentheses_type()]] (for: [[#h:39A2690C-319F-4F34-A139-8549D70FCF26][ParenthesesType]], as: UnitType)
  - [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::return Some(ExpressionKind::Literal(Literal::Unit));][in parse_parentheses_expression()]] (for: [[#h:DF57FFD8-C50B-406E-95E7-94C3BFC15DAC][ParenthesesExpression]], as: UnitLiteral)

#+name: ,ebnf_unit_literal
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::685][UnitLiteral doc]]  :lines 685-685 :src fundamental
  
*************** TODO Rule names according to locus of production
If in parse_parentheses_type then UnitType, but if from Atom in ParenthesesExpression then UnitLiteral?
*************** END

******* SPEC TupleType                                                 :node:
:PROPERTIES:
:CUSTOM_ID: h:CF9505CB-8110-4FC2-8A6B-5D88A7EB1D06
:END:
:LOGBOOK:
- State "SPEC"       from "TODO"       [2025-05-24 Sat 22:47] \\
  As Type gets more complete so will this (since it's recursive).
:END:
:pgd:
+ =(=
+ [[#h:B3490B7C-F387-49C7-BF94-DC9CE8AC3581][Type]]
+ (rep0 grp) =,= by [[#h:B3490B7C-F387-49C7-BF94-DC9CE8AC3581][Type]]
+ (opt) =,=
+ =)=
:end:

#+name: tuple_type
#+begin_src js :arg $
seq(
    '(',
    sepBy1(<<r("type")>>, ','),
    optional(','),
    ')',
)
#+end_src

Parser: /in slice of parent/.
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::387][parse_many_return_trailing_separator_if_any()]] :lines 387-397 :src rust

If only one Type and no trailing comma return ~AST::UnresolvedTypeData::Parenthesized~, else return ~AST::UnresolvedTypeData::Tuple~.

*************** TODO If 1 element in list and no trailing comma Parnthesized, else Tuple
Is there a meaningful difference here for tree-sitter purposes?
*************** END

****** UPGR ArrayOrSliceType
:PROPERTIES:
:CUSTOM_ID: h:FAB3845D-97FD-454B-B8C8-09FEEB41FC3D
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "SPEC"       [2025-07-25 Fri 01:23]
- State "SPEC"       from "BLOCK"      [2025-05-24 Sat 23:05] \\
  More complete as Type/TypeExpression increase in completeness.
- State "BLOCK"      from "TODO"       [2024-11-16 Sat 17:09] \\
  Type and TypeExpression completion.
:END:

#+name: array_or_slice_type
#+begin_src js :rule array_type :arg $ :ast ArrayOrSliceType
seq(
    '[',
    // Encompasses both slice and array types, if differentiation required this rule can easily be split up.
    choice(
        // UnresolvedTypeData::Slice.
        <<r("type")>>,
        // UnresolvedTypeData::Array.
        seq(
            <<r("type")>>,
            ';',
            field('length', <<r("type_expr")>>),
        ),
    ),
    ']',
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_array_or_slice_type(&mut self)][parse_array_or_slice_type()]]

*************** TODO What about slice literal syntax?
What about the &[0; 2] syntax for slice literals? This node doesn't appear to do any ampersand parsing? Check higher up the call chain though since there's A LOT of nesting and what not going on currently.
*************** END

****** UPGR MutableReferenceType
:PROPERTIES:
:CUSTOM_ID: h:C1EF6337-B3F1-44D9-B5E6-FF5A0215FCC5
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "SPEC"       [2025-07-24 Thu 18:18]
- State "SPEC"       from "BLOCK"      [2025-05-24 Sat 23:09] \\
  More complete alongside Type.
- State "BLOCK"      from "TODO"       [2024-11-16 Sat 17:09] \\
  Block on Type completion.
:END:

#+name: mutable_reference_type
#+begin_src js :rule reference_type :arg $ :ast "Ours: MutableReferenceType"
seq(
    '&',
    <<r("modifier_mut")>>,
    <<r("type")>>,
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parses_mutable_reference_type(&mut self)][parse_mutable_reference_type()]]
Types: [[file:noir/compiler/noirc_frontend/src/ast/mod.rs::MutableReference(Box<UnresolvedType>),][UnresolvedTypeData::MutableReference]] ~AST::UnresolvedTypeData::MutableReference~

****** UPGR FunctionType
:PROPERTIES:
:CUSTOM_ID: h:96043AA8-9EC3-4E80-AA5D-CBFFE60A9072
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "SPEC"       [2025-07-24 Thu 03:20]
- State "SPEC"       from "BLOCK"      [2025-05-24 Sat 23:13] \\
  More complete alongside Type.
- State "BLOCK"      from "TODO"       [2024-11-16 Sat 17:37] \\
  Type completion.
:END:

#+name: function_type
#+begin_src js :arg $ :ast "Ours: FunctionType"
seq(
    alias(optional('unconstrained'), $.modifiers),
    'fn',
    field('environment', optional(<<r("capture_environment")>>)),
    // TODO: Condense in source; TupleType has the same parse logic that we need here so use that.
    field('parameters', alias(<<r("function_type_parameters")>>, $.parameters)),
    // TODO: Condense in source; LambdaReturnType has the same parse logic we need here so use that.
    field('return_type', alias(<<r("lambda_return_type")>>, <<r("function_return_type")>>)),
)
#+end_src

#+name: function_type_parameters
#+begin_src js :arg $ :ast "Ours: FunctionTypeParameters"
seq(
    '(',
    optional(seq(
        sepBy1(<<r("type")>>, ','),
        optional(','),
    )),
    ')',
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_function_type(&mut self)][parse_function_type()]]
Callsites:
  - [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::if let Some(typ) = self.parse_function_type() {][in parse_unresolved_type_data()]] (for: [[#h:B3490B7C-F387-49C7-BF94-DC9CE8AC3581][Type]])

Parameters at this locus parsed at: [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_parameter(&mut self)][parse_parameter()]] i.e. comma delimited list of Type.
Return type parsed at line 277 parser/types.rs

Return: ~AST::UnresolvedTypeData::Function~.

*************** TODO Make an EBNF doc for this
Nothing in Noirc exists for this yet
*************** END

******* UPGR CaptureEnvironment
:PROPERTIES:
:CUSTOM_ID: h:4E68CB10-4122-4C09-B99F-DE7F57651E02
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "SPEC"       [2025-07-24 Thu 03:19]
- State "SPEC"       from "BLOCK"      [2025-05-24 Sat 23:22] \\
  More complete alongside Type.
- State "BLOCK"      from "TODO"       [2024-11-16 Sat 17:34] \\
  Type completion.
:END:

#+name: capture_environment
#+begin_src js :arg $ :ast "Ours: CaptureEnvironment"
seq(
    '[',
    <<r("type")>>,
    ']',
)
#+end_src

*************** TODO EBNF doc for this in Noirc
*************** END

Function capture environment syntax, e.g. =fn foo[Env]()= where =[Env]= is the environment specifier valid for the function to be called within.

Parser: /within slice of parent/
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::252][FunctionType CaptureEnvironment]]  :lines 252-258 :src rust

******* SPEC Parameter
:PROPERTIES:
:CUSTOM_ID: h:FC1E33B7-033B-4F6F-9EFD-2CDC784E572C
:END:
:LOGBOOK:
- State "SPEC"       from "BLOCK"      [2025-05-24 Sat 23:22] \\
  More complete alongside Type.
- State "BLOCK"      from "TODO"       [2024-11-16 Sat 17:34] \\
  Type completion.
:END:

*************** TODO Delete this subheading and/or rename so it's clear it's for FunctionType only
*************** END

#+begin_src js :treesit t
parameter_list: ($) => seq(
    '(',
    sepBy($._type, ','),
    ')',
)
#+end_src

Parser: /within slice of parent/ and [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_parameter(&mut self)][parse_parameter()]]
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::271][parse_many()]]  :lines 271-275 :src rust

****** BLOCK TraitAsType
:PROPERTIES:
:CUSTOM_ID: h:08118263-BDC8-4589-8EF9-1F0490B62F34
:END:
:LOGBOOK:
- State "BLOCK"      from "TODO"       [2024-11-16 Sat 17:48] \\
  PathNoTurbofish and GenericTypeArgs completion.
:END:

+ =impl= (kw).
+ [[#h:A051D0D5-7007-4DF8-83B7-FB4EFF9C383E][PathNoTurbofish]].
+ [[#h:3267D7A4-7AA4-49FB-91FA-A9601BC6868A][GenericTypeArgs]].

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_trait_as_type(&mut self)][parse_trait_as_type()]]

Return: ~AST::UnresolvedTypeData::TraitAsType~.

*************** TODO Rename this to just TraitType if that is unused elsewhere in the (relevant) compiler frontend section?
*************** END
*************** TODO Path is implied optional (as noted elsewhere), is PathNoTurbofish also implied optional?
Because here its required that PathNoTurbofish is Some and _not_ None (which IIRC is how/why Path is implied optional elsewhere).
*************** END

****** BLOCK AsTraitPathType
:PROPERTIES:
:CUSTOM_ID: h:5B4FDF39-09B2-4C07-A2B5-3A3D6BEDD4B7
:END:
:LOGBOOK:
- State "BLOCK"      from "TODO"       [2024-11-16 Sat 18:10] \\
  AsTraitPath completion.
:END:

+ [[#h:348C4ABC-3FC0-46EC-95A0-7F4B238BB86A][AsTraitPath]]

This just wraps AsTraitPath.

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_as_trait_path_type(&mut self)][parse_as_trait_path_type()]]

Return: ~AST::UnresolvedTypeData::AsTraitPath~.

****** BLOCK UnresolvedNamedType
:PROPERTIES:
:CUSTOM_ID: h:F2E3D7E1-0978-44DF-A49E-EBE348F9D973
:END:
:LOGBOOK:
- State "BLOCK"      from "TODO"       [2024-11-16 Sat 18:22] \\
  PathNoTurbofish completion.
:END:

*************** TODO DELETE THIS SUBHEADING
This is from very early on and 'UnresolvedNamedType' isn't an actual thing, I've just added GenericTypeArgs to Type (what this actually is) and probably missed doing that due to this (innacurate subheading).
*************** END

+ [[#h:A051D0D5-7007-4DF8-83B7-FB4EFF9C383E][PathNoTurbofish]]
+ (opt) [[#h:3267D7A4-7AA4-49FB-91FA-A9601BC6868A][GenericTypeArgs]]

Parser: /within slice of parent/
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::58][parent parser slice]]  :lines 58-61 :src rust

Return: ~AST::UnresolvedTypeData::Named~.

#+transclude: [[file:noir/compiler/noirc_frontend/src/ast/mod.rs::121][UnresolvedTypeData::Named doc]]  :lines 121-122 :src rust

***** TODO TypeOrTypeExpression
:PROPERTIES:
:CUSTOM_ID: h:A32A351C-092B-42F1-AB03-DE49862B35D4
:END:

#+name: type_or_type_expr
#+begin_src js :rule _type_or_type_expr :arg $ :ast TypeOrTypeExpression
choice(
    <<r("type")>>,
    <<r("type_expr")>>,
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/type_expression.rs::fn parse_type_or_type_expression(&mut self)][parse_type_or_type_expression()]], [[file:noir/compiler/noirc_frontend/src/parser/parser/type_expression.rs::fn parse_add_or_subtract_type_or_type_expression(&mut self)][parse_add_or_subtract_type_or_type_expression()]]
Type: [[file:noir/compiler/noirc_frontend/src/ast/mod.rs::pub struct UnresolvedType {][UnresolvedType struct]]

#+name: ,ebnf_type_or_type_expression
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/type_expression.rs::195][TypeOrTypeExpression doc]]  :lines 195-195 :src fundamental

Similar to [[#h:0DEF3192-4840-41B3-A941-714798677092][TypeExpression]]'s [[id:7A38952D-D669-4DD6-AF3A-065CB546CB21][Infix]] this also contains a heavily nested and confusing implementation with very long and similar reading function names that hurt one's head, it looks to be the same as TypeExpression and it does call those functions but it appears to use it's own wrappers as AST nodes are created ~UnresolvedTypeData~ on this path instead of ~UnresolvedTypeExpression~ on the other. It looks like this has no consequence for tree-sitter grammar so continue with that assumption for now.

***** UPGR TypeExpression
:PROPERTIES:
:CUSTOM_ID: h:0DEF3192-4840-41B3-A941-714798677092
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TOIMPL"     [2025-06-22 Sun 02:13]
- State "TOIMPL"     from "TODO"       [2024-11-16 Sat 20:20]
:END:

Using 'expr' in-place of 'expression' so-as-to not conflate with _real_ expressions.

#+name: type_expr
#+begin_src js :rule _type_expr :arg $ :ast TypeExpression
choice(
    alias(<<r("binary_type_expr")>>, <<r("binary_expression")>>),
    // TODO: Replace literal $.unary_expression with noweb ref function
    alias(<<r("unary_type_expr")>>, $.unary_expression),
    <<r("atom_type_expr")>>,
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/type_expression.rs::pub(crate) fn parse_type_expression(][parse_type_expression()]]
Type: [[file:noir/compiler/noirc_frontend/src/ast/mod.rs::pub enum UnresolvedTypeExpression {][UnresolvedTypeExpression enum]]

Parts of regular [[#h:167542CC-8CDE-49C1-9465-E5157C6A176F][Expression]] reused since TypeExpression is a limited subset. No distinction made in CST.

A special kind of type intended for narrow usage. Limited to constant integers, variables, and basic numeric binary operators; this heading and it's children define a special type that is allowed in the length position of an array (and some other limited places).

Further context (code has diverged however) on implementing PR: [[https://github.com/noir-lang/noir/pull/620/commits/adb969d178fd9f50be91229505138e53bdc4a6f8#diff-ad71a918cf63410fc5be767b6f3ad78a213b22cff60ddd0549c9f5e083a5d6c2][found here]].

****** Infix
:PROPERTIES:
:ID:       7A38952D-D669-4DD6-AF3A-065CB546CB21
:END:

The entire call-tree from AddOrSubtractTypeExpression's parser [[file:noir/compiler/noirc_frontend/src/parser/parser/type_expression.rs::fn parse_add_or_subtract_type_expression(&mut self)][parse_add_or_subtract_type_expression()]] forms the same (subset) binary expressions as in [[#h:ACCBF119-4052-4C4E-87CE-F7B233FF4AA1][Expression Infix]] thus similarly to there, it has been flattened here.

#+name: binary_type_expr
#+begin_src js :rule __binary_type_expr :arg $ :ast "AddOrSubtractTypeExpression -- Entire nested hierarchy flattened and renamed."
{
    const t = [
        // Highest to lowest.
        [PRECEDENCE.multiplicitive, choice('*', '/', '%',)],
        [PRECEDENCE.additive, choice('+', '-')],
    ]

    return choice(...t.map(([p, o]) => prec.left(p, seq(
        field('left', <<r("type_expr")>>),
        field('operator', o),
        field('right', <<r("type_expr")>>),
    ))))
}
#+end_src

****** UPGR TermTypeExpression
:PROPERTIES:
:CUSTOM_ID: h:414EDA73-C80F-4081-A2FC-D4C7DFEDC964
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TOIMPL"     [2025-06-22 Sun 02:12]
:END:

#+name: unary_type_expr
#+begin_src js :rule __unary_type_expr :arg $ :ast TermTypeExpression
prec(PRECEDENCE.unary, seq('-', <<r("type_expr")>>))
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/type_expression.rs::fn parse_term_type_expression(&mut self)][parse_term_type_expression()]]
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/type_expression.rs::111][TermTypeExpression doc]]  :lines 111-113 :src fundamental

This parser is effectively defining =-= as the single valid unary operator and pretends it is a binary one by setting the =lhs= of that to 0. This is probably for some internal compiler reason, I'll treat this as the unary expression is is for the purpose of the CST.

The parser continually eats =-= forming that "binary" (really, unary) expression until no =-= remain after which AtomTypeExpression is parsed which contains top-level recursion via ParenthesisedTypeExpression.

*************** TODO In-code docs for TermTypeExpression minus missing a closing apostrophe
Teeny tiny change, fix if not already done as it seems Noir is now at 0.38.0 so some updating will be required anyway.
*************** END

****** UPGR AtomTypeExpression
:PROPERTIES:
:CUSTOM_ID: h:4E7B0693-6BFF-4B90-A0FB-6BD577A41989
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "SPEC"       [2025-07-14 Mon 02:36]
- State "SPEC"       from "TODO"       [2025-06-22 Sun 02:12] \\
  Still needs Path completed for full test coverage.
- State "TODO"       from              [2025-06-21 Sat 19:07]
:END:

#+name: atom_type_expr
#+begin_src js :rule __atom_type_expr :arg $ :ast AtomTypeExpression
choice(
    <<r("int")>>, // Inlined Noirc: ConstantTypeExpression.
    <<r("identifier_or_path")>>, // Inlined Noirc: VariableTypeExpression.
    // TODO: Replace hardcoded rule name with noweb ref.
    alias(<<r("parenthesised_type_expr")>>, $.parenthesized_expression),
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/type_expression.rs::fn parse_atom_type_expression(&mut self)][parse_atom_type_expression()]]

All children here either alias calls to other literals or other AST nodes in a simple way, so they have been completely inlined.

******* UPGR ParenthesizedTypeExpression
:PROPERTIES:
:CUSTOM_ID: h:CEEC13D7-39B2-434F-90D5-302AB44E2BBA
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from              [2025-07-19 Sat 03:12]
:END:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/type_expression.rs::fn parse_parenthesized_type_expression(&mut self)][parse_parenthesized_type_expression()]]

#+name: parenthesised_type_expr
#+begin_src js :rule __parenthesized_type_expr :arg $ :ast ParenthesizedTypeExpression
seq('(', <<r("type_expr")>>, ')')
#+end_src

#+name: ,ebnf_parenthesized_type_expression
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/type_expression.rs::174][ParenthesizedTypeExpression doc]]  :lines 174-174 :src fundamental

***** TODO Path
:PROPERTIES:
:CUSTOM_ID: h:07167116-EAE4-475B-8C87-DE9075BAF88D
:END:

#+name: path
#+begin_src js :rule path :arg $ :ast "Path, TypePathExpression"
seq(
    field('scope', choice(
        <<self()>>,
        <<r("identifier")>>,
        <<r("path_kind")>>,
    )),
    '::',
    choice(
        field('type_parameters', <<r("generic_type_parameters")>>),
        field('name', <<r("identifier")>>),
    ),
)
#+end_src

Similarly with PathNoTurbofish, anywhere a Path or PathNoTurbofish is specified at minimum an identifier could be returned, so we need a rule to choose between a naked identifier or one that is augmented with a path. In all places seen so far this (and equivalently for PathNoTurbofish) choice'd variant should be used.

#+name: identifier_or_path
#+begin_src js :arg $
choice(
    <<r("identifier")>>,
    <<r("path")>>,
)
#+end_src

In all cases where Path is parsed via mentioned parsers if there are no path segments None is returned; so **Path is implied optional wherever it occurs**.

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/path.rs::fn parse_path_impl(][parse_path_impl()]], [[file:noir/compiler/noirc_frontend/src/parser/parser/path.rs::fn parse_path(&mut self)][parse_path()]]

#+name: ,ebnf_path
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/path.rs::31][Path doc]]  :lines 31-31 :src fundamental

:callstack:
- [-] [[file:noir/compiler/noirc_frontend/src/parser/parser/path.rs::fn parse_path_impl(][parse_path_impl()]]
  - [X] [[file:noir/compiler/noirc_frontend/src/parser/parser/path.rs::fn parse_path_kind(&mut self)][parse_path_kind()]] (is: [[#h:96FCF9AD-3B89-451B-B84D-90A7A625B56D][PathKind]])
  - [ ] [[file:noir/compiler/noirc_frontend/src/parser/parser/path.rs::fn parse_optional_path_after_kind(][parse_optional_path_after_kind()]]
    :: Just a wrapper, if path has no segments and is ~PathKind::Plain~ then ~None~ is returned, else ~Some(path)~.
    - [ ] [[file:noir/compiler/noirc_frontend/src/parser/parser/path.rs::fn parse_path_after_kind(][parse_path_after_kind()]]
      :: Always returns a path, where the meat of the parsing is.
      - [ ] [[file:noir/compiler/noirc_frontend/src/parser/parser/path.rs::fn parse_path_generics(][parse_path_generics()]] (is: [[#h:F8EF693C-A6E2-4D57-BE08-103479D4270D][PathGenerics]])
        - [ ] [[file:noir/compiler/noirc_frontend/src/parser/parser/generics.rs::fn parse_generic_type_args(&mut self)][parse_generic_type_args()]]
:end:

If ~parse_path~ called allow turbofish, and allow trailing double colons are always true.

*************** TODO Are PathNoTurboFish and PathTraitKind seperate Items in the parser (i.e. an Item like Path is an item)?
If they are can reduce nesting complexity.
*************** END

****** Turbofish
:PROPERTIES:
:CUSTOM_ID: h:D0AD78D7-3BF6-4D89-A709-C8CD28968213
:END:

#+name: ,ebnf_turbofish
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/path.rs::33][Turbofish doc]]  :lines 33-33 :src fundamental

A /turbofish/ is syntax of the form ~::<Type>~ (i.e. generics).

****** TOIMPL PathNoTurbofish
:PROPERTIES:
:CUSTOM_ID: h:A051D0D5-7007-4DF8-83B7-FB4EFF9C383E
:END:
:LOGBOOK:
- State "TOIMPL"     from "SPEC"       [2025-07-10 Thu 18:51] \\
  Revising ts grammar rule since Use/Path and children feel brittle
- State "SPEC"       from "TODO"       [2025-06-07 Sat 16:15]
:END:

#+name: path_no_turbofish
#+begin_src js :rule __path_no_turbofish :arg $
seq(
    field('scope', choice(
        alias(<<self()>>, $.path),
        <<r("identifier")>>,
        <<r("path_kind")>>,
    )),
    '::',
    field('name', <<r("identifier")>>),
)
#+end_src

#+name: identifier_or_path_no_turbofish
#+begin_src js :arg $
choice(
    <<r("identifier")>>,
    alias(<<r("path_no_turbofish")>>, $.path),
)
#+end_src

#+name: path_no_turbofish_no_kind
#+begin_src js :rule __path_no_turbofish_no_kind :arg $
seq(
    field('scope', <<r("path_kind")>>),
    field('name', <<r("path_identifiers")>>),
)
#+end_src

Is implicitly optional everywhere it is used unless the callsite checks for ~None~ return.

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/path.rs::pub fn parse_path_no_turbofish(&mut self)][parse_path_no_turbofish()]], [[#h:3DFE0B54-1BEB-41CE-B486-4CA40058C092][parse_path_impl]] called with ~allow_turbofish~ =false= and ~allow_trailing_double_colon~ =true=.

Both of those parameters are passed as-is down to eventual call to [[#h:7BA3BCB8-65F3-4001-8B02-2F904B014F87][parse_path_after_kind]].

#+name: ,ebnf_path_no_turbofish
#+begin_src fundamental
/// PathNoTurbofish = PathKind? PathIdentifiers
#+end_src
Original EBNF: [[file:noir/compiler/noirc_frontend/src/parser/parser/path.rs::55][PathNoTurbofish doc]]

*************** TODO For paths which do allow turbofish do we merge the ts rules into one thing or keep them distinct here
*************** END
*************** TODO EBNF doc update
PathKind is implicit optional everywhere it occurs unless the callsite (parent rule) explicitly checks and errors on it's "nothing" value (in this case, PathKind::Plain).
*************** END

****** TODO PathIdentifiers
:PROPERTIES:
:CUSTOM_ID: h:3E35071C-E186-4562-AC61-1916E637A72E
:END:
:LOGBOOK:
- State "TODO"       from              [2025-06-07 Sat 17:00] \\
  Needed because of Use quirks.
:END:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/path.rs::fn parse_path_after_kind(][parse_path_after_kind()]]

#+name: path_identifiers__OLD
#+begin_src js :rule __path_identifiers :arg $
seq(
    field('scope', choice(
        alias(<<self()>>, $.path),
        <<r("identifier")>>,
        <<r("path_kind")>>,
    )),
    '::',
    field('name', <<r("identifier")>>),
)
#+end_src

#+name: ,ebnf_path_identifiers
#+begin_src fundamental
/// PathIdentifiers = identifier ( '::' identifier )*
#+end_src

See [[#h:ADB184CE-E43C-423B-803F-DE1679A91829][Use]] for why this node exists.

We also want to collect each identifier into a nested structure so Use can be better represented in the final CST.

*************** TODO This snippet useful or delete?
// __identifiers_in_path_no_turbofish: ($) => prec.left(seq(
//     sepBy1($.identifier, '::'),
//     optional('::'),
// ))
*************** END
*************** TODO Rename this heading?
We're using path_kind (decomposed) since we check crate/dep/super as required but it's "depth-first" in that the deepest node has that set now instead of as some prefix. It works and it's correct but perhaps not the most obvious structure. Idk.

pgd for this to be changed as well..?
*************** END
*************** TODO Should this be a new EBNF rule in Noirc compiler?
Current usage of PathNoTurbofish and PathKind in Noirc comments as-is is EXTREMELY confusing unless source code is thoroughly reviewed.
*************** END

#+name: path_no_turbofish__nested_scopes__OLD
#+begin_src js :rule __nested_scopes_in_path_no_turbofish :arg $
seq(
    field('scope', <<r("path_no_kind_no_turbofish")>>),
    '::',
    field('name', $.identifier),
)
#+end_src

TODO: Obviously this rule's name is wrong, but needs to be this way for now.
#+name: path_no_kind_no_turbofish__OLD
#+begin_src js :rule __path_no_kind_no_turbofish :arg $
seq(
    choice(
        choice($.crate, $.dep, $.super, $.identifier),
        // $.identifier,
        alias(<<r("path_no_turbofish__nested_scopes")>>, $.path),
    ),
)
#+end_src

****** BLOCK AsTraitPath
:PROPERTIES:
:CUSTOM_ID: h:348C4ABC-3FC0-46EC-95A0-7F4B238BB86A
:END:
:LOGBOOK:
- State "BLOCK"      from "TODO"       [2024-11-16 Sat 18:10] \\
  Type and PathNoTurbofish completion.
:END:
+ =<=.
+ [[#h:B3490B7C-F387-49C7-BF94-DC9CE8AC3581][Type]].
+ =as= (kw).
+ [[#h:A051D0D5-7007-4DF8-83B7-FB4EFF9C383E][PathNoTurbofish]].
+ [[#h:3267D7A4-7AA4-49FB-91FA-A9601BC6868A][GenericTypeArgs]].
+ =>=.
+ =::=.
+ ~Token::Ident~ as identifier.

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/path.rs::pub(super) fn parse_as_trait_path(&mut self)][parse_as_trait_path()]]
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/path.rs::195][AsTraitPath doc]] :lines 195-195 :src rust

Not to be confused with [[#h:5B4FDF39-09B2-4C07-A2B5-3A3D6BEDD4B7][AsTraitPathType]] which wraps the return in ~AST::UnresolvedType::AsTraitPath~, this node returns a ~AST::Statement::AsTraitPath~.

This is the syntax spaghetti =<Foo as Trait>::Bar= stuff. Specifically the =as Trait= part which leads to the associated type.

*************** TODO Add or note the docs for AsTraitPath
see ast statement.rs line 394 context.
*************** END

****** SPEC PathKind
:PROPERTIES:
:CUSTOM_ID: h:96FCF9AD-3B89-451B-B84D-90A7A625B56D
:END:
:LOGBOOK:
- State "SPEC"       from "TOIMPL"     [2025-05-24 Sat 16:28]
- State "TOIMPL"     from "TODO"       [2024-11-13 Wed 18:18]
:END:

TODO DOCS: Given tight integration with PathNoTurbofish what one would expect as a rule having =::= in it is not.

#+name: path_kind
#+begin_src js :rule __path_kind :arg $ :ast PathKind
choice($.crate, $.dep, $.super)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/path.rs::fn parse_path_kind(&mut self)][parse_path_kind()]]

If there is no path kind, i.e. NIL, this is internally represented via ~PathKind::Plain~.

#+name: ,ebnf_path_kind
#+begin_src fundamental
/// PathKind = ( ( 'crate' | 'dep' | 'super' ) '::' )?
#+end_src
Original EBNF: [[file:noir/compiler/noirc_frontend/src/parser/parser/path.rs::174][PathKind doc]]

*************** TODO EBNF grammar upstream fix
Remove the =| nothing= and instead wrap everything in =( ... )?= to properly mark it as optional. Also missing assignment equals sign.
*************** END

****** UPGR PathGenerics
:PROPERTIES:
:CUSTOM_ID: h:F8EF693C-A6E2-4D57-BE08-103479D4270D
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TOIMPL"     [2025-07-13 Sun 20:31]
- State "TOIMPL"     from "TODO"       [2024-11-13 Wed 19:28]
:END:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/path.rs::let generics = if allow_turbofish][parse_path_generics() parent callsite]], [[file:noir/compiler/noirc_frontend/src/parser/parser/path.rs::fn parse_path_generics(][parse_path_generics()]]

**NOTE**: Only [[#h:43662F12-2EC8-47E8-B5B8-DFF8A1226EB2][OrderedTypeArg]]s are allowed, any [[#h:8314C368-924E-4B8B-A881-66C9F46D6833][NamedTypeArg]]s are parser errors.

At parent callsite check for current token ~Token::DoubleColon~ (=::=) followed by ~Token::Less~ (=<=) is before parser is called.

#+name: ,ebnf_path_generics
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/path.rs::157][PathGenerics doc]]  :lines 157-157 :src fundamental

*************** TODO Currently ignoring the NamedTypeArg being errors for this rule, worth it to not do that?
By ignoring it this subheading has no rule, simply use GenericTypeArgs directly.
*************** END
*************** TODO Document in-code Noir that only OrderedGenerics are allowed, update EBNF accordingly
As the parsing function for PathGenerics shows, any NamedArgs will return a parser error.
*************** END

***** UPGR TypeAlias
:PROPERTIES:
:CUSTOM_ID: h:220925BB-96BF-4D6F-B7E1-EA39B98A8F05
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-07-23 Wed 00:24]
- State "TODO"       from              [2025-07-22 Tue 23:44]
:END:

#+name: type_alias
#+begin_src js :rule type_item :arg $ :ast TypeAlias
seq(
    optional(<<r("item_visibility")>>),
    'type',
    field('name', <<r("identifier")>>),
    field('type_parameters', optional(<<r("generic_parameters")>>)),
    '=',
    field('type', <<r("type")>>),
    ';',
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/type_alias.rs::fn parse_type_alias(][parse_type_alias()]]
Types: [[file:noir/compiler/noirc_frontend/src/ast/type_alias.rs::pub struct NoirTypeAlias {][NoirTypeAlias struct]]
Only [[#h:F5A79701-65C9-4FEA-83D8-2413C585A5FA][ItemVisibility]] modifier applicable, all other [[#h:2A9D09A5-2E52-4B8C-ABA1-0B3B953F093C][Modifiers]] are parse errors ([[#h:14698757-D7C8-4966-B84E-5DA1CAE3011E][see more]]).

***** UPGR Function
:PROPERTIES:
:CUSTOM_ID: h:B3C4609F-307A-42A1-B420-DBBAB6CDE6E5
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-07-22 Tue 02:50]
:END:

#+name: function
#+begin_src js :rule function_item :arg $ :ast Function
seq(
    optional(<<r("item_visibility")>>),
    optional(alias(<<r("function_item_modifiers")>>, $.modifiers)),
    'fn',
    field('name', <<r("identifier")>>),
    field('type_parameters', optional(<<r("generic_parameters")>>)),
    field('parameters', <<r("function_parameters")>>),
    field('return_type', optional(<<r("function_return_type")>>)),
    // TODO: Field name for where clause like on Traits and so forth?
    optional(<<r("where")>>),
    // No optional body allowed at this locus.
    field('body', <<r("block")>>),
)
#+end_src

#+name: function_signature
#+begin_src js :rule function_signature_item :arg $ :ast TraitFunction
seq(
    optional(<<r("item_visibility")>>),
    optional(alias(<<r("function_item_modifiers")>>, $.modifiers)),
    'fn',
    field('name', <<r("identifier")>>),
    field('type_parameters', optional(<<r("generic_parameters")>>)),
    field('parameters', <<r("function_parameters")>>),
    field('return_type', optional(<<r("function_return_type")>>)),
    // TODO: Field name for where clause like on Traits and so forth?
    optional(<<r("where")>>),
    // No body = a function signature, and requires a terminating semicolon.
    ';',
)
#+end_src

#+name: function_return_type
#+begin_src js :rule return_type :arg $
seq(
    '->',
    optional(<<r("visibility")>>),
    field('type', <<r("type")>>),
)
#+end_src

#+name: function_item_modifiers
#+begin_src js
repeat1(choice(
    'comptime',
    'unconstrained',
))
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/item.rs::if self.eat_keyword(Keyword::Fn) {][parse_function() parent callsite]], [[file:noir/compiler/noirc_frontend/src/parser/parser/function.rs::fn parse_function(][parse_function()]]
Types: [[file:noir/compiler/noirc_frontend/src/ast/function.rs::pub struct NoirFunction {][NoirFunction struct]], [[file:noir/compiler/noirc_frontend/src/ast/expression.rs::pub struct FunctionDefinition {][FunctionDefinition struct]]
All [[#h:2A9D09A5-2E52-4B8C-ABA1-0B3B953F093C][Modifiers]] except =mutable= are applicable.

Function parameter =self= **not allowed** at this locus.

Parser immediately calls [[file:noir/compiler/noirc_frontend/src/parser/parser/function.rs::fn parse_function_definition(][parse_function_definition()]] which then calls [[file:noir/compiler/noirc_frontend/src/parser/parser/function.rs::fn parse_function_definition_with_optional_body(][parse_function_definition_with_optional_body()]] with =allow_optional_body= ~false~ and =allow_self= ~false~.

- [ ] [[file:noir/compiler/noirc_frontend/src/parser/parser/traits.rs::fn parse_trait_function(&mut self)][parse_trait_function()]]
- [X] [[file:noir/compiler/noirc_frontend/src/parser/parser/function.rs::fn parse_function(][parse_function()]]
  - [X] [[file:noir/compiler/noirc_frontend/src/parser/parser/function.rs::fn parse_function_definition(][parse_function_definition()]]
    - [X] [[file:noir/compiler/noirc_frontend/src/parser/parser/function.rs::fn validate_attributes(&mut self, attributes: Vec<(Attribute, Span)>)][validate_attributes()]]
      :: Checks that only 1 PrimaryAttribute is set.
    - [X] [[file:noir/compiler/noirc_frontend/src/parser/parser/function.rs::fn parse_function_definition_with_optional_body(][parse_function_definition_with_optional_body()]]
      :: Parses identifier and onwards (generics etc) i.e. everything but attributes.
      - [X] [[file:noir/compiler/noirc_frontend/src/parser/parser/generics.rs::fn parse_generics(&mut self)][parse_generics()]] (is: [[#h:BA1422E4-AB97-4099-8346-5845CA9223A1][Generics]])
      - [X] [[file:noir/compiler/noirc_frontend/src/parser/parser/function.rs::fn parse_function_parameters(&mut self, allow_self: bool)][parse_function_parameters()]] (is: [[#h:B635EAF3-0AE1-47E0-8817-7174186912D8][FunctionParameters]])
      - [X] [[file:noir/compiler/noirc_frontend/src/parser/parser/function.rs::fn parse_visibility(&mut self)][parse_visibility()]] (is: [[#h:17BBA21C-65D3-447D-93DE-2F13E16575C5][Visibility]])
      - [X] [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_type(&mut self)][parse_type()]] (is: [[#h:B3490B7C-F387-49C7-BF94-DC9CE8AC3581][Type]])
      - [X] [[file:noir/compiler/noirc_frontend/src/parser/parser/where_clause.rs::fn parse_where_clause(&mut self)][parse_where_clause()]] (is: [[#h:ED279BDF-F033-4C47-9105-6AC549CE7C31][WhereClause]])
      - [X] [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::fn parse_block(&mut self)][parse_block()]] (is: [[#h:B34CADE5-71B4-41F2-AB54-00483EE593A6][Block]])

#+name: ,ebnf_function
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/function.rs::34][Parser::parse_function()]]  :lines 34-34 :src fundamental

*************** TODO validate_attributes and document it if required
Said call is within the parse_function_definition function, first expression.
*************** END
*************** TODO Look at type FunctionDefinitionWithOptionalBody and FunctionDefinition
See the function.rs file top struct and also what parse_function_definition returns to make sure this matches what we're constructing as a function_definition in our tree-sitter grammar (e.g. whereclause, return visibility blah blah).
*************** END
*************** TODO Look at parse_trait_function function
TraitFunction is a new type (in Noirc).
*************** END

****** UPGR FunctionParameters
:PROPERTIES:
:CUSTOM_ID: h:B635EAF3-0AE1-47E0-8817-7174186912D8
:END:
:LOGBOOK:
CLOCK: [2026-02-18 Wed 22:57]--[2026-02-18 Wed 23:03] =>  0:06
- Corrected links but functions have some other dependencies so I'll do more atomic items first.
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-07-22 Tue 02:49]
:END:

#+name: function_parameters
#+begin_src js :rule parameters :arg $ :ast FunctionParameters
seq(
    '(',
    optional(seq(
        // Inlined Noirc: FunctionParametersList.
        sepBy1(choice(
            <<r("self_pattern")>>,
            alias(<<r("function_parameter")>>, $.parameter),
        ), ','),
        optional(','),
    )),
    ')',
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/function.rs::fn parse_function_parameters(&mut self, allow_self: bool)][parse_function_parameters()]]

#+name: ,ebnf_function_parameters
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/function.rs::/// FunctionParameters =][FunctionParameters doc]]  :lines 1- :src fundamental :end "fn parse_function_parameters("

****** FunctionParametersList
:PROPERTIES:
:CUSTOM_ID: h:D94BC382-4224-4FB5-8332-4C5CCF285946
:END:

**Inlined this unless something else references it in a way that requires otherwise**.

Via [[#h:8E0DC05B-1ED6-47BE-9589-64DC06FAECCA][parse_many]] in parent, split by =,= until =)=, each parsed as [[#h:9554D746-C88F-4E3D-B065-B1A5C5F9B57B][FunctionParameter]].

****** UPGR FunctionParameter
:PROPERTIES:
:CUSTOM_ID: h:9554D746-C88F-4E3D-B065-B1A5C5F9B57B
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-07-22 Tue 02:48]
:END:

#+name: function_parameter
#+begin_src js :arg $ :ast FunctionParameter
seq(
    field('pattern', choice(
        <<r("pattern")>>,
        <<r("self")>>,
    )),
    field('type', choice(
        <<r("type_annotation")>>,
        <<r("function_parameter_type")>>,
    )),
)
#+end_src

Because visibility is after =:= and before Type we need another CST node so it can have the children Visibility/Type in the event Visibility is present.

#+name: function_parameter_type
#+begin_src js :rule visible_type :arg $
seq(
    ':',
    <<r("visibility")>>,
    <<r("type")>>,
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/function.rs::fn parse_function_parameter(&mut self, allow_self: bool)][parse_function_parameter()]]
Types: [[file:noir/compiler/noirc_frontend/src/ast/expression.rs::pub struct Param {][Param struct]]

*************** TODO EBNF Visibility goes after : next to Type
fn parse_function_parameters
*************** END

*************** TODO Deeper parameter parsing functions
Tired, perhaps parse_function_parameter, pattern_param, self_pattern_param have things of consequence in them (or not). It has ~self~ vs ~Self~ in it which is a straight identifier in the former case and a path to an identifier in the latter.
*************** END

***** UPGR Visibility
:PROPERTIES:
:CUSTOM_ID: h:17BBA21C-65D3-447D-93DE-2F13E16575C5
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "SPEC"       [2025-07-22 Tue 02:48]
- State "SPEC"       from "SPEC"       [2025-07-14 Mon 15:16] \\
  Re-mark spec after fixing accidental inline of =call_data(= instead of =call_data=. Plus reviewing Function downwards now that significant progress made elsewhere.
- State "SPEC"       from "TOIMPL"     [2025-06-10 Tue 20:09]
- State "TOIMPL"     from "TODO"       [2025-05-15 Thu 20:36]
:END:

#+name: visibility
#+begin_src js :arg $ :ast Visibility
choice(
    'pub',
    'return_data',
    seq('call_data', '(', <<r("int")>> ,')'),
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/function.rs::fn parse_visibility(&mut self)][parse_visibility()]]
Types: [[file:noir/compiler/noirc_frontend/src/ast/expression.rs::pub enum FunctionReturnType {][FunctionReturnType enum]]

Strictly function return visibility. Default visibility is private.

#+name: ,ebnf_visibility
#+begin_src fundamental
/// Visibility = ( 'pub' | 'return_data' | ( 'call_data' '(' int ')' ) )?
#+end_src
Original EBNF: [[file:noir/compiler/noirc_frontend/src/parser/parser/function.rs::213][Visibility doc]]

*************** TODO Update Visibility EBNF
*************** END

***** UPGR Generics
:PROPERTIES:
:CUSTOM_ID: h:BA1422E4-AB97-4099-8346-5845CA9223A1
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-07-14 Mon 02:30]
:END:

#+name: generics
#+begin_src js :rule _generics :arg $ :ast Generics
seq(
    '<',
    optional(seq(
        sepBy1(<<r("generic")>>, ','), // Inlined Noirc: GenericsList.
        optional(','),
    )),
    '>',
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/generics.rs::fn parse_generics(&mut self)][parse_generics()]]

Via [[#h:8E0DC05B-1ED6-47BE-9589-64DC06FAECCA][parse_many]] split on =,= until =>= call [[file:noir/compiler/noirc_frontend/src/parser/parser/generics.rs::fn parse_generic_in_list(&mut self)][parse_generic_in_list()]].

#+name: ,ebnf_generics
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/generics.rs::13][Generics doc]]  :lines 13-13 :src fundamental

*************** TODO Call this rule generics_list or type_parameters_list instead?
All other list type rules have _list suffix.
*************** END

****** UPGR GenericsList
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from              [2025-07-12 Sat 22:06]
:END:

**Inlined**, subheading only kept for reference.

#+name: ,ebnf_generics_list
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/generics.rs::15][GenericsList doc]]  :lines 15-15 :src fundamental

****** BLOCK Generic
:LOGBOOK:
- State "BLOCK"      from "TODO"       [2025-07-14 Mon 02:29] \\
  Everything done except ResolvedGeneric
:END:

#+name: generic
#+begin_src js :rule __generic :arg $ :ast Generic
choice(
    <<r("identifier")>>, // Inlined Noirc: VariableGeneric.
    <<r("constrained_type")>>,
    // TODO: ResolvedGeneric IFF it even matters for CST.
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/generics.rs::fn parse_generic(&mut self)][parse_generic()]]

Simple wrapper for child AST nodes.

#+name: ,ebnf_generic
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/generics.rs::37][Generic doc]]  :lines 37-40 :src fundamental

****** UPGR VariableGeneric
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TOIMPL"     [2025-07-12 Sat 21:56]
- State "TOIMPL"     from "TODO"       [2024-11-03 Sun 05:25]
:END:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/generics.rs::fn parse_variable_generic(&mut self)][parse_variable_generic()]]

Effective alias for [[#h:65B0176B-B46F-4679-8535-C504870AC048][ident]].

#+name: ,ebnf_variable_generic
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/generics.rs::57][VariableGeneric doc]]  :lines 57-57 :src fundamental

****** UPGR NumericGeneric
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "SPEC"       [2025-07-12 Sat 22:23]
- State "SPEC"       from "TOIMPL"     [2025-07-12 Sat 22:04]
- State "TOIMPL"     from "TODO"       [2024-11-03 Sun 05:26]
:END:

#+name: constrained_type
#+begin_src js :arg $ :ast NumericType
<<r("tmp__let_to_type")>>
#+end_src

#+name: tmp__let_to_type
#+begin_src js :arg $
seq(
    'let',
    field('name', $.identifier),
    ':',
    field('type', $._type),
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/generics.rs::fn parse_numeric_generic(&mut self)][parse_numeric_generic()]]

There's additional checks on integer generic type which we ignore for the purpose of tree-sitter grammar rules.

*************** TODO re-home the template bit on this subheading
Inlined grammar rules are nice, don't have to keep redefining things.
*************** END
*************** TODO Rename NumericType rule from constrained_type
Placeholder-ish name for now idk.
*************** END

#+name: ,ebnf_numeric_generic
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/generics.rs::62][NumericGeneric doc]]  :lines 62-62 :src fundamental

****** TODO ResolvedGeneric
:LOGBOOK:
- State "TODO"       from "TODO"       [2025-07-12 Sat 22:05] \\
  Quoted expression stuff, do as the very last thing
:END:

****** UPGR GenericTypeArgs
:PROPERTIES:
:CUSTOM_ID: h:3267D7A4-7AA4-49FB-91FA-A9601BC6868A
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "SPEC"       [2025-07-14 Mon 02:28]
- State "SPEC"       from "TOIMPL"     [2025-05-24 Sat 20:16]
- State "TOIMPL"     from "TODO"       [2024-11-13 Wed 19:10]
:END:

#+name: generic_type_args
#+begin_src js :rule _generic_type_args :arg $ :ast GenericTypeArgs
seq(
    '<',
    optional(seq(
        sepBy1(<<r("generic_type_arg")>>, ','), // Inlined Noirc: GenericTypeArgsList.
        optional(','),
    )),
    '>',
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/generics.rs::fn parse_generic_type_args(&mut self)][parse_generic_type_args()]]
Types: [[file:noir/compiler/noirc_frontend/src/ast/mod.rs::pub enum GenericTypeArg {][GenericTypeArg enum]]

Final part of parser loops over generics from [[#h:8C6AF1F0-DBAC-4030-AEFC-8FBF6B069EAD][GenericTypeArgsList]] checking if they are Ordered or Named and adding them to ~AST::GenericTypeArgs~ struct before that struct is returned.

- Ordered :: =<A, B, C>=
- Named :: =<A = B, C = D, E = F>=

#+name: ,ebnf_generic_type_args
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/generics.rs::106][GenericTypeArgs doc]]  :lines 106-106 :src fundamental

*************** TODO GenericTypeArgs EBNF update, and also it's optional
If =<= is not eaten default GenericTypeArgs is returned, which is presumably empty (and in any case we didn't eat any syntax) so really GenericTypeArgs is optional wherever it appears.
*************** END

******* UPGR GenericTypeArgsList
:PROPERTIES:
:CUSTOM_ID: h:8C6AF1F0-DBAC-4030-AEFC-8FBF6B069EAD
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "SPEC"       [2025-07-13 Sun 17:21]
- State "SPEC"       from "TOIMPL"     [2025-05-24 Sat 20:16]
- State "TOIMPL"     from "TODO"       [2024-11-13 Wed 19:09]
:END:

**Inlined**, subheading only kept for reference.

#+name: ,ebnf_generic_type_args_list
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/generics.rs::108][GenericTypeArgsList doc]]  :lines 108-108 :src fundamental

******* UPGR GenericTypeArg
:PROPERTIES:
:CUSTOM_ID: h:B2EDBA96-AA93-449F-A8EB-5636CCFC4F1C
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "SPEC"       [2025-07-14 Mon 02:28]
- State "SPEC"       from "TOIMPL"     [2025-05-24 Sat 20:16]
- State "TOIMPL"     from "TODO"       [2024-11-13 Wed 19:07]
:END:

#+name: generic_type_arg
#+begin_src js :rule __generic_type_arg :arg $ :ast GenericTypeArg
choice(
    <<r("named_type_arg")>>,
    <<r("ordered_type_arg")>>,
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/generics.rs::let generics = self.parse_many(][parse_generic_type_arg() parent callsite]], [[file:noir/compiler/noirc_frontend/src/parser/parser/generics.rs::fn parse_generic_type_arg(&mut self)][parse_generic_type_arg()]]

Via [[#h:8E0DC05B-1ED6-47BE-9589-64DC06FAECCA][parse_many]] at parent callsite, split at =,= until =>=.

First checks if current token is ~Token::Ident~ followed by ~Token::Assign~ (===) at which point it attempts to parse [[#h:8314C368-924E-4B8B-A881-66C9F46D6833][NamedTypeArg]]. If those conditions were not true attempts to parse [[#h:43662F12-2EC8-47E8-B5B8-DFF8A1226EB2][OrderedTypeArg]].

Failure in attempt to parse OrderedTypeArg raises parser error ~ParsingRuleLabel::TypeOrTypeExpression~.

#+name: ,ebnf_generic_type_arg
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/generics.rs::110][GenericTypeArg doc]]  :lines 110-112 :src fundamental

******* UPGR NamedTypeArg
:PROPERTIES:
:CUSTOM_ID: h:8314C368-924E-4B8B-A881-66C9F46D6833
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "SPEC"       [2025-07-14 Mon 02:28]
- State "SPEC"       from "TOIMPL"     [2025-05-24 Sat 20:05]
- State "TOIMPL"     from "TODO"       [2024-11-13 Wed 18:56]
:END:

#+name: named_type_arg
#+begin_src js :rule associated_type :arg $ :ast NamedTypeArg
seq(
    field('name', $.identifier),
    '=',
    field('type', <<r("type")>>),
)
#+end_src

NamedTypeArgs should have a wrapping node for clarity on their structure in the CST. It's currently unclear to me exactly what these are like in Noir so the rule name may be subject to change.

Call to Type wrapped in ~parse_type_or_error~. Also called "associated types".

#+name: ,ebnf_named_type_arg
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/generics.rs::114][NamedTypeArg doc]]  :lines 114-114 :src fundamental

******* UPGR OrderedTypeArg
:PROPERTIES:
:CUSTOM_ID: h:43662F12-2EC8-47E8-B5B8-DFF8A1226EB2
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "SPEC"       [2025-07-14 Mon 02:27]
- State "SPEC"       from "TOIMPL"     [2025-05-24 Sat 20:04] \\
  Effectively just an alias of TypeOrTypeExpression
- State "TOIMPL"     from "TODO"       [2024-11-13 Wed 18:56]
:END:

#+name: ordered_type_arg
#+begin_src js :rule __ordered_type_arg :arg $ :ast OrderedTypeArg
<<r("type_or_type_expr")>>
#+end_src

OrderedTypeArgs should have no wrapping node and just defer to TypeOrTypeExpression since they are "self-contained".

If attempt to parse TypeOrTypeExpression yields ~None~ parser error ~ParsingRuleLabel::TypeOrTypeExpression~ is raised.

#+name: ,ebnf_ordered_type_arg
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/generics.rs::116][OrderedTypeArg doc]]  :lines 116-116 :src fundamental

*** SPEC WhereClause
:PROPERTIES:
:CUSTOM_ID: h:ED279BDF-F033-4C47-9105-6AC549CE7C31
:END:
:LOGBOOK:
- State "SPEC"       from "TODO"       [2025-06-09 Mon 00:54]
:END:

#+name: where
#+begin_src js :rule where_clause :arg $ :ast WhereClause
prec.right(seq(
    'where',
    sepBy(<<r("where_clause")>>, ','), // Inlined Noirc: WhereClauseItems.
    optional(',')
))
#+end_src

Is implicit optional ([[file:noir/compiler/noirc_frontend/src/parser/parser/where_clause.rs::if !self.eat_keyword(Keyword::Where) {][src]]) everywhere it appears unless callsite checks for empty vec return.

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/where_clause.rs::fn parse_where_clause(&mut self)][parse_where_clause()]]
Returns: vec of [[file:noir/compiler/noirc_frontend/src/ast/traits.rs::pub struct UnresolvedTraitConstraint {][UnresolvedTraitConstraint struct]]

Note that Type returns an [[file:noir/compiler/noirc_frontend/src/ast/mod.rs::pub struct UnresolvedType {][UnresolvedType struct]], and WhereClause an UnresolvedTraitConstraint struct the latter of which has a field ~typ~ which is the former.

*************** TODO EBNF for WhereClause?
:LOGBOOK:
- State "TODO"       from              [2026-02-19 Thu 16:39]
:END:
Add an org-transclusion for it here?
*************** END
*************** TODO parse_where_clause says constraints can be empty
Does this mean =impl Bar for Foo where {}= is valid in noir then? (there's no constraint after the where, just directly to a block).
*************** END

**** SPEC WhereClauseItems
:PROPERTIES:
:CUSTOM_ID: h:40EAA2CE-8D14-4663-B5A8-83F4D34EABF0
:END:
:LOGBOOK:
- State "SPEC"       from "TODO"       [2025-06-09 Mon 01:29]
:END:

#+name: where_clause
#+begin_src js :rule where_constraint :arg $ :ast WhereClauseItem
seq(
    field('type', <<r("type")>>),
    field('bounds', seq(':', <<r("trait_bounds")>>)),
)
#+end_src

Via [[#h:8E0DC05B-1ED6-47BE-9589-64DC06FAECCA][parse_many]] in parent split on =,=.

**** UPGR WhereClauseItem
:PROPERTIES:
:CUSTOM_ID: h:E13DAE9C-1546-4BEA-9F5C-F18A6497497E
:END:
:LOGBOOK:
- State "UPGR"       from "SPEC"       [2026-02-19 Thu 16:27] \\
  v1.0.0-beta.19, parse_type optional return investigate how it may differ
- State "SPEC"       from "TODO"       [2025-06-09 Mon 01:29]
:END:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/where_clause.rs::fn parse_single_where_clause(&mut self)][parse_single_where_clause()]]

**** SPEC TraitBounds
:PROPERTIES:
:CUSTOM_ID: h:88538872-073E-4ADA-A615-797A00E0DE5F
:END:
:LOGBOOK:
- State "SPEC"       from "UPGR"       [2026-02-19 Thu 16:34]
- State "UPGR"       from "SPEC"       [2026-02-19 Thu 16:30] \\
  v1.0.0-beta.19 Noir
- State "SPEC"       from "TODO"       [2025-06-09 Mon 01:29]
:END:

#+name: trait_bounds
#+begin_src js :arg $ :ast TraitBounds
    sepBy1(<<r("trait_bound")>>, '+'),
// seq(
    // ':', // Common prefix reduction.
    // sepBy1(<<r("trait_bound")>>, '+')
    // optional('+'), // TODO: I think not allowed, test compiler methods post-grammar.
// )
#+end_src

Even though the literal Noirc parser has already checked =:= before it's called we place that token in our tree-sitter rule to simplify the grammar a little. There are only two possible combinations of this rule appearing (according to Noirc comments) and this way the =:= is part of this CST node.

#+begin_example
ugrep -r "':' TraitBounds" -t rust noir -n
#+end_example

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/where_clause.rs::fn parse_trait_bounds(&mut self)][parse_trait_bounds()]]

Via [[#h:8E0DC05B-1ED6-47BE-9589-64DC06FAECCA][parse_many]] inline split on =+= calls [[file:noir/compiler/noirc_frontend/src/parser/parser/where_clause.rs::fn parse_trait_bound_in_list(&mut self)][parse_trait_bound_in_list()]].

~parse_trait_bound_in_list~ checks [[file:noir/compiler/noirc_frontend/src/parser/parser/where_clause.rs::pub(crate) fn parse_trait_bound(&mut self)][parse_trait_bound()]] returns ~Some~ and returns that (which /is/ [[#h:161848E1-1F70-4DEF-9353-4C6BAF517C82][TraitBound]]), otherwise parse error.

#+name: ,ebnf_trait_bounds
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/where_clause.rs::/// TraitBounds =][TraitBounds doc]]  :lines 1- :src fundamental :end "pub(super) fn parse_trait_bounds("

*************** TODO Is trailing + allowed? Do a test for this
:LOGBOOK:
- State "TODO"       from              [2026-02-19 Thu 16:31]
:END:
Ancient test scenario that I need to check still
*************** END
*************** TODO stop_if_separator_is_missing consequences
Really tired right now, double check any undocumented BNF implications of this
*************** END

**** DONE TraitBound
CLOSED: [2026-02-19 Thu 16:36]
:PROPERTIES:
:CUSTOM_ID: h:161848E1-1F70-4DEF-9353-4C6BAF517C82
:END:
:LOGBOOK:
- State "DONE"       from "UPGR"       [2026-02-19 Thu 16:36] \\
  Appears to be no change.
- State "UPGR"       from "SPEC"       [2026-02-19 Thu 16:34] \\
  v1.0.0-beta.19 Noir
- State "SPEC"       from "TODO"       [2025-06-09 Mon 01:30]
:END:

#+name: trait_bound
#+begin_src js :rule __trait_bound :arg $ :ast TraitBound
choice(
    // TraitBound without generics associated.
    <<r("identifier_or_path_no_turbofish")>>,
    // TraitBound with generics needs to be wrapped in a CST node.
    <<r("generic_type")>>,
)
#+end_src

To ensure that a generic type argument has a CST node which encompasses the prior PathNoTurbofish we create a special rule and choose between either just PathNoTurbofish or PathNoTurbofish followed by GenericTypeArgs.

#+name: generic_type
#+begin_src js :rule generic :arg $
seq(
    field('trait', <<r("identifier_or_path_no_turbofish")>>),
    field('type_parameters', <<r("generic_type_parameters")>>),
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/where_clause.rs::fn parse_trait_bound(&mut self)][parse_trait_bound()]]
Types: [[file:noir/compiler/noirc_frontend/src/ast/traits.rs::pub struct TraitBound {][TraitBound struct]]

A ~TraitBound~ is a single type path used to constrain a trait.

#+name: ,ebnf_trait_bound
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/where_clause.rs::/// TraitBound =][TraitBound doc]]  :lines 1- :src fundamental :end "pub(crate) fn parse_trait_bound("

*** SPEC PatternOrSelf
:PROPERTIES:
:CUSTOM_ID: h:464E9BE0-4EC7-4D73-A1F2-F9C581DFD8E3
:END:
:LOGBOOK:
- State "SPEC"       from "TODO"       [2025-06-12 Thu 17:36]
:END:

+ [[#h:D349E307-F033-4D2A-A729-F2EE5B483065][Pattern]] OR [[#h:5B14A337-12EC-477C-8269-961094FAB41B][SelfPattern]]

#+name: pattern_or_self
#+begin_src js :rule _pattern_or_self :arg $ :ast PatternOrSelf
choice(
    <<r("self_pattern")>>,
    <<r("pattern")>>,
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/pattern.rs::pub(crate) fn parse_pattern_or_self(&mut self)][parse_pattern_or_self()]]
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/pattern.rs::43][PatternOrSelf doc]]  :lines 43-45 :src fundamental

Standard case:
1. Check next token is not =:=, then;
2. Eat current token as a ~Token::Ident~ if its literal text is =self=.

PatternOrSelf forms checked in increasing complexity, absent condition checks fall through:
- Standard case is checked ([[file:noir/compiler/noirc_frontend/src/parser/parser/pattern.rs::49][src]]).
  - pass :: SelfPattern =self=.
- Eat =mut= (kw) and then check standard case ([[file:noir/compiler/noirc_frontend/src/parser/parser/pattern.rs::56][src]]).
  - pass :: SelfPattern =mut self=.
  - fail :: Pattern.
- Eat =&= (token), eat =mut= (kw) and then check standard case ([[file:noir/compiler/noirc_frontend/src/parser/parser/pattern.rs::69][src]]).
  - pass :: SelfPattern =&mut self=.
  - fail :: Parser error ~ParserRefMutCanOnlyBeUsedWithSelf~.
- All other (fall through) cases yield Pattern ([[file:noir/compiler/noirc_frontend/src/parser/parser/pattern.rs::88][src]]).

In all cases Pattern is further parsed by call to ~parse_pattern_after_modifiers~.

:verbose:
1. Construct an ~AST::UnresolvedType::Named~ with =Self= ~AST::Path~; then box the entire aforementioned into an ~AST::UnresolvedType::MutableReference~ iff given ~SelfPattern~ contained =&= (i.e. a reference).
2. Construct an ~AST::Pattern::Identifier~ with =self= ~AST::Ident~; then box the entire aforementioned into an ~AST::Pattern::Mutable~ iff given ~SelfPattern~ contained =mut= (i.e. mutable).
3. Return ~AST::Param~ which contains (1) and (2).
:end:

**** SPEC Pattern
:PROPERTIES:
:CUSTOM_ID: h:D349E307-F033-4D2A-A729-F2EE5B483065
:END:
:LOGBOOK:
- State "SPEC"       from "TODO"       [2025-06-12 Thu 17:33]
:END:

#+name: pattern
#+begin_src js :rule _pattern :arg $ :ast Pattern
choice(
    <<r("pattern_no_mut")>>,
    <<r("pattern_mut")>>,
)
#+end_src

If a pattern has a mutable modifier it needs to be wrapped in another CST node to contain it. This form has lower precedence than pattern.
#+name: pattern_mut
#+begin_src js :rule mut_pattern :arg $
prec(-1, seq(
    <<r("modifier_mut")>>,
    <<r("pattern_no_mut")>>,
))
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/pattern.rs::pub(crate) fn parse_pattern(&mut self)][parse_pattern()]], [[file:noir/compiler/noirc_frontend/src/parser/parser/pattern.rs::pub(crate) fn parse_pattern_after_modifiers(][parse_pattern_after_modifiers()]], [[file:noir/compiler/noirc_frontend/src/parser/parser/pattern.rs::fn parse_pattern_no_mut(&mut self)][parse_pattern_no_mut()]]
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/pattern.rs::35][Pattern doc]]  :lines 35-36 :src fundamental

~parse_pattern~ optionally eats =mut= before calling ~parse_pattern_after_modifiers~ which itself optionally parses a PatternNoMut via ~parse_pattern_no_mut~ and that result is appropriately marked mutable (or not) and passed back as the return value for ~parse_pattern~. So, two levels of indirection.

*************** TODO Update Noir BNF grammar comment in source code, mut is actually optional here
Update Noir in-code docs, mut is actually optional. i.e. literal in-code Noir docs should say ='mut'?= and not ='mut'=.
*************** END

***** SPEC PatternNoMut                                                :node:
:PROPERTIES:
:CUSTOM_ID: h:4A5BB563-4244-4B1F-8084-1116B58FA40F
:END:
:LOGBOOK:
- State "SPEC"       from "TODO"       [2025-06-12 Thu 17:33]
:END:
:pgd:
- [[#h:BA807BCE-99B0-4D84-BDC5-613C20F4A422][InternedPattern]]
- [[#h:5EC2C25E-781B-4AA1-B01B-D37B761237F8][TuplePattern]]
- [[#h:44A2D194-B244-4E4C-B53E-2FCF3F4165E2][StructPattern]]
- [[#h:CE58024C-51AD-4A68-A57B-CE4E6D5C0552][IdentifierPattern]]
:end:

#+name: pattern_no_mut
#+begin_src js :rule _pattern_no_mut :arg $ :ast PatternNoMut
choice(
    // TODO: InternedPattern? It looks like a compiler-only internal though and not discrete syntax.
    <<r("tuple_pattern")>>,
    <<r("struct_pattern")>>,
    <<r("identifier")>>, // Noirc: IdentifierPattern.
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/pattern.rs::fn parse_pattern_no_mut(&mut self)][parse_pattern_no_mut()]]
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/pattern.rs::112][PatternNoMut doc]]  :lines 112-116 :src fundamental

***** BLOCK InternedPattern                                            :leaf:
:PROPERTIES:
:CUSTOM_ID: h:BA807BCE-99B0-4D84-BDC5-613C20F4A422
:END:
:LOGBOOK:
- State "BLOCK"      from "TODO"       [2025-05-21 Wed 14:31] \\
  Need to know how lexer assigns TokenKind::InternedPattern.
:END:
:pgd:
- TERMINAL ~TokenKind::InternedPattern~.
:end:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/pattern.rs::fn parse_interned_pattern(&mut self)][parse_interned_pattern()]]

Eat token ~TokenKind::InternedPattern~ and get it's literal contents. If contents is indexable in ~noirc_arena~ (i.e. its been interned) then return ~AST::Pattern::Interned~.

*************** TODO How is TokenKind::InternedPattern assigned
TODO: I spent like 1 hour on the flight to BKK while really tired trying to figure out how the fuck ~TokenKind::InternedPattern~ is assigned and I see no way, maybe it's not even in-use yet or some satanic shit is involved here. Leave it for now I guess.
TODO: How does the lexer assign ~TokenKind::InternedPattern~? Once that's known this node is done.
TODO: TokenKind::InternedPattern (TODO) ~InteredPattern~ is a reference to an interned ~Pattern~.
TODO: So a ~Spanned~ 's ~contents~ are the literal source-code buffers content for the byte region the span defines.
TODO: As per the top of node_interner.rs an InternedPattern is one that is encountered specifically at comptime (i.e. in a comptime block?)
TODO: PGD block for this
*************** END

***** SPEC TuplePattern                                                :node:
:PROPERTIES:
:CUSTOM_ID: h:5EC2C25E-781B-4AA1-B01B-D37B761237F8
:END:
:LOGBOOK:
- State "SPEC"       from "BLOCK"      [2025-06-12 Thu 17:01]
- State "BLOCK"      from "TODO"       [2024-11-13 Wed 02:23] \\
  Until Path.
:END:
:pgd:
+ =(= by (opt) [[#h:3C5C665F-CB91-4C4E-9B39-ACFEE421F5DB][PatternList]] by =)=
:end:

#+name: tuple_pattern
#+begin_src js :arg $ :ast TuplePattern
seq(
    '(',
    sepBy(<<r("pattern")>>, ','), // Inlined Noirc: PatternList.
    optional(','),
    ')',
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/pattern.rs::fn parse_tuple_pattern(&mut self)][parse_tuple_pattern()]]
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/pattern.rs::169][TuplePattern doc]]  :lines 169-169 :src fundamental

****** SPEC PatternList                                                :node:
:PROPERTIES:
:CUSTOM_ID: h:3C5C665F-CB91-4C4E-9B39-ACFEE421F5DB
:END:
:LOGBOOK:
- State "SPEC"       from "BLOCK"      [2025-06-12 Thu 17:00] \\
  Effectively an alias, could even just delete this.
- State "BLOCK"      from "TODO"       [2024-11-13 Wed 02:22] \\
  Until Path.
:END:
:pgd:
+ [[#h:D349E307-F033-4D2A-A729-F2EE5B483065][Pattern]]
+ (rep0 grp) =,= by [[#h:D349E307-F033-4D2A-A729-F2EE5B483065][Pattern]]
+ (opt) =,=
:end:

**Inlined this unless something else references it in a way that requires otherwise**.

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/pattern.rs::fn parse_tuple_pattern_element(&mut self)][parse_tuple_pattern_element()]]
Via [[#h:8E0DC05B-1ED6-47BE-9589-64DC06FAECCA][parse_many]] in [[#h:5EC2C25E-781B-4AA1-B01B-D37B761237F8][parent]], split by =,= until =)=, each parsed as [[#h:D349E307-F033-4D2A-A729-F2EE5B483065][Pattern]].
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/pattern.rs::171][PatternList doc]]  :lines 171-171 :src fundamental

***** UPGR StructPattern
:PROPERTIES:
:CUSTOM_ID: h:44A2D194-B244-4E4C-B53E-2FCF3F4165E2
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "SPEC"       [2025-07-25 Fri 03:03]
- State "SPEC"       from "BLOCK"      [2025-06-12 Thu 17:26]
- State "BLOCK"      from "TODO"       [2024-11-13 Wed 02:22] \\
  Until Path is complete.
:END:

#+name: struct_pattern
#+begin_src js :arg $ :ast StructPattern
seq(
    field('type', <<r("identifier_or_path")>>),
    '{',
    sepBy(<<r("struct_pattern_field")>>, ','), // Inlined Noirc: StructPatternFields.
    optional(','),
    '}',
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/pattern.rs::fn parse_struct_pattern(&mut self, path: Path, start_span: Span)][parse_struct_pattern()]]
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/pattern.rs::197][StructPattern doc]]  :lines 197-201 :src fundamental

****** SPEC StructPatternFields                                        :node:
:PROPERTIES:
:CUSTOM_ID: h:AD401294-1A53-405B-9717-6818B89FF22E
:END:
:LOGBOOK:
- State "SPEC"       from "BLOCK"      [2025-06-12 Thu 17:15]
- State "BLOCK"      from "TODO"       [2024-11-13 Wed 02:21] \\
  Requires all of Pattern which itself has a dependency on Path which is TODO.
:END:
:pgd:
+ [[#h:E4A5FB8F-3DEF-4AA2-8457-E7DE648EC0F4][StructPatternField]]
+ (rep0 grp) =,= by [[#h:E4A5FB8F-3DEF-4AA2-8457-E7DE648EC0F4][StructPatternField]]
+ (opt) =,=
:end:

**Inlined this unless something else references it in a way that requires otherwise**.

Via [[#h:8E0DC05B-1ED6-47BE-9589-64DC06FAECCA][parse_many]] in [[#h:44A2D194-B244-4E4C-B53E-2FCF3F4165E2][parent]], split by =,= until =}=, each parsed as [[#h:E4A5FB8F-3DEF-4AA2-8457-E7DE648EC0F4][StructPatternField]].

*************** TODO Update in-code Noir docs for StructPatternFields
The question mark in the grouping should be an asterisk no?
*************** END

****** SPEC StructPatternField                                         :node:
:PROPERTIES:
:CUSTOM_ID: h:E4A5FB8F-3DEF-4AA2-8457-E7DE648EC0F4
:END:
:LOGBOOK:
- State "SPEC"       from "BLOCK"      [2025-06-12 Thu 17:15]
- State "BLOCK"      from "TODO"       [2024-11-13 Wed 02:22] \\
  Until Path is completed.
:END:
:pgd:
+ [[#h:65B0176B-B46F-4679-8535-C504870AC048][ident]] (token)
+ (opt grp) =:= by [[#h:D349E307-F033-4D2A-A729-F2EE5B483065][Pattern]]
:end:

TODO: Is this similar enough to other rules we can reduce it to a single shared one?

#+name: struct_pattern_field
#+begin_src js :arg $ :ast StructPatternField
seq(
    $.identifier,
    optional(seq(':', <<r("pattern")>>)),
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/pattern.rs::fn parse_struct_pattern_field(&mut self)][parse_struct_pattern_field()]]

***** SPEC IdentifierPattern                                           :leaf:
:PROPERTIES:
:CUSTOM_ID: h:CE58024C-51AD-4A68-A57B-CE4E6D5C0552
:END:
:LOGBOOK:
- State "SPEC"       from "TODO"       [2025-06-12 Thu 17:31]
:END:
:pgd:
+ [[#h:65B0176B-B46F-4679-8535-C504870AC048][ident]] (token)
:end:

**** UPGR SelfPattern
:PROPERTIES:
:CUSTOM_ID: h:5B14A337-12EC-477C-8269-961094FAB41B
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "SPEC"       [2025-07-24 Thu 18:19]
- State "SPEC"       from "TODO"       [2025-06-12 Thu 16:26]
:END:

#+name: self_pattern
#+begin_src js :arg $ :ast SelfPattern
seq(
    optional('&'),
    optional(<<r("modifier_mut")>>),
    $.self,
)
#+end_src

Parser (sop): [[#h:464E9BE0-4EC7-4D73-A1F2-F9C581DFD8E3][PatternOrSelf]]
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/pattern.rs::19][SelfPattern doc]]  :lines 19-19 :src rust

*************** TODO Update upstream in-code docs if =&self= is in-fact valid?
In-code don't suggest so but parser logic (thus far) says it is. Going to proceed as if it is for now though.
*************** END

:note:
TODO: Claim sounds dubious based on doc comments, test if unclear when TOIMPL status.
Guaranteed to NOT have a colon =:= following it.

=self= is not a true keyword as it is contextual.
#+transclude: [[file:noir/compiler/noirc_frontend/src/lexer/token.rs::1093][`self` is not a keyword]] :lines 1093-1094 :src rust
:end:

*** TODO Expression
:PROPERTIES:
:CUSTOM_ID: h:167542CC-8CDE-49C1-9465-E5157C6A176F
:END:
:LOGBOOK:
- State "TODO"       from              [2025-06-12 Thu 18:48]
:END:

- [[id:7A38952D-D669-4DD6-AF3A-065CB546CB21][Infix]] (BinaryExpression)
- [[#h:24F065BB-8AC3-48EE-8C8E-64E188E2AE16][Literal]]

#+name: expression
#+begin_src js :rule _expression :arg $
prec.left(1,
choice(
    <<r("binary_expression")>>,
    <<r("generic_function")>>, // Ours.
    // Inlined Noirc: Atom.
    <<r("literal")>>,
      // Inlined Noirc: ParenthesesExpression.
      alias(<<r("unit_type")>>, $.unit_expression),
      <<r("parenthesised_expression")>>,
      <<r("tuple_expression")>>,
    <<r("unsafe_block")>>,
      // Inlined Noirc: PathExpression.
      <<r("path")>>, // Inlined Noirc: VariableExpression.
      <<r("constructor_expression")>>,
    <<r("if_expression")>>,
    <<r("lambda")>>,
    <<r("comptime_block")>>,
    // r("unquote_expression")>>, // XXX: Moving so only valid within QuoteExpression.
    // TypePathExpression is Path.
    alias(<<r("trait_path_alias")>>, $.path),
    // Blocked: ResolvedExpression, InternedExpression, InternedStatementExpression.
    // ---/ End: Atom.
    <<r("unary_op")>>,
    // Inlined Noirc: UnaryRightExpression.
      <<r("call_expression")>>,
      <<r("member_access_expression")>>,
      <<r("cast_expression")>>,
      <<r("index_expression")>>,
    // TODO: SURELY identifier is allowed in expression, where's the concrete evidence though? Assuming it is for now.
    <<r("identifier")>>,
))
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::fn parse_expression_or_error(&mut self)][parse_expression_or_error()]], [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::fn parse_expression_impl(&mut self, allow_constructors: bool)][parse_expression_impl()]], [[file:noir/compiler/noirc_frontend/src/parser/parser/infix.rs::fn parse_equal_or_not_equal(][parse_equal_or_not_equal()]]

*************** TODO Document Literal as appropriate in org tree
Currently lots of confusing names, got lexing at the top, literal at the bottom with more lexing info (which does make sense tho) and then also an AST node called Literal we should keep track of:
[[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::/// Literal][Literal doc]]
*************** END

**** Infix                                                           :pseudo:
:PROPERTIES:
:CUSTOM_ID: h:ACCBF119-4052-4C4E-87CE-F7B233FF4AA1
:END:

#+caption: Purely so we can insert literal =<<= and =>>= into the noweb template without it being treated as a noweb reference.
#+name: ab_lit
| << | >> |

#+name: binary_expression
#+begin_src js :arg $ :ast "EqualOrNotEqualExpression -- Entire nested hierarchy flattened and renamed."
{
    const t = [
        // Highest to lowest.
        [PRECEDENCE.multiplicitive, choice('*', '/', '%',)],
        [PRECEDENCE.additive, choice('+', '-')],
        [PRECEDENCE.bitshift, choice('<<ab_lit()[0,0]>>', '<<ab_lit()[0,1]>>')],
        [PRECEDENCE.comparative, choice('<', '<=', '>', '>=')],
        [PRECEDENCE.bitxor, '^'],
        [PRECEDENCE.bitand, '&'],
        [PRECEDENCE.or, '|'],
        [PRECEDENCE.equality, choice('==', '!=')],
    ]

    return choice(...t.map(([p, o]) => prec.left(p, seq(
        field('left', <<r("expression")>>),
        field('operator', o),
        field('right', <<r("expression")>>),
    ))))
}
#+end_src

All the expression nodes in [[file:noir/compiler/noirc_frontend/src/parser/parser/infix.rs][infix.rs]] constitute binary expressions and their call hierarchy via [[#h:CE180901-F6F2-4A65-878D-6C9154971376][parse_infix]] denotes the reverse of their precedence. Note that the deepest call (in that file) [[file:noir/compiler/noirc_frontend/src/parser/parser/infix.rs::pub(super) fn parse_multiply_or_divide_or_modulo(][parse_multiply_or_divide_or_modulo()]] further calls [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::pub(super) fn parse_term(&mut self, allow_constructors: bool)][parse_term()]] meaning all of Term's (TODO: link) expressions are higher priority still.

**** UPGR Literal
:PROPERTIES:
:CUSTOM_ID: h:24F065BB-8AC3-48EE-8C8E-64E188E2AE16
:END:
:LOGBOOK:
- State "UPGR"       from "TODO"       [2026-02-19 Thu 20:40] \\
  v1.0.0-beta.19 Noir, lots different.
:END:

- [[id:CF0A439A-EFBB-466E-8F5F-7A8827EB703E][QuoteExpression]]
- [[#h:48EA91F0-AB43-4FEF-94F1-3837C634CF38][ArrayExpression]]
- [[#h:C6FDB5DB-21D9-46A2-A4E8-DEE2AFFD1F6F][SliceExpression]]
- [[#h:B34CADE5-71B4-41F2-AB54-00483EE593A6][BlockExpression]]

#+name: literal
#+begin_src js :rule __literal :arg $ :ast Literal
prec(
    // Literals need to bind more tightly than Statement so things like SliceExpression are correctly associated. Since this is similar to Unary we use the same precedence level.
    PRECEDENCE.unary,
    choice(
        <<r("bool")>>,
        <<r("int")>>,
        <<r("str")>>,
        <<r("raw_str")>>,
        <<r("fmt_str")>>,
        <<r("quote")>>,
        <<r("array_expression")>>,
        <<r("slice_expression")>>,
        <<r("block")>>,
    ),
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::fn parse_literal(&mut self)][parse_literal()]]

#+name: ,ebnf_literal
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::/// Literal][Literal, QuoteExpression, ArrayExpression, BlockExpression doc]]  :lines 1- :src fundamental :end "fn parse_literal("

**** TODO AtomOrUnaryRightExpression
2025/07/23 TODO

**** SPEC UnaryOp
:PROPERTIES:
:CUSTOM_ID: h:4C18FF90-351E-43E9-95BA-F81704718B2F
:END:
:LOGBOOK:
- State "SPEC"       from "TODO"       [2025-07-24 Thu 01:57] \\
  Parser examined
:END:

#+name: unary_op
#+begin_src js :rule unary_expression :arg $ :ast UnaryOp
prec(PRECEDENCE.unary, seq(
    choice(seq('&', 'mut'), '-', '!', '*'),
    <<r("expression")>>,
))
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::fn parse_unary_op(&mut self)][parse_unary_op()]]
Types: [[file:noir/compiler/noirc_frontend/src/ast/expression.rs::pub enum UnaryOp {][UnaryOp enum]]

**** UPGR CallExpression
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-07-23 Wed 01:10]
- State "TODO"       from              [2025-07-23 Wed 00:37]
:END:

#+name: call_expression
#+begin_src js :arg $ :ast CallExpression
prec(PRECEDENCE.call, seq(
    field('function', <<r("expression")>>),
    field('arguments', <<r("call_arguments")>>),
))
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::fn parse_call(&mut self, atom: Expression, start_span: Span)][parse_call()]]
Types: [[file:noir/compiler/noirc_frontend/src/ast/expression.rs::pub struct CallExpression {][CallExpression struct]]

*************** TODO Whether or not this is a macro call (also see CallArguments) here
*************** END

**** GenericFunction                                                 :pseudo:

#+name: generic_function
#+begin_src js :arg $ :ast "Ours: GenericFunction"
prec(
    1, // Precedence so long as it's higher than Path.
    seq(
        field('function', choice(
            <<r("identifier")>>,
            <<r("member_access_expression")>>,
        )),
        '::',
        // TODO: Alias generic_type_parameters usage to CST node 'type_arguments' here and elsewhere.
        field('type_arguments', <<r("generic_type_parameters")>>),
    )
)   
#+end_src

Before this rule anything with a turbofish in it was essentially considered a path with generics, however that's not technically correct (however I think Noirc makes this a little ambiguous IIRC). Paths (i.e. =::= delimited )that included generics and ended in a call expression worked fine but access expressions (i.e. =.= delimited) did not work as it was not possible to then parse an identifier followed by =::<T>= by =()=. This also addresses an internal TODO about CallExpression with paths looking ugly (as Path) was involved.

*************** TODO Further refinements on path probably required in the long run
What's considered a path versus call expression, member access etc etc. Basically just need to add more tests in the Noirc side to get back what the compiler frontend considers a thing and mirror that here. For now our rules are correct (in that they parse things correctly etc) but their names (semantics) /might/ not be the best.
*************** END
*************** TODO Might need to also rename 'generic' (as in a generic type) to that also, since this CST rule will be 'generic_function'.
*************** END

**** TOIMPL MemberAccessExpression
:LOGBOOK:
- State "TOIMPL"     from "SPEC"       [2025-07-23 Wed 01:42] \\
  Turbofish makes the rule implode in it's current form.
- State "TODO"       from              [2025-07-23 Wed 00:37]
:END:

#+name: member_access_expression
#+begin_src js :rule access_expression :arg $ :ast MemberAccessExpression
prec(PRECEDENCE.access, seq(
    field('scope', <<r("expression")>>),
    '.',
    field('name', choice(<<r("identifier")>>, <<r("int")>>)),
))
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::fn parse_member_access_or_method_call(][parse_member_access_or_method_call()]]
Types: [[file:noir/compiler/noirc_frontend/src/ast/expression.rs::pub struct MemberAccessExpression {][MemberAccessExpression]]

**** TOIMPL MethodCallExpression
:LOGBOOK:
- State "TOIMPL"     from "TODO"       [2025-07-23 Wed 01:42] \\
  See MemberAccessExpression
- State "TODO"       from              [2025-07-23 Wed 00:37]
:END:

2025/07/23: Does it need it's own CST node...?

**** UPGR CastExpression
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-07-23 Wed 01:41]
- State "TODO"       from              [2025-07-23 Wed 00:37]
:END:

#+name: cast_expression
#+begin_src js :arg $ :ast CastExpression
prec(PRECEDENCE.cast, seq(
    field('value', <<r("expression")>>),
    'as',
    field('type', <<r("type")>>),
))
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::fn parse_cast(&mut self, atom: Expression, start_span: Span)][parse_cast()]]
Types: [[file:noir/compiler/noirc_frontend/src/ast/expression.rs::pub struct CastExpression {][CastExpression struct]]

**** UPGR IndexExpression
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-07-23 Wed 01:41]
- State "TODO"       from              [2025-07-23 Wed 00:37]
:END:

#+name: index_expression
#+begin_src js :arg $ :ast IndexExpression
prec(PRECEDENCE.cast, seq(
    field('collection', <<r("expression")>>),
    '[',
    field('index', <<r("expression")>>),
    ']',
))
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::fn parse_index(&mut self, atom: Expression, start_span: Span)][parse_index()]]
Types: [[file:noir/compiler/noirc_frontend/src/ast/expression.rs::pub struct IndexExpression {][IndexExpression struct]]

**** UPGR QuoteExpression
:PROPERTIES:
:ID:       CF0A439A-EFBB-466E-8F5F-7A8827EB703E
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-07-26 Sat 03:02]
- State "TODO"       from              [2025-06-17 Tue 18:15] \\
  Top-level recursion, see quote literal, deferring ultimately.
:END:
https://noir-lang.org/docs/noir/concepts/comptime#quasi-quote

Implemented at: [[#h:3F001F84-17D8-4B0D-912F-67AF98F72CD4][quote]].

*************** TODO EBNF update
See Literals EBNF for QuoteExpression, the braces can be one of three kinds (brackets, braces, parens) as long as it's a matching pair.
*************** END

**** UPGR ArrayExpression
:PROPERTIES:
:CUSTOM_ID: h:48EA91F0-AB43-4FEF-94F1-3837C634CF38
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-06-22 Sun 02:11]
- State "TODO"       from              [2025-06-21 Sat 16:38]
:END:

- [[#h:D27534C1-90A8-4A0C-A601-55A631D16C89][StandardArrayLiteral]]
- [[#h:437EA6B2-BF82-44D3-8B1F-ABA5BD8B3675][RepeatedArrayLiteral]]

#+name: array_expression
#+begin_src js :arg $ :ast ArrayExpression
seq(
    '[',
    choice(
        // Inlined Noirc: StandardArrayLiteral and ArrayElements.
        seq(
            sepBy(<<r("expression")>>, ','),
            optional(','),
        ),
        // Inlined Noirc: RepeatedArrayLiteral.
        seq(
            <<r("expression")>>,
            ';',
            field('length', <<r("type_expr")>>),
        ),
    ),
    ']',
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::if let Some(literal) = self.parse_array_literal() {][parse_array_literal() parent callsite]], [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::fn parse_array_literal(&mut self)][parse_array_literal()]]

#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::577][ArrayExpression doc]]  :lines 577-577 :src fundamental

#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::620][ArrayLiteral, StandardArrayLiteral, ArrayElements, RepeatedArrayLiteral docs]]  :lines 620-628 :src fundamental

***** UPGR StandardArrayLiteral                                    :node:
:PROPERTIES:
:CUSTOM_ID: h:D27534C1-90A8-4A0C-A601-55A631D16C89
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-06-22 Sun 02:11]
- State "TODO"       from              [2025-06-21 Sat 16:54]
:END:
:pgd:
+ =[=
+ (opt):
  + [[#h:167542CC-8CDE-49C1-9465-E5157C6A176F][Expression]]
  + (rep0 grp) =,= by [[#h:167542CC-8CDE-49C1-9465-E5157C6A176F][Expression]]
  + (opt) =,=
+ =]=
:end:

Here StandardArrayLiteral and ArrayElements form the same kind of "Foo" in a "FooList" parameter used elsewhere, e.g. FunctionParameter(s) and FunctionParametersList, UseTree, UseTreeList etc.

Parser at parent. Returns ~ArrayLiteral::Standard~

***** UPGR RepeatedArrayLiteral                                    :node:
:PROPERTIES:
:CUSTOM_ID: h:437EA6B2-BF82-44D3-8B1F-ABA5BD8B3675
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-06-22 Sun 02:11]
- State "TODO"       from              [2025-06-21 Sat 16:54]
:END:
:pgd:
+ =[= by [[#h:167542CC-8CDE-49C1-9465-E5157C6A176F][Expression]] by =;= by [[#h:0DEF3192-4840-41B3-A941-714798677092][TypeExpression]] by =]=
:end:

Parser at parent. Returns ~ArrayLiteral::Repeated~.

**** UPGR SliceExpression
:PROPERTIES:
:CUSTOM_ID: h:C6FDB5DB-21D9-46A2-A4E8-DEE2AFFD1F6F
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from              [2025-06-24 Tue 16:48]
:END:

#+name: slice_expression
#+begin_src js :arg $ :ast SliceExpression
seq('&', <<r("array_expression")>>)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::if let Some(literal) = self.parse_slice_literal() {][parse_slice_literal() parent callsite]], [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::fn parse_slice_literal(&mut self)][parse_slice_literal()]]

#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::670][SliceExpression doc]]  :lines 670-670 :src fundamental

**** TODO BlockExpression                                             :alias:
:PROPERTIES:
:CUSTOM_ID: h:B34CADE5-71B4-41F2-AB54-00483EE593A6
:END:
:LOGBOOK:
- State "TODO"       from              [2025-05-15 Thu 20:50]
:END:

#+name: block
#+begin_src js :arg $ :ast "Block, BlockExpression, BlockStatement"
seq(
    '{',
    repeat(<<r("statement")>>),
    optional(<<r("expression")>>),
    '}',
)
#+end_src

Modifiers for Block need to be their own CST rule since Block is so bare there's nowhere else to put a field or anonymous node for the modifier, unlike say Function.

#+name: comptime_block
#+begin_src js :rule comptime :arg $ :ast "ComptimeExpression, ComptimeBlock"
seq('comptime', <<r("block")>>)
#+end_src

#+name: unsafe_block
#+begin_src js :rule unsafe :arg $ :ast UnsafeExpression
seq('unsafe', <<r("block")>>)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::fn parse_block(&mut self)][parse_block()]]
Callsites:
  - [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::if let Some(kind) = self.parse_block() {][in parse_literal()]] (for: [[#h:3446FD3E-4526-4DBF-80AB-64BD9078C4F5][Literals]], as: ~BlockExpression~)
  - [[file:noir/compiler/noirc_frontend/src/parser/parser/function.rs::Some(self.parse_block().unwrap_or_else(empty_body))][in parse_function_definition_with_optional_body()]] (for: [[#h:B3C4609F-307A-42A1-B420-DBBAB6CDE6E5][Function]], as: ~BlockExpression~)
  - [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::if let Some(block) = self.parse_block() {][in parse_unsafe_expr()]] (for: [[#h:AE41A3D6-2311-40DB-998F-1E15B5A0C07D][UnsafeExpression]], as: ~UnsafeExpression(BlockExpression)~)
  - [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::let Some(block) = self.parse_block() else {][in parse_comptime_expr()]] (for: [[#h:6424BB7B-2E77-4E26-84EC-D574E74F0520][ComptimeExpression]], as: ~BlockExpression~)
  - [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::if let Some(block) = self.parse_block() {][in parse_comptime_statement_kind()]] (for: [[#h:A0796B1B-462F-4DC6-BE7D-F1D87112AFD4][ComptimeStatement]], as: ~BlockExpression~)

Via [[#h:8E0DC05B-1ED6-47BE-9589-64DC06FAECCA][parse_many]] split by nothing until =}= each parsed as a [[#h:788ECB8C-0A48-4255-B35E-F5850902AA32][Statement]] via [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::fn parse_statement_in_block(&mut self)][parse_statement_in_block()]].

All statements except the last require a semicolon at the end, see [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::fn check_statements_require_semicolon(][check_statements_require_semicolon()]]. It is generally an error for non-terminal statements to NOT have a semicolon **however** specific of which statement kinds require a semicolon are found on [[file:noir/compiler/noirc_frontend/src/ast/statement.rs::impl StatementKind {][impl StatementKind::add_semicolon()]].

Struct ~BlockExpression~ ([[file:noir/compiler/noirc_frontend/src/ast/expression.rs::pub struct BlockExpression {][src]]) contains vector of ~Statement~ structs, each of a ~StatementKind~ ([[file:noir/compiler/noirc_frontend/src/ast/statement.rs::pub enum StatementKind {][src]]) enum (see also: [[#h:788ECB8C-0A48-4255-B35E-F5850902AA32][Statement]]).

*************** TODO Go through add_semicolon documenting the statements that require a semicolon for ts grammar
*************** END

#+name: ,ebnf_block
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::721][Block doc]]  :lines 721-721 :src fundamental

**** UPGR If                                                       :alias:
:PROPERTIES:
:CUSTOM_ID: h:16951F18-730F-4A1F-84C9-3A1F78F67DF0
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-06-29 Sun 20:01]
- State "TODO"       from              [2025-06-26 Thu 17:58]
:END:

#+name: if_expression
#+begin_src js :arg $ :ast "IfStatement, IfExpression"
seq(
    'if',
    field('condition', <<r("expression")>>),
    field('consequence', <<r("block")>>),
    optional(seq(
        'else',
        field('alternative', choice(<<r("block")>>, <<self()>>)),
    )),
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::fn parse_if_expr(&mut self)][parse_if_expr()]]
Callsites:
  - [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::if let Some(kind) = self.parse_if_expr() {][in parse_statement_kind()]] (for: [[#h:788ECB8C-0A48-4255-B35E-F5850902AA32][Statement]], as: IfStatement)
  - [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::if let Some(kind) = self.parse_if_expr() {][in parse_atom_kind()]] (for: (TODO: Link Atom), as: IfExpression)

#+name: ,ebnf_if_expression
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::442][IfExpression doc]]  :lines 442-442 :src fundamental

*************** TODO This has ExpressionExceptConstructor stuff similar to ForRange
Refactor accordingly, if appropriate.
*************** END

*** TOIMPL Statement
:PROPERTIES:
:CUSTOM_ID: h:788ECB8C-0A48-4255-B35E-F5850902AA32
:END:
:LOGBOOK:
- State "TOIMPL"     from "TODO"       [2025-07-15 Tue 21:25] \\
  Parser function explored, need to consider what to do for ts rule
:END:

#+name: statement
#+begin_src js :rule _statement :arg $ :ast Statement
seq(
    // TODO: Attributes.
    choice(
        // Inlined Noirc: StatementKind.
        <<r("break_statement")>>,
        <<r("continue_statement")>>,
        <<r("return_statement")>>,
        <<r("let_statement")>>,
        <<r("constrain_statement")>>,
        <<r("comptime_block")>>, // Inlined Noirc: ComptimeBlock.
        // Inlined Noirc: ComptimeStatement sans ComptimeBlock.
        alias(<<r("comptime_statement__let_for")>>, $.comptime),
        <<r("for_statement")>>,
        <<r("if_expression")>>,
        // Block and it's variants appear to all be valid at each other's locations.
        <<r("block")>>,
        <<r("comptime_block")>>,
        <<r("unsafe_block")>>,
        <<r("assign_statement")>>,
        <<r("expression_statement")>>,
    ),
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::fn parse_statement(&mut self)][parse_statement()]]
Types: [[file:noir/compiler/noirc_frontend/src/ast/statement.rs::pub enum StatementKind {][StatementKind enum]]

Loop parsing attributes and [[#h:7BCA6405-C905-45AB-A3C7-1B7F6064454A][StatementKind]], each StatementKind is delimited by a semicolon.

#+name: ,ebnf_statement
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::25][Statement doc]]  :lines 25-25 :src fundamental

**** BLOCK StatementKind
:PROPERTIES:
:CUSTOM_ID: h:7BCA6405-C905-45AB-A3C7-1B7F6064454A
:END:
:LOGBOOK:
- State "BLOCK"      from "TODO"       [2025-07-08 Tue 22:20] \\
  Finish breadth-first grammar exploration, when StatementKind callsites known can continue.
- State "TODO"       from              [2025-05-20 Tue 18:16]
:END:

- [[#h:71AB7D76-FD24-4B91-A187-E9968024DC0C][BreakStatement]]
- [[#h:6616DE79-93E3-42AA-9633-4A29251F5BA0][ContinueStatement]]
- [[#h:17935AE3-A964-49D1-927B-E67D035FD8D7][ReturnStatement]]
- [[#h:FD70AFA1-5D45-434E-A9D0-7E8F6DD38058][LetStatement]]
- [[#h:25216601-CAF6-4246-8289-B106F9A9166B][ConstrainStatement]]
- [[#h:A0796B1B-462F-4DC6-BE7D-F1D87112AFD4][ComptimeStatement]]
- [[#h:F444339D-00F1-4553-ACF6-DE0B5E2EE35E][ForStatement]]
- [[#h:BB36CCC8-4FE6-4529-A365-69F0011CEC2A][IfStatement]]
- [[#h:B305BFF3-A865-4292-A8E5-5448D38CE872][BlockStatement]]
- [[#h:D8D0BBE8-6152-479B-8C19-282B2B56C4A9][AssignStatement]]
- [[#h:12F5ADF9-E496-4D5B-896E-5CE97D44BE3D][ExpressionStatement]]

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::fn parse_statement_kind(][parse_statement_kind()]]
Types: [[file:noir/compiler/noirc_frontend/src/ast/statement.rs::pub struct Statement {][Statement struct]] / [[file:noir/compiler/noirc_frontend/src/ast/statement.rs::pub enum StatementKind {][StatementKind enum]]

~StatementKind::Semi~ is an ~Expression~ with a trailing semicolon, i.e. an expression-statement (TODO: link to PROJECT.org).

#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::59][StatementKind doc]]  :lines 59-70 :src fundamental

Top of parser function checks for a specially lexed ~TokenKind::InternedStatement~. If that is the next token a ~StatementKind::Interned~ of that statement is returned. Remember the return here returns at the function (i.e. ~parse_statement_kind()~ level).

#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::91][TokenKind::InternedStatement check]]  :lines 91-98 :src rust

*************** TODO Have we done/added stuff for interned statements yet? Lex notes for interned statements also?
*************** END
*************** TODO See line 85:97 on ast/statement.rs
Copied:                 // To match rust, statements always require a semicolon, even at the end of a block

We'll want to take note of that for the grammar.
*************** END

***** TODO Block-Ending Statements
:PROPERTIES:
:CUSTOM_ID: h:B617D31A-7FDE-4BB3-AB4D-5E79254585BB
:END:
:LOGBOOK:
- State "TODO"       from              [2025-05-20 Tue 20:13]
:END:

#+begin_src js :treesit t
// Statements ending in blocks, thus not requiring semicolons.
_block_ending_statements: ($) => choice(
    $.for_statement,
    // $.interned_statement, // TODO: Commented temporarily.
    //$.block,
    // $.unsafe_expression, // TODO: Commented temporarily.
    // $.interned_expression, // TODO: Commented temporarily.
    // $.if_statement, // TODO: Commented temporarily.
)
#+end_src

***** UPGR BreakStatement
:PROPERTIES:
:CUSTOM_ID: h:71AB7D76-FD24-4B91-A187-E9968024DC0C
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TOIMPL"     [2025-06-24 Tue 17:43]
- State "TOIMPL"     from "TODO"       [2025-05-20 Tue 19:03]
- State "TODO"       from              [2025-05-20 Tue 18:16]
:END:

#+name: break_statement
#+begin_src js :ast BreakStatement
seq('break', ';')
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::if self.eat_keyword(Keyword::Break) {][parse_break_statement() parent inline]]

See [[#h:3F52F622-294C-463F-986F-DD38EB41EA89][add_semicolon]], ~StatementKind::Break~ always requires a semicolon.

Takes nothing (unlike say Rust where an expression can follow), only the keyword.

***** UPGR ContinueStatement
:PROPERTIES:
:CUSTOM_ID: h:6616DE79-93E3-42AA-9633-4A29251F5BA0
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TOIMPL"     [2025-06-24 Tue 17:47]
- State "TOIMPL"     from "TODO"       [2025-05-20 Tue 19:07]
- State "TODO"       from              [2025-05-20 Tue 18:16]
:END:

#+name: continue_statement
#+begin_src js :ast ContinueStatement
seq('continue', ';')
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::if self.eat_keyword(Keyword::Continue) {][parse_continue_statement() parent inline]]

See [[#h:3F52F622-294C-463F-986F-DD38EB41EA89][add_semicolon]], ~StatementKind::Continue~ always requires a semicolon.

***** UPGR ReturnStatement
:PROPERTIES:
:CUSTOM_ID: h:17935AE3-A964-49D1-927B-E67D035FD8D7
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-06-25 Wed 14:06]
- State "TODO"       from              [2025-05-20 Tue 18:16]
:END:

#+name: return_statement
#+begin_src js :arg $ :ast ReturnStatement
seq('return', optional(<<r("expression")>>), ';')
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::if self.eat_keyword(Keyword::Return) {][parse_return_statement() parent inline]]

See [[#h:3F52F622-294C-463F-986F-DD38EB41EA89][add_semicolon]], ~StatementKind::Error~ always requires a semicolon.

#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::76][ReturnStatement doc]]  :lines 76-76 :src fundamental

*************** TODO Does the BNF doc have an error is is code missing that makes it actually optional?
*************** END

***** SPEC LetStatement
:PROPERTIES:
:CUSTOM_ID: h:FD70AFA1-5D45-434E-A9D0-7E8F6DD38058
:END:
:LOGBOOK:
- State "SPEC"       from "TODO"       [2025-06-26 Thu 02:11] \\
  Still needs more test coverage
- State "TODO"       from              [2025-05-20 Tue 18:16]
:END:

#+name: let_statement
#+begin_src js :arg $ :ast LetStatement
seq(
    'let',
    optional(<<r("modifier_mut")>>),
    field('pattern', <<r("pattern")>>),
    <<field__type_annotation>>,
    '=',
    field('value', <<r("expression")>>),
    ';',
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::if self.at_keyword(Keyword::Let) {][parse_let_statement() parent callsite]], [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::fn parse_let_statement(&mut self, attributes: Vec<(Attribute, Span)>)][parse_let_statement()]]

See [[#h:3F52F622-294C-463F-986F-DD38EB41EA89][add_semicolon]], ~StatementKind::Let~ always requires a semicolon.

#+name: ,ebnf_let_statement
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::351][LetStatement doc]]  :lines 351-351 :src fundamental

*************** TODO Change pattern field name to 'name'?
Makes more sense I think
*************** END
*************** TODO Change rendered rule name to let_declaration?
This kind of ties into using Statements as a category in the final rendered grammar.js anyway, since all _things_ are going to be at least statements anyway (or really, expressions since a statement is an expression with no return value). Semantics.
*************** END
*************** TODO Validate secondary attributes stuff in the let statement parse.
I don't think we need to do that these attributes come from Statement, so long as we have things set correctly on Statement in terms of parsing attributes we're fine here (for the purpose of tree-sitter) I think.
*************** END
*************** TODO Noirc EBNF for pattern needs to be capital P since it's a proper AST node?
*************** END

***** UPGR ConstrainStatement
:PROPERTIES:
:CUSTOM_ID: h:25216601-CAF6-4246-8289-B106F9A9166B
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-06-26 Thu 16:15]
- State "TODO"       from              [2025-05-20 Tue 18:16]
:END:

#+name: constrain_statement
#+begin_src js :arg $ :ast ConstrainStatement
seq(
    // XXX: Keyword 'constrain' is deprecated, we're not going to include it at all.
    // 'assert' expects 1 or 2 parameters, 'assert_eq' expects 2 or 3. This is out of scope for tree-sitter grammar (at least for now), if it's a boon without huge complexity the rules can be augmented to enforce this later.
    choice('assert', 'assert_eq'),
    field('arguments', <<r("arguments")>>),
    ';',
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::if let Some(constrain) = self.parse_constrain_statement() {][parse_constrain_statement() parent callsite]], [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::fn parse_constrain_statement(&mut self)][parse_constrain_statement()]], [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::fn parse_constrain_kind(&mut self)][parse_constrain_kind()]]

See [[#h:3F52F622-294C-463F-986F-DD38EB41EA89][add_semicolon]], ~StatementKind::Constrain~ always requires a semicolon.

#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::370][ConstrainStatement doc]]  :lines 370-373 :src fundamental

***** UPGR ComptimeStatement
:PROPERTIES:
:CUSTOM_ID: h:A0796B1B-462F-4DC6-BE7D-F1D87112AFD4
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "SPEC"       [2025-06-26 Thu 17:51]
- State "SPEC"       from "TODO"       [2025-06-26 Thu 16:29] \\
  Doing ForStatement before tests since it depends on that
- State "TODO"       from              [2025-05-20 Tue 18:16]
:END:

ComptimeBlock inlined at [[#h:788ECB8C-0A48-4255-B35E-F5850902AA32][Statement]]. Also see [[#h:B34CADE5-71B4-41F2-AB54-00483EE593A6][BlockExpression]].

#+name: comptime_statement__let_for
#+begin_src js :arg $ :ast "ComptimeStatement sans ComptimeBlock"
seq(
    'comptime',
    choice(
        <<r("let_statement")>>, // Inlined Noirc: ComptimeLet.
        <<r("for_statement")>>, // Inlined Noirc: ComptimeFor.
    ),
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::if self.at_keyword(Keyword::Comptime) {][parse_comptime_statement() parent callsite]], [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::fn parse_comptime_statement(][parse_comptime_statement()]], [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::fn parse_comptime_statement_kind(][parse_comptime_statement_kind()]]

#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::291][ComptimeStatement ComptimeBlock ComptimeLet ComptimeFor doc]]  :lines 291-300 :src fundamental

****** ComptimeBlock                                                  :alias:
:PROPERTIES:
:CUSTOM_ID: h:5092AC79-344E-465F-973E-70DC2ECF38FB
:END:

**Inlined unless something else references it in a way that requires otherwise**.

****** ComptimeLet                                                     :node:
:PROPERTIES:
:CUSTOM_ID: h:46D5DE09-D9EB-4227-BB31-BA77B8B0063D
:END:

**Inlined unless something else references it in a way that requires otherwise**.

****** ComptimeFor                                                     :node:
:PROPERTIES:
:CUSTOM_ID: h:B0F78DC8-11C8-4D7E-A72C-7C3498574225
:END:

**Inlined unless something else references it in a way that requires otherwise**.

***** SPEC ForStatement
:PROPERTIES:
:CUSTOM_ID: h:F444339D-00F1-4553-ACF6-DE0B5E2EE35E
:END:
:LOGBOOK:
- State "SPEC"       from "TODO"       [2025-06-26 Thu 17:47] \\
  Still needs more test coverage
- State "TODO"       from              [2025-05-20 Tue 18:16]
:END:

#+name: for_statement
#+begin_src js :arg $ :ast ForStatement
seq(
    'for',
    field('value', <<r("identifier")>>),
    'in',
    field('range', choice(
        <<r("expression")>>,
        <<r("for_range")>>,
    )),
    field('body', <<r("block")>>),
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::if let Some(for_loop) = self.parse_for() {][parse_for() parent callsite]], [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::fn parse_for(&mut self)][parse_for()]]
Types: [[file:noir/compiler/noirc_frontend/src/ast/statement.rs::pub struct ForLoopStatement {][ForLoopStatement struct]]

#+name: ,ebnf_for_statement
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::227][ForStatement doc]]  :lines 227-227 :src fundamental

****** UPGR ForRange
:PROPERTIES:
:CUSTOM_ID: h:C859B697-6DDD-4F6D-B70B-BF0A9FBA6E80
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-06-26 Thu 17:47]
- State "TODO"       from              [2025-06-26 Thu 16:42] \\
  ExpressionExceptConstructor look into this 'constructor'
:END:

#+name: for_range
#+begin_src js :rule range_expression :arg $ :ast ForRange
seq(
    <<r("expression")>>,
    '..',
    optional(token.immediate('=')),
    <<r("expression")>>,
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::fn parse_for_range(&mut self)][parse_for_range()]]
Types: [[file:noir/compiler/noirc_frontend/src/ast/statement.rs::pub enum ForRange {][ForRange enum]]

#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::262][ForRange doc]]  :lines 262-264 :src fundamental

*************** TODO Is this the general range expression/statement for noir? Assuming it is for now and have aliased rule name as such
*************** END
*************** TODO ExpressionExceptConstructor
Quick glance looks like no constructors means no paths or a function call, look into if we can reasonably support this in the ts grammar since it feels like it would duplicate the entire expression tree for a variant which has paths but without function/method calls.

UPDATE: Constructor pattern here looks to be like =Foo {}= i.e. the braces, which I guess makes sense. So the parsing rule is expression except something that looks like it has braces and is for a Struct which would .'. be a constructor, HOWEVER block-scoped expressions should be fine, like ={1 + 1 }=, because they don't have a leading identifier =Foo { 1 + 1 }= making them NOT constructors.
*************** END

***** UPGR IfStatement
:PROPERTIES:
:CUSTOM_ID: h:BB36CCC8-4FE6-4529-A365-69F0011CEC2A
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-06-26 Thu 17:58]
- State "TODO"       from              [2025-05-20 Tue 18:16]
:END:

**Just an alias for IfExpression**. Wraps IfExpression in ~StatementKind::Expression~.

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::if let Some(kind) = self.parse_if_expr() {][parse_if_expr() parent callsite]]

#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::78][IfStatement doc]]  :lines 78-78 :src fundamental

***** UPGR BlockStatement
:PROPERTIES:
:CUSTOM_ID: h:B305BFF3-A865-4292-A8E5-5448D38CE872
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-06-29 Sun 20:16]
- State "TODO"       from              [2025-05-20 Tue 18:16]
:END:

**Just an alias for Block**. Wraps Block in ~StatementKind::Expression~.

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::if let Some(block) = self.parse_block() {][parse_block() parent callsite]]

#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::80][BlockStatement doc]]  :lines 80-80 :src fundamental

***** UPGR AssignStatement
:PROPERTIES:
:CUSTOM_ID: h:D8D0BBE8-6152-479B-8C19-282B2B56C4A9
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "BLOCK"      [2025-07-25 Fri 02:22]
- State "BLOCK"      from "SPEC"       [2025-07-08 Tue 22:21] \\
  See entry at this time for StatementKind.
- State "SPEC"       from "TODO"       [2025-07-07 Mon 15:27]
- State "TODO"       from              [2025-05-20 Tue 18:16]
:END:

#+name: assign_statement
#+begin_src js :arg $ :ast AssignStatement
seq(
    field('left', <<r("expression")>>),
    choice(
        // Desugared (and limited) binary expression assignment, see: next_is_op_assign.
        '+=', '-=', '*=', '/=', '%=', '&=', '^=', '<<ab_lit()[0,0]>>=', '|=', '<<ab_lit()[0,1]>>=',
        // Simple assignment.
        '=',
    ),
    field('right', <<r("expression")>>),
    ';',
)
#+end_src

Parser: defer to [[#h:37FF07C0-5DAA-467E-9DBA-8EBAC79F7DE4][AssignOrExpression]] as **multiple parse locations after BlockStatement**

See [[#h:3F52F622-294C-463F-986F-DD38EB41EA89][add_semicolon]], ~StatementKind::Assign~ always requires a semicolon.

For the AssignStatement struct, field =lvalue= is the thing which field =expression= is being assigned to.

*************** TODO If anything but simple assignment put them into a named field?
Makes it easier to do ts queries for += and -= etc
*************** END
*************** TODO keep left/right field name or use value/expression
left/right appears to be convention, but value/expression is more accurate to parser source.
*************** END

***** BLOCK ExpressionStatement
:PROPERTIES:
:CUSTOM_ID: h:12F5ADF9-E496-4D5B-896E-5CE97D44BE3D
:END:
:LOGBOOK:
- State "BLOCK"      from "SPEC"       [2025-07-08 Tue 22:21] \\
  See entry at this time for StatementKind.
- State "SPEC"       from "TODO"       [2025-07-07 Mon 15:27]
- State "TODO"       from              [2025-05-20 Tue 18:16]
:END:

#+name: expression_statement
#+begin_src js :arg $ :ast ExpressionStatement
seq(<<r("expression")>>, ';')
#+end_src

Parser: defer to [[#h:37FF07C0-5DAA-467E-9DBA-8EBAC79F7DE4][AssignOrExpression]] as **multiple parse locations after BlockStatement**

Project notes [[file:PROJECT.org::#h:9255C4E4-03B0-4A3B-B3AE-454FF2A53D57][definition of: expression statement]]. 

***** AssignOrExpression                                             :pseudo:
:PROPERTIES:
:CUSTOM_ID: h:37FF07C0-5DAA-467E-9DBA-8EBAC79F7DE4
:END:

Types: [[file:noir/compiler/noirc_frontend/src/ast/statement.rs::pub struct AssignStatement {][AssignStatement struct]], [[#h:BF579445-9EE4-4F65-B928-8E22987DFDBD][LValue]], [[file:noir/compiler/noirc_frontend/src/ast/statement.rs::pub enum StatementKind {][StatementKind enum]]


After [[#h:B305BFF3-A865-4292-A8E5-5448D38CE872][BlockStatement]]'s parent callsite the rest of =parse_statement_kind= mixes attempts to parse either an [[#h:D8D0BBE8-6152-479B-8C19-282B2B56C4A9][AssignStatement]] or an [[#h:12F5ADF9-E496-4D5B-896E-5CE97D44BE3D][ExpressionStatement]] in 3 major blocks, each block guarded by a condition and causes the parser enter an error-state if it's condition succeeds but parsing fails.


**Block 1**: If [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::if let Some(token) = self.eat_kind(TokenKind::InternedLValue) {][eat_kind(TokenKind::InternedLValue)]] then: eat an assign token ===, an [[#h:167542CC-8CDE-49C1-9465-E5157C6A176F][Expression]], and finally return a ~StatementKind::Assign(AssignStatement)~.

Between Block 1 and Block 2 an [[#h:167542CC-8CDE-49C1-9465-E5157C6A176F][Expression]] is optionally parsed. Remember since these blocks are guarded and set an error-state in failure if Block 1 was not triggered this is the first time we're parsing an Expression, if Block 1 was triggered and suceeded we never reach this line, if Block 1 was triggered but didn't parse the parser is at an error-state.

**Block 2**: If [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::if self.eat_assign() {][eat_assign()]] then: reify an [[#h:BF579445-9EE4-4F65-B928-8E22987DFDBD][LValue]] from the in-between parsed Expression (via [[file:noir/compiler/noirc_frontend/src/ast/statement.rs::pub fn from_expression(expr: Expression) -> Option<LValue> {][LValue::from_expression()]]), parse another [[#h:167542CC-8CDE-49C1-9465-E5157C6A176F][Expression]], and finally return a ~StatementKind::Assign(AssignStatement)~. If the reification failed a parse-error is pushed since the left-side of this attempted assignment must be invalid.

**Block 3**: if [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::if let Some(operator) = self.next_is_op_assign() {][next_is_op_assign()]] (see: [[#h:0AD7B3FC-EF8B-4DE5-85E9-19AFBC8CB257][next_is_op_assign]]) then: reify an [[#h:BF579445-9EE4-4F65-B928-8E22987DFDBD][LValue]] from the in-between parsed Expression (via [[file:noir/compiler/noirc_frontend/src/ast/statement.rs::pub fn from_expression(expr: Expression) -> Option<LValue> {][LValue::from_expression()]]), create an [[#h:ACCBF119-4052-4C4E-87CE-F7B233FF4AA1][Expression Infix]] where the left-hand side is the in-between expression, and the right-hand side is just-now another parsed Expression. This Infix expression is wrapped, and finally a ~StatementKind::Assign(AssignStatement)~ is returned. If the reification failed a parse-error is pushed since the left-side of this attempted assignment must be invalid.


If none of the blocks' guards are triggered an [[file:PROJECT.org::#h:9255C4E4-03B0-4A3B-B3AE-454FF2A53D57][expression statement]] (~StatementKind::Expression~) of the in-between parsed Expression is returned.

*** UPGR Arguments
:PROPERTIES:
:CUSTOM_ID: h:FB4BC935-116B-4C56-B866-3842C5CA9B5F
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-06-26 Thu 16:15]
- State "TODO"       from              [2025-06-26 Thu 15:54]
:END:

#+name: arguments
#+begin_src js :arg $ :ast Arguments
seq(
    '(',
    optional(seq(
        // Inlined Noirc: ArgumentsList.
        sepBy1(<<r("expression")>>, ','),
        optional(','),
    )),
    ')',
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/arguments.rs::fn parse_arguments(&mut self)][parse_arguments()]]

#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/arguments.rs::11][Arguments ArgumentsList doc]]  :lines 11-13 :src fundamental

*************** TODO EBNF feels unclear here, upstream patch?
assert expects 1 or 2 params, assert_eq expects 2 or 3 so how is it the case that arguments list could only ever be up to 2 elements given how ArgumentsList is specified.

Have pretended it is =*= in our implementation.
*************** END

**** ArgumentsList
:PROPERTIES:
:CUSTOM_ID: h:10AA2FCE-2B45-442A-8349-1161B113A661
:END:

**Inlined unless something else references it in a way that requires otherwise**.

Via [[#h:8E0DC05B-1ED6-47BE-9589-64DC06FAECCA][parse_many]] in parent, split by =,= until =)=, each parsed as [[#h:167542CC-8CDE-49C1-9465-E5157C6A176F][Expression]].

*** TODO CallArguments
:PROPERTIES:
:CUSTOM_ID: h:C98290E5-F5C5-4D52-BECC-974E4CDA07DC
:END:
:LOGBOOK:
- State "TODO"       from              [2025-06-26 Thu 15:54]
:END:

#+name: call_arguments
#+begin_src js :rule __call_arguments :arg $ :ast CallArguments
seq(
    optional('!'),
    <<r("arguments")>>,
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/arguments.rs::fn parse_call_arguments(&mut self)][parse_call_arguments()]]

#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/arguments.rs::28][CallArguments doc]] :lines 28-28 :src fundamental

Looks to specify a macro call if =!(= is the sequence of initial tokens.

*************** TODO CST node for =!= being a macro call
*************** END

*** OptionalTypeAnnotation
:PROPERTIES:
:CUSTOM_ID: h:4644D901-3F04-456E-89D1-14351FD138E8
:END:

#+name: type_annotation
#+begin_src js :rule _type_annotation :arg $ :ast OptionalTypeAnnotation
seq(':', <<r("type")>>)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::fn parse_optional_type_annotation(&mut self)][parse_optional_type_annotation()]]

#+name: field__type_annotation
#+caption: Convenience tangle-time template for common OptionalTypeAnnotation pattern.
#+begin_src js :noweb yes
field('type', optional(<<r("type_annotation")>>)), // Inlined Noirc: OptionalTypeAnnotation.
#+end_src

#+name: ,ebnf_optional_type_annotation
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/types.rs::409][OptionalTypeAnnotation doc]] :lines 409-409 :src fundamental

*** UPGR Atom
:PROPERTIES:
:CUSTOM_ID: h:14C02FBD-84BA-470B-92C3-8E9C55BCF375
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-07-20 Sun 00:54]
- State "TODO"       from              [2025-07-19 Sat 01:05] \\
  Under Term which is under Expression
:END:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::fn parse_atom(&mut self, allow_constructors: bool)][parse_atom()]], [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::fn parse_atom_kind(&mut self, allow_constructors: bool)][parse_atom_kind()]]

Grammar rule inlined at [[#h:167542CC-8CDE-49C1-9465-E5157C6A176F][Expression]].

**** UPGR ParenthesesExpression
:PROPERTIES:
:CUSTOM_ID: h:DF57FFD8-C50B-406E-95E7-94C3BFC15DAC
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-07-19 Sat 03:49]
- State "TODO"       from              [2025-07-19 Sat 01:25]
:END:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::fn parse_parentheses_expression(&mut self)][parse_parentheses_expression()]]
Callsites:
  - [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::if let Some(kind) = self.parse_parentheses_expression() {][in parse_atom_kind()]] (for: [[#h:14C02FBD-84BA-470B-92C3-8E9C55BCF375][Atom]])

Grammar rule inlined at [[#h:167542CC-8CDE-49C1-9465-E5157C6A176F][Expression]].

Both [[id:D6E2F320-99C6-49BE-972A-FCE3FD65EC38][ParenthesizedExpression]] and [[#h:C5D99479-D00F-4719-852B-947B388EDD59][TupleExpression]] are parsed inline here via [[#h:8E0DC05B-1ED6-47BE-9589-64DC06FAECCA][parse_many]] split on =,= call ~parse_expression_in_list~ call ~parse_expression~ which is [[#h:167542CC-8CDE-49C1-9465-E5157C6A176F][Expression]].

If only 1 Expression was parsed and there's no trailing comma ~ExpressionKind::Parenthesized~ returned, otherwise ~ExpressionKind::Tuple~.

#+name: ,ebnf_parentheses_expression
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::680][ParenthesesExpression doc]]  :lines 680-683 :src fundamental

**** UPGR ParenthesizedExpression
:PROPERTIES:
:ID:       D6E2F320-99C6-49BE-972A-FCE3FD65EC38
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-07-19 Sat 03:49]
- State "TODO"       from              [2025-07-19 Sat 03:02]
:END:

#+name: parenthesised_expression
#+begin_src js :rule parenthesized_expression :arg $ :ast ParenthesizedExpression
seq('(', <<r("expression")>>, ')')
#+end_src

Parser: /in parent, see [[#h:DF57FFD8-C50B-406E-95E7-94C3BFC15DAC][ParenthesesExpression]]/

Similar to [[#h:CEEC13D7-39B2-434F-90D5-302AB44E2BBA][ParenthesizedTypeExpression]]. EBNF pattern only appears here and UnquoteExpression (TODO LINK).

#+name: ,ebnf_parenthesized_expression
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::687][ParenthesizedExpression doc]]  :lines 687-687 :src fundamental

#+begin_example
just fd "'(' Expression ')'" -C 2
#+end_example

**** UPGR TupleExpression
:PROPERTIES:
:CUSTOM_ID: h:C5D99479-D00F-4719-852B-947B388EDD59
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-07-19 Sat 03:49]
- State "TODO"       from              [2025-07-19 Sat 03:21]
:END:

#+name: tuple_expression
#+begin_src js :arg $ :ast TupleExpression
seq(
    '(',
    // Required trailing colon to match.
    seq(<<r("expression")>>, ','),
    // Additional either includes trailing colon or doesn't.
    repeat(seq(<<r("expression")>>, ',')),
    optional(<<r("expression")>>),
    ')',
)
#+end_src

Parser: /in parent, see [[#h:DF57FFD8-C50B-406E-95E7-94C3BFC15DAC][ParenthesesExpression]]/

#+name: ,ebnf_tuple_expression
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::689][TupleExpression doc]]  :lines 689-689 :src fundamental

**** UPGR UnsafeExpression                                         :alias:
:PROPERTIES:
:CUSTOM_ID: h:AE41A3D6-2311-40DB-998F-1E15B5A0C07D
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-07-19 Sat 04:01]
- State "TODO"       from              [2025-07-19 Sat 03:55]
:END:

Grammar rule defined in [[#h:B34CADE5-71B4-41F2-AB54-00483EE593A6][BlockExpression]] for clarity.

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::fn parse_unsafe_expr(&mut self)][parse_unsafe_expr()]]
Callsites:
  - [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::if let Some(kind) = self.parse_unsafe_expr() {][in parse_atom_kind()]] (for: [[#h:14C02FBD-84BA-470B-92C3-8E9C55BCF375][Atom]])

#+name: ,ebnf_unsafe_expression
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::372][UnsafeExpression doc]]  :lines 372-372 :src fundamental

**** UPGR PathExpression
:PROPERTIES:
:CUSTOM_ID: h:3884C486-9CDF-4A3A-B486-8F7BE0A21494
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-07-19 Sat 17:30]
- State "TODO"       from              [2025-07-19 Sat 04:03]
:END:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::fn parse_path_expr(&mut self, allow_constructors: bool)][parse_path_expr()]]
Callsites:
  - [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::if let Some(kind) = self.parse_path_expr(allow_constructors) {][in parse_atom_kind()]] (for: [[#h:14C02FBD-84BA-470B-92C3-8E9C55BCF375][Atom]])

Grammar rule inlined at [[#h:167542CC-8CDE-49C1-9465-E5157C6A176F][Expression]].

The [[#h:07167116-EAE4-475B-8C87-DE9075BAF88D][Path]] component of both [[#h:01A477BE-69D1-48DD-BCFE-4571CC5F3F73][VariableExpression]] and [[#h:33877732-BC96-4CE2-99F3-EDB01CB46420][ConstructorExpression]] are parsed inline here. If parameter ~allow_constructors~ is =true= and there's ={= then [[#h:33877732-BC96-4CE2-99F3-EDB01CB46420][ConstructorExpression]] is parsed.

#+name: ,ebnf_path_expression
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::386][PathExpression doc]]  :lines 386-388 :src fundamental

***** VariableExpression                                              :alias:
:PROPERTIES:
:CUSTOM_ID: h:01A477BE-69D1-48DD-BCFE-4571CC5F3F73
:END:

Alias for [[#h:07167116-EAE4-475B-8C87-DE9075BAF88D][Path]] except it is represented as an [[file:noir/compiler/noirc_frontend/src/ast/expression.rs::pub enum ExpressionKind {][ExpressionKind enum]] ~ExpressionKind::Variable~.

#+name: ,ebnf_variable_expression
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::390][VariableExpression doc]]  :lines 390-390 :src fundamental

***** UPGR ConstructorExpression
:PROPERTIES:
:CUSTOM_ID: h:33877732-BC96-4CE2-99F3-EDB01CB46420
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "SPEC"       [2025-07-19 Sat 17:30]
- State "SPEC"       from "TODO"       [2025-07-19 Sat 16:37] \\
  Parser examined.
- State "TODO"       from              [2025-07-19 Sat 16:37]
:END:

#+name: constructor_expression
#+begin_src js :rule struct_expression :arg $ :ast ConstructorExpression
seq(
    // TODO: is it really any Type? So like a parentheses type etc. For now just identifier or path no turbofish.
    field('name', <<r("identifier_or_path_no_turbofish")>>),
    field('body', alias(<<r("constructor_body")>>, $.initializer_list)),
)
#+end_src

#+name: constructor_body
#+begin_src js :arg $ :ast ConstructorFields
seq(
    '{',
    optional(seq(
        sepBy1(alias(<<r("constructor_field")>>, $.field_initializer), ','),
        optional(','),
    )),
    '}',
)
#+end_src

#+name: constructor_field
#+begin_src js :arg $ :ast ConstructorField
choice(
    <<r("identifier")>>,
    seq(
        field('field', <<r("identifier")>>),
        ':',
        field('value', <<r("expression")>>),
    ),
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::fn parse_constructor(&mut self, typ: UnresolvedType)][parse_constructor()]]
Types: [[file:noir/compiler/noirc_frontend/src/ast/expression.rs::pub struct ConstructorExpression {][ConstructorExpression struct]], ~ExpressionKind::Constructor~.

Looks to be akin to Rust struct expressions: https://doc.rust-lang.org/reference/expressions/struct-expr.html

#+name: ,ebnf_constructor_expression
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::404][ConstructorExpression, ConstructorFields, ConstructorField doc]]  :lines 404-408 :src fundamental

*************** TODO In parser UnresolvedType::from_path
Does this mean OrderedGenerics are allowed in the Path? Investigate later.
*************** END
*************** TODO In parser callsite this thing about interned unresolved type data
Does that represent anything we should realistically grab via tree-sitter? If so adjust as required. For current Noir 0.36.0 (I think) its in parser/expression.rs line 287 ([[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::if matches!(self.token.token(), Token::InternedUnresolvedTypeData(..))][link]])
*************** END

****** ConstructorFields
:PROPERTIES:
:CUSTOM_ID: h:E6CE7011-D6FC-4662-899D-DF8A5B1D42A0
:END:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::let fields = self.parse_many(][parse_constructor() parent inline]]

Via [[#h:8E0DC05B-1ED6-47BE-9589-64DC06FAECCA][parse_many]] split at =,= until =}= each calls [[#h:6EE8711B-E124-4A46-B468-1C2F493C160A][ConstructorField]].

****** UPGR ConstructorField
:PROPERTIES:
:CUSTOM_ID: h:6EE8711B-E124-4A46-B468-1C2F493C160A
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "SPEC"       [2025-07-19 Sat 17:30]
- State "SPEC"       from "TODO"       [2025-07-19 Sat 16:37] \\
  Parser examined.
- State "TODO"       from              [2025-07-19 Sat 16:37]
:END:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::fn parse_constructor_field(&mut self)][parse_constructor_field()]]

Parser technically allows === instead of =:= but it does raise a parse error so we'll ignore that in the tree-sitter grammar and only allow =:=.

**** UPGR Lambda
:PROPERTIES:
:CUSTOM_ID: h:5F28CD6F-4D91-40CD-81F1-D3BD63E77839
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-07-19 Sat 20:26]
- State "TODO"       from              [2025-07-19 Sat 17:40]
:END:

#+name: lambda
#+begin_src js :arg $ :ast Lambda
seq(
    field('parameters', <<r("lambda_parameters")>>),
    field('return_type', optional(<<r("lambda_return_type")>>)),
    field('body', <<r("expression")>>),
)
#+end_src

#+name: lambda_return_type
#+begin_src js :arg $
seq(
    '->',
    field('type', <<r("type")>>),
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/lambda.rs::fn parse_lambda(&mut self)][parse_lambda()]]
Types: [[file:noir/compiler/noirc_frontend/src/ast/expression.rs::pub struct Lambda {][Lambda struct]]
Callsites:
  - [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::if let Some(kind) = self.parse_lambda() {][in parse_atom_kind()]] (for: [[#h:14C02FBD-84BA-470B-92C3-8E9C55BCF375][Atom]])

#+name: ,ebnf_lambda
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/lambda.rs::10][Lambda doc]]  :lines 10-10 :src fundamental

***** UPGR LambdaParameters
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from              [2025-07-19 Sat 20:26]
:END:

#+name: lambda_parameters
#+begin_src js :arg $ :ast LambdaParameters
seq(
    '|',
    optional(seq(
        sepBy1(choice(
            <<r("pattern")>>,
            alias(<<r("lambda_parameter")>>, $.parameter),
        ), ','),
        optional(','),
    )),
    '|',
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/lambda.rs::fn parse_lambda_parameters(&mut self)][parse_lambda_parameters()]]

Via [[#h:8E0DC05B-1ED6-47BE-9589-64DC06FAECCA][parse_many]] split at =,= until =|= call [[#h:947E0384-AC3E-4F56-9413-AD806BCCBBD7][LambdaParameter]].

***** UPGR LambdaParameter
:PROPERTIES:
:CUSTOM_ID: h:947E0384-AC3E-4F56-9413-AD806BCCBBD7
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from              [2025-07-19 Sat 20:26]
:END:

#+name: lambda_parameter
#+begin_src js :arg $ :ast LambdaParameter
seq(
    field('pattern', <<r("pattern")>>),
    field('type', <<r("type_annotation")>>), // Inlined Noirc: OptionalTypeAnnotation (except required).
)
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/lambda.rs::fn parse_lambda_parameter(&mut self)][parse_lambda_parameter()]]

**** UPGR ComptimeExpression                                       :alias:
:PROPERTIES:
:CUSTOM_ID: h:6424BB7B-2E77-4E26-84EC-D574E74F0520
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-07-19 Sat 23:17]
- State "TODO"       from              [2025-07-19 Sat 20:30]
:END:

Alias of [[#h:5092AC79-344E-465F-973E-70DC2ECF38FB][ComptimeBlock]], also see [[#h:B34CADE5-71B4-41F2-AB54-00483EE593A6][BlockExpression]].

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::fn parse_comptime_expr(&mut self)][parse_comptime_expr()]]
Callsites:
  - [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::if let Some(kind) = self.parse_comptime_expr() {][in parse_atom_kind()]] (for: [[#h:14C02FBD-84BA-470B-92C3-8E9C55BCF375][Atom]])

#+name: ,ebnf_comptime_expression
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::481][ComptimeExpression]]  :lines 481-481 :src fundamental

**** UPGR UnquoteExpression
:PROPERTIES:
:CUSTOM_ID: h:99953D79-E89B-49B8-B23D-E3CE1F8B4B0D
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-07-19 Sat 23:47]
- State "TODO"       from              [2025-07-19 Sat 23:31]
:END:

#+name: unquote_expression
#+begin_src js :arg $ :ast UnquoteExpression
seq(
    $.quote_expr_unquote,
    choice(
        <<r("identifier_or_path")>>,
        seq('(', <<r("expression")>>, ')'),
    ),
)
#+end_src

#+name: unquote_expression__OLD
#+begin_src js :arg $ :ast UnquoteExpression
prec.left(100, seq(
    '$',
    choice(
        prec.left(1000, <<r("identifier_or_path")>>),
        seq('(', prec.right(1000, <<r("expression")>>), ')'),
    ),
))
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::fn parse_unquote_expr(&mut self)][parse_unquote_expr()]]
Callsites:
  - [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::if let Some(kind) = self.parse_unquote_expr() {][in parse_atom_kind()]] (for: [[#h:14C02FBD-84BA-470B-92C3-8E9C55BCF375][Atom]])

*************** TODO EBNF update, identifier should be Path
*************** END

**** UPGR TypePathExpression                                       :alias:
:PROPERTIES:
:CUSTOM_ID: h:B4802C06-9963-41FB-B929-95C82597FE3A
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-07-20 Sun 00:14]
- State "TODO"       from              [2025-07-19 Sat 23:31]
:END:

No distinction made on primitive types in the Path, so this is already implemented at [[#h:07167116-EAE4-475B-8C87-DE9075BAF88D][Path]].

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::fn parse_type_path_expr(&mut self)][parse_type_path_expr()]]
Types: [[file:noir/compiler/noirc_frontend/src/ast/statement.rs::pub struct TypePath {][TypePath struct]]
Callsites:
  - [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::if let Some(kind) = self.parse_type_path_expr() {][in parse_atom_kind()]] (for: [[#h:14C02FBD-84BA-470B-92C3-8E9C55BCF375][Atom]])

#+name: ,ebnf_type_path_expression
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::534][TypePathExpression doc]]  :lines 534-534 :src fundamental
    
**** UPGR AsTraitPath
:PROPERTIES:
:CUSTOM_ID: h:274AC665-0EC2-4B68-9F24-CF867F19FCAC
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-07-20 Sun 00:51]
- State "TODO"       from              [2025-07-19 Sat 23:31]
:END:

#+name: trait_path_alias
#+begin_src js :arg $ :ast AsTraitPath
seq(
    '<',
    field('type', <<r("type")>>),
    'as',
    field('alias', <<r("trait_bound")>>),
    '>',
    '::',
    field('name', <<r("identifier")>>),
)
#+end_src

Looks to be based on Rust's: https://doc.rust-lang.org/reference/paths.html#r-paths.qualified

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/path.rs::fn parse_as_trait_path(&mut self)][parse_as_trait_path()]]
Callsites:
  - [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::if let Some(as_trait_path) = self.parse_as_trait_path() {][in parse_atom_kind()]] (for: [[#h:14C02FBD-84BA-470B-92C3-8E9C55BCF375][Atom]])

[[#h:161848E1-1F70-4DEF-9353-4C6BAF517C82][TraitBound]] has the same structure as the ~PathNoTurbofish GenericTypeArgs~ part of this AST's rule.

#+name: ,ebnf_as_trait_path
#+transclude: [[file:noir/compiler/noirc_frontend/src/parser/parser/path.rs::195][AsTraitPath doc]] :lines 195-195 :src fundamental
    
**** BLOCK ResolvedExpression
:LOGBOOK:
- State "BLOCK"      from "TODO"       [2025-07-20 Sun 00:52] \\
  Quoted stuff, stretch goal
- State "TODO"       from              [2025-07-19 Sat 23:31]
:END:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::fn parse_resolved_expr(&mut self)][parse_resolved_expr()]]
Callsites:
  - [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::if let Some(kind) = self.parse_resolved_expr() {][in parse_atom_kind()]] (for: [[#h:14C02FBD-84BA-470B-92C3-8E9C55BCF375][Atom]])
    
**** BLOCK InternedExpression
:LOGBOOK:
- State "BLOCK"      from "TODO"       [2025-07-20 Sun 00:53] \\
  Interned stuff, stretch goal
- State "TODO"       from              [2025-07-19 Sat 23:31]
:END:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::fn parse_interned_expr(&mut self)][parse_interned_expr()]]
Callsites:
  - [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::if let Some(kind) = self.parse_interned_expr() {][in parse_atom_kind()]] (for: [[#h:14C02FBD-84BA-470B-92C3-8E9C55BCF375][Atom]])
    
**** BLOCK InternedStatementExpression
:LOGBOOK:
- State "BLOCK"      from "TODO"       [2025-07-20 Sun 00:53] \\
  Interned stuff, stretch goal
- State "TODO"       from              [2025-07-19 Sat 23:31]
:END:

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::fn parse_interned_statement_expr(&mut self)][parse_interned_statement_expr()]]
Callsites:
  - [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::if let Some(kind) = self.parse_interned_statement_expr() {][in parse_atom_kind()]] (for: [[#h:14C02FBD-84BA-470B-92C3-8E9C55BCF375][Atom]])
    
*** TODO Literals
:PROPERTIES:
:CUSTOM_ID: h:3446FD3E-4526-4DBF-80AB-64BD9078C4F5
:END:

Constructed by the lexer.

*************** TODO Make this tree (from Literals) about literals and tokens, generally things the lexer sets TokenKind on
*************** END

**** Token Lexing

Function [[file:noir/compiler/noirc_frontend/src/lexer/lexer.rs::fn next_token(&mut self)][Lexer.next_token()]] is the major fork where ~Token~\s are created. After a series of whitespace is ignored attempts to lex [[#h:47747650-8CB5-48B1-A085-AFAF3C469B8B][Glue]], and single-character tokens are made followed by more complex tokens.

(TODO all these properly as appropriate):
eat_string_literal for string literal escape sequences (e.g. \n).
eat_format_string_or_alpha_numeric format strings or..?
eat_raw_string_or_alpha_numeric raw strings 'r' and '#' or something..?
eat_quote_or_alpha_numeric quote strings starting with 'q'
eat_attribute

- =#= for [[#h:22DB13A6-D91E-4240-8711-10ED6DEE1C6E][attribute]] ([[file:noir/compiler/noirc_frontend/src/lexer/lexer.rs::fn eat_attribute(&mut self)][eat_attribute()]])

eat_alpha_numeric called when character is_ascii_alphanumeric (rust stdlib function) or '_' then ~A-Za-z_~ calls to eat_word

eat_word calls lex_word and then lookup_word_token

lex_word keeps eating while rust stdlib is_ascii_alphabetic (A-Za-z) or rust is_numeric (0-9) or _

Lookup word token checks if the word is a keyword  via ~Keyword::lookup_keyword~ (TODO: Nice list of keywords). Checks if its an int type ~IntType::lookup_int_type~. If both of those fail its then an identifier ~Token::Ident~.

We don't need to give tree-sitter a literal list of keywords since we can rely on automatic keyword extraction (TODO: doc this here, the ts keyword extraction and how we set it in the grammar file). So, our identifier syntax is ~A-Za-z0-9_~ of which those not consumed as ~Token::IntType~.

Looking at lookup_int_type this means literal numbers prefixed with u or i will be int types. We probably don't need a regex to exclude these since we can rely on precedence. Via the lexer logic we clearly see that attempting to parse an int type is higher precedence (checks and returns first, last resort is identifier).


*************** TODO How is that for result in lexer thing even populated (top of Lexer struct)
Once that's clear all the call syntax etc up to Lexer.next_token can be documented. Perhaps just ask in Rust IRC.
*************** END

**** Glue
:PROPERTIES:
:CUSTOM_ID: h:47747650-8CB5-48B1-A085-AFAF3C469B8B
:END:

Lexer (master): [[file:noir/compiler/noirc_frontend/src/lexer/lexer.rs::fn glue(&mut self, prev_token: Token)][glue()]]

Some tokens can contain more than 1 character, e.g. =!== (not equal-to), such tokens are formed by being 'glued' together during lexing.

Starting glue tokens are: =<=, =>=, ===, =/=, =.=, =:=, =!=, =-=.
#+transclude: [[file:noir/compiler/noirc_frontend/src/lexer/lexer.rs::115][Lexer.next_token() glue matches]]  :lines 115-122 :src fundamental

Since ~next_token~ (TODO: link) has already incremented the cursor when the [[file:noir/compiler/noirc_frontend/src/lexer/lexer.rs::fn glue(&mut self, prev_token: Token)][glue()]] lexer is called (in next_tokens pattern match arm), glue is given the prior (initial) ~Token~ it is to start attempting to match from and begins subsequently.

*************** TODO Copy prior notes on glue from elsewhere to here
I've taken notes on this before, put glue stuff here as appropriate.
*************** END

**** UPGR comment                                                    :lex:
:PROPERTIES:
:CUSTOM_ID: h:E866B8E1-2736-4A62-938B-0FD416C4A088
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-06-05 Thu 16:39]
- State "TODO"       from              [2025-05-25 Sun 18:05] \\
  Need to document how this is lexed since parser grabs it by Token type only.
:END:

#+name: comment
#+begin_src js :arg $
choice(
    <<r("line_comment")>>,
    <<r("block_comment")>>,
)
#+end_src

Lexer (sop): [[file:noir/compiler/noirc_frontend/src/lexer/lexer.rs::222][glue() Token::Slash match arm]]

Look at next char, if:
- =/= switch to [[#h:155F78B1-495B-4F49-BFED-82369979A23E][line_comment]], else if
- =*= switch to [[#h:5B512D17-7FD5-4FD5-B4AA-C1B27A9E6FCA][block_comment]]

Both lexers for line/block comment are called with the start position on the character /after/ their (now completed) glue-token.

Comments can optionally have a [[file:noir/compiler/noirc_frontend/src/lexer/token.rs::pub enum DocStyle {][DocStyle enum]], ~Outer~ or ~Inner~.

~Outer~ means the comment applies to the subsequent AST node after it (i.e. immediately preceding the element it is outside of).
~Inner~ means the comment applies to its parent AST node (i.e. the element it is within).

**Implemented in =extras= as comments can appear anywhere in code.**

*************** TODO Outer comments are... and Inner comments are...?
*************** END

***** UPGR line_comment
:PROPERTIES:
:CUSTOM_ID: h:155F78B1-495B-4F49-BFED-82369979A23E
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-05-27 Tue 19:08]
- State "TODO"       from              [2025-05-25 Sun 19:00]
:END:
:pgd:
+ =//=
+ (opt grp):
  - =!= (marks ~DocStyle::Inner~)
  - =/= (marks ~DocStyle::Outer~)
+ ASCII until newline
:end:

#+name: line_comment__doc_style__inner
#+begin_src js :rule __inner_line_comment_doc_style
token.immediate(prec(2, '!'))
#+end_src

#+name: line_comment__doc_style__outer
#+begin_src js :rule __outer_line_comment_doc_style
token.immediate(prec(2, '/'))
#+end_src

#+name: line_comment__doc_style
#+begin_src js :rule __line_comment_doc_style :arg $
choice(
    alias(<<r("line_comment__doc_style__inner")>>, $.inner_doc_style),
    alias(<<r("line_comment__doc_style__outer")>>, $.outer_doc_style),
)
#+end_src

#+name: line_comment
#+begin_src js :arg $
seq(
    '//',
    choice(
        // Four forward-slashes is still a normal line comment, not an outer-style.
        seq(token.immediate(prec(2, '//')), /.*/),
        seq(
            field('style', <<r("line_comment__doc_style")>>),
            field('content', alias(/.*/, $.doc_comment)),
        ),
        /.*/,
    ),
)
#+end_src

Lexer: [[file:noir/compiler/noirc_frontend/src/lexer/lexer.rs::fn parse_comment(&mut self, start: u32)][parse_comment()]]

Continue eating asii characters (via Rust stdlib ~is_ascii~) until newline is encountered.

It looks like quadruple forward-slash =////= will disqualify a comment from having ~DocStyle::Outer~, it must be exactly triple. [[file:noir/compiler/noirc_frontend/src/lexer/lexer.rs::Some('/') if self.peek2_char() != '/'.into() => {][See this line of the lexer]].

So =////= has no DocStyle.

*************** TODO It looks like comments are lexed (and then parsed) WITHOUT the comment prefixes
So a comment like // Foo is parsed as "Foo" (but we know its a comment), the leading characters are dropped. Shall we do this too for ts? Likely we have a comment node and then a "value" or "contents" field on it which is everything after the leading token type
*************** END

***** UPGR block_comment
:PROPERTIES:
:CUSTOM_ID: h:5B512D17-7FD5-4FD5-B4AA-C1B27A9E6FCA
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-06-04 Wed 19:29]
- State "TODO"       from              [2025-05-25 Sun 19:03]
:END:
:pgd:
+ =/*=
+ (opt grp):
  - =!= (marks ~DocStyle::Inner~)
  - =*= (marks ~DocStyle::Outer~)
+ ASCII until balanced =*/=
:end:

#+name: block_comment__doc_style
#+begin_src js :rule __block_comment_doc_style :arg $
choice(
    alias($.__inner_block_comment_doc_style, $.inner_doc_style),
    alias($.__outer_block_comment_doc_style, $.outer_doc_style),
)
#+end_src

#+name: block_comment
#+begin_src js :arg $
seq(
    '/*',
    optional(
        choice(
            // Block comments with doc style (see external parser).
            seq(
                field('style', <<r("block_comment__doc_style")>>),
                optional(field('content', alias($._block_comment_content, $.doc_comment))),
            ),
            // Normal block comments (see external parser).
            $._block_comment_content,
        ),
    ),
    '*/',
)
#+end_src

Lexer: [[file:noir/compiler/noirc_frontend/src/lexer/lexer.rs::fn parse_block_comment(&mut self, start: u32)][parse_block_comment()]]

Continue eating ascii characters (via Rust stdlib ~is_ascii~) until =*/= encountered such that all opening =/*= and closing =*/= pairs are balanced.

It looks like an empty ~DocStyle::Outer~ block comment is not possible, so =/***/=. It must at least have some content =/** foo */=. [[file:noir/compiler/noirc_frontend/src/lexer/lexer.rs::Some('*') if !matches!(self.peek2_char(), Some('*' | '/')) => {][See this line of the lexer]].

So =/***/= has no DocStyle.

*************** TODO It looks like outer doc comments must be exactly two asterisks like how outer line comments but be exactly three slashes, right?
Confirm this later, also feeling a bit tired right now so could just be missing due to fatigue. For now will assume this is true.
*************** END
*************** TODO Nested block comments are not multiple AST nodes but a single block comment then?
Looks like it but confirm later on
*************** END

**** ident                                                              :lex:
:PROPERTIES:
:CUSTOM_ID: h:65B0176B-B46F-4679-8535-C504870AC048
:END:

Appears only place ~Token::Ident~ is created is within [[file:noir/compiler/noirc_frontend/src/lexer/lexer.rs::fn lookup_word_token(][lookup_word_token()]].

~Token::Ident~.

Noir does not support Unicode Identifiers (UAX#31) so XID_Start/XID_Continue. Only ASCII.

#+name: identifier
#+begin_src js :ast identifier
/[a-zA-Z_][a-zA-Z0-9_]*/
#+end_src

[[#h:65B0176B-B46F-4679-8535-C504870AC048][ident]]

#+name: ,ebnf_identifier
#+begin_src fundamental
identifier = [a-zA-Z_][a-zA-Z0-9_]*
#+end_src

**** AttributeKeywords
:PROPERTIES:
:CUSTOM_ID: h:0845FBC0-576F-4E44-B2A8-B7D7B17FBC84
:END:

Also called FunctionAttribute (predefined):
#+name: primary_attributes
#+begin_src js
// Functions can only have one primary attribute.
const PRIMARY_ATTRIBUTES = [
    'foreign',
    'builtin',
    'oracle',
    'test',
    'recursive',
    'fold',
    'no_predicates',
    'inline_always',
    'test',
    'field',
]
#+end_src

Include CustomAttribute and InnerAttribute (predefined):
#+name: secondary_attributes
#+begin_src js
// Functions can have any number of secondary attributes.
const SECONDARY_ATTRIBUTES = [
    'deprecated',
    'contract_library_method',
    'abi',
    'export',
    'varargs',
    'use_callers_scope',
    'allow',
]
#+end_src

**** UPGR attribute                                                  :lex:
:PROPERTIES:
:CUSTOM_ID: h:22DB13A6-D91E-4240-8711-10ED6DEE1C6E
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from "TODO"       [2025-06-05 Thu 20:02]
- State "TODO"       from              [2025-06-05 Thu 17:37] \\
  Reviewing attribute lexing
:END:
:pgd:
+ =#=
+ (opt) =!= (marks ~Token::InnerAttribute~)
+ =[=
+ (opt) ='= (marks as a tag)
+ CHARS until first =]=
:end:

#+name: attribute
#+begin_src js :rule attribute_item :arg $ :ast Attributes, InnerAttribute
seq(
    '#',
    optional('!'), // Marks InnerAttribute.
    '[',
    optional("'"), // Marks attribute as having a tag
    // ASCII space, and printable characters except for opening and closing brackets.
    optional(alias(/[\x20-\x22\x23-\x5A,\x5C,\x5E-\x7E\s]+/, $.content)),
    ']',
)
#+end_src

Lexer: [[file:noir/compiler/noirc_frontend/src/lexer/lexer.rs::fn eat_attribute(&mut self)][eat_attribute()]], [[file:noir/compiler/noirc_frontend/src/lexer/token.rs::pub(crate) fn lookup_attribute(][Attribute::lookup_attribute()]]
Types: [[file:noir/compiler/noirc_frontend/src/lexer/token.rs::pub enum Attribute {][Attribute enum]] / [[file:noir/compiler/noirc_frontend/src/lexer/token.rs::pub enum FunctionAttribute {][FunctionAttribute enum]] / [[file:noir/compiler/noirc_frontend/src/lexer/token.rs::pub enum SecondaryAttribute {][SecondaryAttribute enum]] / [[file:noir/compiler/noirc_frontend/src/lexer/token.rs::pub struct CustomAttribute {][CustomAttribute struct]]

If next immediate char is =!= it's a ~Token::InnerAttribute~, else a (normal) ~Token::Attribute~.

The contents of the attribute are everything within the starting/ending =[= and =]=, excluding the tag mark (if present). In source this is ~word~, and ~span~ is everything from the starting =#= to closing =]= inclusive.

After an all the characters of an attribute have been eaten (but before a concrete ~Token~ is created) [[file:noir/compiler/noirc_frontend/src/lexer/token.rs::pub(crate) fn lookup_attribute(][Attribute::lookup_attribute()]] is called to check if this is a predefined attribute, or a custom one.

Parameter ~word~ split into segments at =(= and =)=, all empty segments dropped:
#+transclude: [[file:noir/compiler/noirc_frontend/src/lexer/token.rs::754][lookup_attribute() word split]] :lines 754-757 :src rust

Parameter ~span~ has all characters checked such that they are any of:
- ASCII alphabetic.
- Numeric :: *NOTE* that this does NOT mean ASCII numeric, see [[https://doc.rust-lang.org/std/primitive.char.html#method.is_numeric][rust docs]].
- ASCII punctuation; any of (see [[https://doc.rust-lang.org/std/primitive.char.html#method.is_ascii_punctuation][rust docs]]): ~! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~~.
- ASCII whitespace.

#+transclude: [[file:noir/compiler/noirc_frontend/src/lexer/token.rs::759][lookup_attribute() slice check]] :lines 759-771 :src rust

If attribute is a tag (via parameter ~is_tag~) an ~Attribute::Secondary~ (enumerant) is returned, itself containing a ~SecondaryAttribute~ (enum) with it's ~Tag~ set to a ~CustomAttribute~.
#+transclude: [[file:noir/compiler/noirc_frontend/src/lexer/token.rs::773][lookup_attribute() tag return]] :lines 773-779 :src rust

Otherwise each of the processed ~word~\s is checked to see if it's a predefined attribute and either a ~FunctionAttribute~ (enum) or ~SecondaryAttribute~ (enum) is returned as appropriate ([[file:noir/compiler/noirc_frontend/src/lexer/token.rs::781][lookup_attribute() top of predefined pattern-match]]).

Penultimately if =!= was present (marking a ~Token::InnerAttribute~) and the return from lookup_attribute was a ~FunctionAttribute~ a lex error is thrown. If it was a ~SecondaryAttribute~ that return value is wrapped into a ~Token::InnerAttribute~ and returned.

Otherwise a ~Token::Attribute~ wrapping the return value is returned.

So ~Token::InnerAttribute~ cannot have the name of any ~FunctionAttribute~ (aka. Primary) attribute. ~Token::Attribute~ /can/ have the name of any ~FunctionAttribute~ (aka. Primary) or ~SecondaryAttribute~.

*************** TODO // TODO: Differentiate between inner/non-inner in grammar, for now not doing so in order to focus on completing grammar entirely (broadly).
*************** END
*************** TODO Is the field attribute primary or secondary?
In source its listed as Attribute::Secondary but the comment for secondary attributes begins after it. For now I've taken it as the comment describes (thus considering it a primary attribute).
*************** END

**** SPEC bool                                                          :lex:
:PROPERTIES:
:CUSTOM_ID: h:54ACA91F-70A8-4121-A799-F872DDCAF240
:END:
:LOGBOOK:
- State "SPEC"       from              [2025-06-15 Sun 17:15]
:END:

Via [[file:noir/compiler/noirc_frontend/src/parser/parser.rs::fn eat_bool(&mut self)][eat_bool]] eats a token which was lexed as ~Token::Bool~ which are created from either =true= or =false= (see: [[file:noir/compiler/noirc_frontend/src/lexer/token.rs::pub(crate) fn lookup_keyword(word: &str)][lookup_keyword()]]).

#+name: bool
#+begin_src js :rule bool_literal :ast bool
choice('true', 'false')
#+end_src

#+name: ,ebnf_bool
#+begin_src fundamental
bool = 'true' | 'false'
#+end_src

*************** TODO Put lookup_keyword into Internal alongside parse_many and friends if it keeps being called in other places we document (like it is here).
*************** END

**** SPEC int                                                           :lex:
:PROPERTIES:
:CUSTOM_ID: h:CA7F6441-C376-4A8E-9C59-B128CC1F841A
:END:
:LOGBOOK:
- State "SPEC"       from "TODO"       [2025-05-26 Mon 12:30]
- State "TODO"       from              [2025-05-26 Mon 12:30]
:END:

#+name: int
#+begin_src js :rule int_literal :ast int
token(seq(
    choice(
        /[0-9][0-9_]*/,
        /0x[0-9a-fA-F_]+/,
    ),
    // Noirc: (TODO: get patch version this feature was added) integer suffix types.
    optional(choice(...INTEGER_TYPES)),
))
#+end_src

Parser: [[file:noir/compiler/noirc_frontend/src/parser/parser.rs::fn eat_int(&mut self)][eat_int()]]

If token was lexed ~Token::Int~, bump parser, get token contents and return tuple ~(FieldElement, Option<IntegerTypeSuffix>)~.

~IntegerTypeSuffix~


Lexer:

~Token::Int~

*************** TODO Put this TODO elsewhere, this describes a Token::Int
Note a Token::Int is not the same as a Token::IntType. Token::Int is a literal integer e.g. 42 whereas Token::IntType is say u32 or i8 etc.

eat_alpha_numeric -> eat_digit

eat_alpha_numeric if the initial char is 0..9 call eat_digit

eat_digit continues to eat while each character is ascii digit, or ascii hexdigit, or 'x' or '_'.

Underscore cannot appear at the end (invalid). Underscore at start is an identifier not a Token::Int. Cannot have multiple consecutive underscores.

Appears to be an error for:
        let integer_str = self.eat_while(Some(initial_char), |ch| {
            ch.is_ascii_digit() | ch.is_ascii_hexdigit() | (ch == 'x') | (ch == '_')
        });

This means we can have integers like 0xxxx123 be valid? Or 0x123x123x123 (note the multiple x).

Should also link stuff as appropriate. This is lexing documentation.
*************** END
*************** TODO Update reg for error on multiple consecutive _ and if a trailing _
As it is is fine for now however.
*************** END

***** TODO IntegerTypeSuffix                                        :lex:
:LOGBOOK:
- State "TODO"       from              [2026-02-19 Thu 21:23] \\
  v1.0.0-beta.19 Noir, new
:END:

Lexer: [[file:noir/compiler/noirc_frontend/src/lexer/lexer.rs::fn check_for_integer_type_suffix(integer_string: &mut String)][check_for_integer_type_suffix()]]
Types: [[file:noir/compiler/noirc_frontend/src/lexer/token.rs::pub enum IntegerTypeSuffix {][IntegerTypeSuffix enum]]

If an integer (used in a value position only) has a type suffix it is returned ~IntegerTypeSuffix~ and said suffix stripped from the integer string. Later the integer string can be parsed as an integer with this associated type information (see: [[#h:CA7F6441-C376-4A8E-9C59-B128CC1F841A][int]]).

**** UPGR str                                                        :lex:
:PROPERTIES:
:CUSTOM_ID: h:6135F05F-8F23-4B77-98E2-CF6D639F4D7A
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from              [2025-06-15 Sun 19:09]
:END:

#+name: str
#+begin_src js :rule str_literal :arg $ :ast str
seq(
    '"',
    repeat(choice(
        <<r("str_content")>>,
        <<r("escape_sequence")>>,
    )),
    token.immediate('"'),
)
#+end_src

#+name: escape_sequence
#+begin_src js
token.immediate(
    seq(
        '\\',
        // TODO: Do we want to be strict on valid escape sequences (r, n, t etc) or accept any ASCII. Problem is error recovery in tree-sitter and how that affects highlighting.
        choice('r', 'n', 't', '0', '"', '\\'),
    ),
)
#+end_src

Whitespace characters, and printable ASCII except " (x22) and \ (x5C).
#+name: str_content
#+begin_src js
/[\x20-\x21\x23-\x5B\x5D-\x7E\s]+/
#+end_src

Lexed via [[#h:2AE110C8-8650-4F3B-AAA0-FFE5E79C8C81][next_token]] pattern ="= calls [[file:noir/compiler/noirc_frontend/src/lexer/lexer.rs::fn eat_string_literal(&mut self)][eat_string_literal()]] which lexes and returns a ~Token::Str~.
Parsed via [[file:noir/compiler/noirc_frontend/src/parser/parser.rs::fn eat_str(&mut self)][eat_str]] which eats a token which was lexed as ~Token::Str~.

Lexer eats until ending ="= allowing the following escape characters within the string: =\r=, =\n=, =\t=, =\0=, =\"=, =\\=.

*************** TODO Keep as-is or use an external scanner?
Seems to be fine for now.
*************** END

**** UPGR raw_str                                                    :lex:
:PROPERTIES:
:CUSTOM_ID: h:0573AE7E-F170-4CC3-BE8C-852249558A04
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from              [2025-06-17 Tue 16:40]
:END:

#+name: raw_str
#+begin_src js :rule raw_str_literal :arg $ :ast rawstr
seq(
    $._raw_str_literal_start,
    alias($._raw_str_literal_content, $.str_content),
    $._raw_str_literal_end,
)
#+end_src

Lexed via [[#h:2AE110C8-8650-4F3B-AAA0-FFE5E79C8C81][next_token]] pattern =r= calls [[file:noir/compiler/noirc_frontend/src/lexer/lexer.rs::fn eat_raw_string_or_alpha_numeric(&mut self)][eat_raw_string_or_alpha_numeric()]] which peeks at the following 2 characters. If they are (order matters) of the following patterns: (=#=, =#=) OR (=#=, ="=) OR (="=, ANYTHING) then [[file:noir/compiler/noirc_frontend/src/lexer/lexer.rs::fn eat_raw_string(&mut self)][eat_raw_string()]] is called which finalises the lexing and returns a ~Token::RawStr~.

If none of those patterns are matched then [[file:noir/compiler/noirc_frontend/src/lexer/lexer.rs::fn eat_alpha_numeric(&mut self, initial_char: char)][eat_alpha_numeric()]] is called which will attempt to eat the span via ~eat_word~, which see.

~eat_raw_string~ eats all leading =#= and records the count. Technically over 255 leading =#= is an error. A ="= must immediately follow after the pounds. Loop doing: eat characters until ="= at which point all the =#= after the ="= are eaten and counted. If the count of these pounds equals the leading ones that terminates the raw string literal, otherwise the ="= and eaten =#= are also string contents and the loop continues.

Essentially this all means that a raw string literal is started via =r"= or =r#"= where there can be 0 to 255 =#=\s. The amount of =#=\s form the delimiter. The raw string literal only ends when an ="= or ="#= is encountered, in the latters case where the amount of =#=\s matches the starting delimiter exactly. No escape sequences are handled at all.

Parsed via [[file:noir/compiler/noirc_frontend/src/parser/parser.rs::fn eat_raw_str(&mut self)][eat_raw_str]] which eats a token which was lexed as ~Token::RawStr~.

**** UPGR fmt_str                                                    :lex:
:PROPERTIES:
:CUSTOM_ID: h:196B9814-8776-49F7-B43A-6084A8A3256A
:END:
:LOGBOOK:
- State "UPGR"       from "DONE"       [2026-02-18 Wed 21:39] \\
  Noir v1.0.0-beta.19
- State "DONE"       from              [2025-06-17 Tue 17:43]
:END:

#+name: fmt_str
#+begin_src js :rule fmt_str_literal :arg $ :ast fmtstr
seq(
    'f"',
    repeat(alias(<<r("fmt_str_content")>>, $.str_content)),
    token.immediate('"'),
)
#+end_src

Whitespace characters, and printable ASCII except " (x22).
#+name: fmt_str_content
#+begin_src js
/[\x20-\x21\x23-\x7E\s]+/
#+end_src

Lexed via [[#h:2AE110C8-8650-4F3B-AAA0-FFE5E79C8C81][next_token]] pattern =f= calls [[file:noir/compiler/noirc_frontend/src/lexer/lexer.rs::fn eat_format_string_or_alpha_numeric(&mut self)][eat_format_string_or_alpha_numeric()]] which peeks at the next character, only if it is ="= is [[file:noir/compiler/noirc_frontend/src/lexer/lexer.rs::fn eat_fmt_string(&mut self)][eat_fmt_string()]] called which simply eats all characters until first ="= encountered.

No escape sequences appear to be interpreted, so =\"= within the string contents will result in an error.

Parsed via [[file:noir/compiler/noirc_frontend/src/parser/parser.rs::fn eat_fmt_str(&mut self)][eat_fmt_str]] which eats a token which was lexed as ~Token::FmtStr~.

**** DONE quote                                                         :lex:
CLOSED: [2025-07-26 Sat 03:01]
:PROPERTIES:
:CUSTOM_ID: h:3F001F84-17D8-4B0D-912F-67AF98F72CD4
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2025-07-26 Sat 03:01]
- State "TODO"       from              [2025-06-17 Tue 18:10] \\
  For now will eat arbitrary characters, without nesting, until rest of grammar is completed.
:END:

// TODO: This isn't /really/ a literal (in terms of where we've placed it here) as quote allows all things next_token can lex and so we'll want to parse strings, variables etc all over again within the quote area. For now we'll make it a very dumb stubbed rule since this really depends on everything else and we'll want everything else working so we can develop and evaluate proper coverage of this meta-programming/macro rule.
// TODO: https://noir-lang.org/docs/noir/concepts/comptime#quasi-quote
// TODO: Will likely require an external scanner since we need to match the opening delimiter which can be 1 of 3 options, and there is nesting. For now: only braces.

#+name: quote
#+begin_src js :rule quote_expression :arg $
seq(
    'quote',
    '{',
    // field('tokens', alias($.quote_content, $.token_stream)),
    // XXX: Optionality here must be in-sync with external scanner.
    field('tokens', optional(seq(
        choice(
            <<r("unquote_expression")>>,
            alias($.quote_expr_content, $.token_stream),
        ),
    ))),
    '}',
),

// XXX: If more nested structure desired.
quote_content: $ => seq(
    choice(
        <<r("unquote_expression")>>,
        alias($.quote_expr_content, $.token_stream),
    ),
)
#+end_src

#+name: quote_OLD
#+begin_src js :rule quote_expression :arg $ :ast quote
{
    const t = [ ['{', '}'], ['[', ']'], ['(', ')'] ]

    // Single character regex with:
    //   - Space (as \s)
    //   - All printable ASCII characters, except...
    //   - ... $ (\x24)
    // const regex_token_stream = /[\x20-\x23\x25-\x7E\s]/
    const regex_token_stream = /[\x20-\x7E\s]/

    // TODO: This feels hacky but it apparently works, no external scanner required.
    return seq(
        'quote',
        choice(...t.map(([o, c, p]) => seq(
            o,
            alias(
                repeat(choice(
                    // Order here doesn't matter.
                    // o, c, regex_token_stream,
                    <<r("expression")>>,
                        <<r("if_expression")>>,
                    <<r("unquote_expression")>>,
                    // XXX: Need to specify all possible keywords which are no longer special within the scope of QuoteExpression.
                )),
                $.token_stream,
            ),
            c,
        )))
    )
}
#+end_src

Body of quote (see also: [[id:CF0A439A-EFBB-466E-8F5F-7A8827EB703E][QuoteExpression]]) consists of tokens but the body can be one of three patterns of matching delimiters.

Contents of quote can be any arbitrary tokens which makes it nasty to specify a grammar for. Might need a sub-grammar and to do injections for this instead since things like a function signature need not have a =;= after it (so we cannot just choice those rules in here).

#+name: quote_tokens__OLD
#+begin_src js :rule _quote_tokens :arg $
choice(
    <<r("expression")>>,
    <<r("function_signature")>>,
)
#+end_src

Lexed via [[#h:2AE110C8-8650-4F3B-AAA0-FFE5E79C8C81][next_token]] pattern =q= calls [[file:noir/compiler/noirc_frontend/src/lexer/lexer.rs::fn eat_quote_or_alpha_numeric(&mut self)][eat_quote_or_alpha_numeric()]] which eats =quote= (via [[#h:E76126FE-1E7A-40E9-A0C2-14F3FD3DB7E5][lex_word]]). Get the delimiter type via ~next_token~, where braces (={}=), brackets (=[]=), and parentheses (=()=) are valid delimiters. Then, while keeping track of potential delimiter nesting, consume tokens via ~next_token~.

Parsed via [[file:noir/compiler/noirc_frontend/src/parser/parser.rs::fn eat_quote(&mut self)][eat_quote]] which eats a token which was lexed as ~Token::Quote~.

*************** TODO Better version of this that actually (if possible nicely) gets a CST for those inner tokens
*************** END

** Internal

*** [[file:noir/compiler/noirc_frontend/src/parser/parser/parse_many.rs::9][Parser::parse_many(items, sep)]]                                :parser_fn:
:PROPERTIES:
:CUSTOM_ID: h:8E0DC05B-1ED6-47BE-9589-64DC06FAECCA
:END:

Parses list of items separated by sep, can optionally end when another (different configurable) separator is found.

- [ ] ~Parser::parse_many_return_trailing_separator_if_any()~.

TODO: Don't think I need to document parse_many_return blah blah, that's a compiler implementation detail (unless in future we have problems relating to it).

Accepts a single trailing separator (up to callsite if it allows trailing or not).

*** [[file:noir/compiler/noirc_frontend/src/parser/parser.rs::fn eat_kind(&mut self, kind: TokenKind)][Parser.eat_kind(kind)]]                                         :parser_fn:
:PROPERTIES:
:CUSTOM_ID: h:AC5A6E2C-59EC-44C6-9D1E-52553E56C3F9
:END:

Parameter =kind= (~TokenKind~) is compared to the parsers current token kind, and if they match ~Some(current_token)~ is returned and the parser is incremented one token forward (via bump).

Checking token kind goes down to [[file:noir/compiler/noirc_frontend/src/lexer/token.rs::355][SpannedToken.kind()]] to [[file:noir/compiler/noirc_frontend/src/lexer/token.rs::497][Token.kind()]] which is the following pattern match:

#+transclude: [[file:noir/compiler/noirc_frontend/src/lexer/token.rs::498][Token.kind() pattern match]]  :lines 498-522 :src rust

*** [[file:noir/compiler/noirc_frontend/src/parser/parser/path.rs::fn parse_path_impl(][Parser::parse_path_impl(allow_turbofish, allow_trailing_double_colon)]] :parser_fn:
:PROPERTIES:
:CUSTOM_ID: h:3DFE0B54-1BEB-41CE-B486-4CA40058C092
:END:

Further calls [[#h:96FCF9AD-3B89-451B-B84D-90A7A625B56D][PathKind]]'s parser (~parse_path_kind~) for =kind=, and ~parse_optional_path_after_kind~ ([[file:noir/compiler/noirc_frontend/src/parser/parser/path.rs::fn parse_optional_path_after_kind(][src]]) which is a simple wrapper for [[#h:7BA3BCB8-65F3-4001-8B02-2F904B014F87][parse_path_after_kind]] for =path=.

If the parsed =path= has no segments and it's =kind= is NOT ~PathKind::Plain~ a parse error is raised.

Whenever this function is called a parsed =path= only ever has it's =kind= parsed once.

*** [[file:noir/compiler/noirc_frontend/src/parser/parser/path.rs::pub(super) fn parse_path_after_kind(][Parser::parse_path_after_kind(kind, allow_turbofish, allow_trailing_double_colon)]] :parser_fn:
:PROPERTIES:
:CUSTOM_ID: h:7BA3BCB8-65F3-4001-8B02-2F904B014F87
:END:

Can be reached via [[file:noir/compiler/noirc_frontend/src/parser/parser/path.rs::pub(super) fn parse_path_impl(][Parser::parse_path_impl()]] and [[file:noir/compiler/noirc_frontend/src/parser/parser/path.rs::pub(super) fn parse_optional_path_after_kind(][Parser::parse_optional_path_after_kind()]] which are simple wrappers.

Parses the rest of a path after the [[#h:96FCF9AD-3B89-451B-B84D-90A7A625B56D][PathKind]] and always returns a path even if it's still just the PathKind and nothing else.

Loops [[#h:65B0176B-B46F-4679-8535-C504870AC048][ident]] tokens after the PathKind, if parameter ~allow_turbofish~ is true =::= and =<= are eaten and [[#h:F8EF693C-A6E2-4D57-BE08-103479D4270D][PathGenerics]] are parsed.

Each ident forms a [[file:noir/compiler/noirc_frontend/src/ast/statement.rs::pub struct PathSegment {][PathSegment struct]]. It is possible to eat no idents, returning an empty path.

*** [[file:noir/compiler/noirc_frontend/src/parser/parser/infix.rs::fn parse_infix<Next, Op>(][Parser.parse_infix(allow_constructors, next, op)]]              :parser_fn:
:PROPERTIES:
:CUSTOM_ID: h:CE180901-F6F2-4A65-878D-6C9154971376
:END:

Param ~next~ is a function name to be called, and param ~op~ is a lambda to be executed **after** ~next~ is executed, possibly multiple times.

Each time ~parse_infix~ is called it updates Parser's ~start_span~ to ~current_token_span~. Then ~next~ is executed, and a loop over ~op~ is created.

For all the expression AST nodes in the selfsame file ~parse_infix~ is in they pass a ~next~ which results in calling ~parse_infix~ again. This means for those AST nodes the operator precedence (for the language grammar) is the inverse of their call hierarchy. So ==== and =!== have the least precedence, and =*=, =/=, =%= the most.

*** [[file:noir/compiler/noirc_frontend/src/parser/parser/statement.rs::fn next_is_op_assign(&mut self)][Parser.next_is_op_assign()]]                                    :parser_fn:
:PROPERTIES:
:CUSTOM_ID: h:0AD7B3FC-EF8B-4DE5-85E9-19AFBC8CB257
:END:

Optionally parses sugared binary operations (also see: [[#h:ACCBF119-4052-4C4E-87CE-F7B233FF4AA1][Infix]]), so ~a <OP>= b~ becomes ~a = a <OP> b~.

Valid sugared combinations:

#+begin_example
+=
-=
*=
/=
%=
&=
^=
<<=
|=

>>=
#+end_example

*** [[file:noir/compiler/noirc_frontend/src/parser/parser.rs::fn comptime_mutable_and_unconstrained_not_applicable(&mut self, modifiers: Modifiers)][Parser.comptime_mutable_and_unconstrained_not_applicable(modifiers)]] :parser_fn:
:PROPERTIES:
:CUSTOM_ID: h:14698757-D7C8-4966-B84E-5DA1CAE3011E
:END:

Param ~modifiers~ is a previously parsed [[file:noir/compiler/noirc_frontend/src/parser/parser/modifiers.rs::struct Modifiers][Modifiers struct]], this function checks if any of the mutable, comptime, or unconstrained modifiers are set and if they are a parse error is raised.

This effectively means only the visibility modifier (which is ~ItemVisibility~) is valid where this function is called for ~modifiers~.

*** [[file:noir/compiler/noirc_frontend/src/ast/statement.rs::impl StatementKind {][StatementKind::add_semicolon(semi, span, last_statement_in_block)]] :parser_fn:
:PROPERTIES:
:CUSTOM_ID: h:3F52F622-294C-463F-986F-DD38EB41EA89
:END:

Asserts specific ~StatementKind~\s having semicolons. Called from [[file:noir/compiler/noirc_frontend/src/parser/parser/expression.rs::fn check_statements_require_semicolon(][check_statements_require_semicolon()]]. Some of the rules are simple, others more complex.

Those which /require/ semicolons will have the semicolon form part of their CST node, see [[#h:71AB7D76-FD24-4B91-A187-E9968024DC0C][BreakStatement]] for a simple example.

Those for which semicolons are /optional/ will have an empty statement captured as it's own CST node immediately following their associated rule (TODO: link simple example).

*************** TODO Decide on empty statement or not
So Block can optionally be followed by ;, do we want an EmptyStatement rule where this trailing ; becomes its own CST node or do we want that Block to then be captured (and so wrapped) in an ExpressionStatement?

I suppose clarity will come at the end of the grammar when we find out if Expressions can be used outside of places that expect Statements. Currently it doesn't look like that and so it should be wrapped in ExpressionStatement.
*************** END

**** Complex

~Comptime~ requiring a semicolon depends on it's inner ~StatementKind~. Recall that [[file:noir/compiler/noirc_frontend/src/ast/statement.rs::Comptime(Box<Statement>),][Comptime wraps another Statement]] when this other Statement is prefixed with =comptime= (see: [[#h:A0796B1B-462F-4DC6-BE7D-F1D87112AFD4][ComptimeStatement]]).

*************** TODO (parser error) explore where ; goes after wrapped statements which require it
Comptime wraps block, let, and for. Block ; is always optional. So do we put ; as part of the comptime statement if it follows or not?

This is also currently a parser error if a comptime block is followed by a ; because we haven't implemented / considered that yet.
*************** END

**** Simple

**Optional**:
  - ~For~ ([[#h:F444339D-00F1-4553-ACF6-DE0B5E2EE35E][ForStatement]])
  - ~Interned~ (TODO)
  - ~Expression~'s inner ~ExpressionKind~ optional semicolons:
    - ~Block~ ([[#h:B34CADE5-71B4-41F2-AB54-00483EE593A6][BlockExpression]])
    - ~Unsafe~ (TODO)
    - ~Interned~ (TODO)
    - ~InternedStatement~ (TODO)
    - ~If~ ([[#h:16951F18-730F-4A1F-84C9-3A1F78F67DF0][IfExpression]]) :: Presence of a semicolon turns wrapping ~StatementKind~ into ~StatementKind::Semi~ (i.e. an [[#h:12F5ADF9-E496-4D5B-896E-5CE97D44BE3D][ExpressionStatement]]), otherwise (if no semicolon) it remains ~StatementKind::Expression~.

**Required**:
  - ~Let~ ([[#h:FD70AFA1-5D45-434E-A9D0-7E8F6DD38058][LetStatement]])
  - ~Constrain~ ([[#h:25216601-CAF6-4246-8289-B106F9A9166B][ConstrainStatement]])
  - ~Assign~ ([[#h:D8D0BBE8-6152-479B-8C19-282B2B56C4A9][AssignStatement]])
  - ~Semi~ ([[#h:16951F18-730F-4A1F-84C9-3A1F78F67DF0][IfExpression]] TODO: Any others which can also be Semi?)
  - ~Break~ ([[#h:71AB7D76-FD24-4B91-A187-E9968024DC0C][BreakStatement]])
  - ~Continue~ ([[#h:6616DE79-93E3-42AA-9633-4A29251F5BA0][ContinueStatement]])
  - ~Error~ ([[#h:17935AE3-A964-49D1-927B-E67D035FD8D7][ReturnStatement]])
  
**** Rest

If none of Simple or Complex are triggered the final pattern match lines work as follows (snippet followed by explanation):

#+transclude: [[file:noir/compiler/noirc_frontend/src/ast/statement.rs::124][Pattern non-terminal Expression]]  :lines 124-127 :src fundamental

Any ~ExpressionKind~, which has =None= ~semi~ (i.e. no semicolon), and for which ~last_statement_in_block~ is =false= is a parser error. So this matches any Expression that is not the last in the block, and said Expressions require a semicolon.

#+transclude: [[file:noir/compiler/noirc_frontend/src/ast/statement.rs::128][Pattern ExpressionStatement]]  :lines 128-128 :src fundamental

Any ~ExpressionKind~, which has =Some= ~semi~ (i.e. a semicolon), at any position in the block is fine. It is considered a ~StatementKind::Semi~ (i.e. an [[#h:12F5ADF9-E496-4D5B-896E-5CE97D44BE3D][ExpressionStatement]]).

#+transclude: [[file:noir/compiler/noirc_frontend/src/ast/statement.rs::129][Pattern terminal Expression]]  :lines 129-129 :src fundamental

Any ~ExpressionKind~, which has =None= ~semi~ (i.e. no semicolon), and for which ~last_statement_in_block~ is =true= remains as an Expression.

In plain English these three cases are effectively:
  1. Non-terminal Expressions require a semicolon.
  2. An Expression followed by a semicolon is valid anywhere in a Block.
  3. An Expression which is the last statement in a Block is not required to have a semicolon.

*** [[file:noir/compiler/noirc_frontend/src/lexer/lexer.rs::fn next_token(&mut self)][Lexer.next_token()]]                                             :lexer_fn:
:PROPERTIES:
:CUSTOM_ID: h:2AE110C8-8650-4F3B-AAA0-FFE5E79C8C81
:END:

Major fork where ~Token~\s are created. After a series of whitespace is ignored: attempts to lex [[#h:47747650-8CB5-48B1-A085-AFAF3C469B8B][Glue]], and single-character tokens are made followed by more complex tokens.

*** [[file:noir/compiler/noirc_frontend/src/lexer/lexer.rs::fn lex_word(&mut self, initial_char: char)][Lexer.lex_word(initial_char)]]                                   :lexer_fn:
:PROPERTIES:
:CUSTOM_ID: h:E76126FE-1E7A-40E9-A0C2-14F3FD3DB7E5
:END:

From (and including) parameter =initial_char= eat characters which are ascii alphabetic (Rust stdlib), or numeric (Rust stdlib) or =_= and return the start/end positions of the eaten characters and said characters.

*** [[file:noir/compiler/noirc_frontend/src/ast/statement.rs::pub enum LValue {][LValue enum]]
:PROPERTIES:
:CUSTOM_ID: h:BF579445-9EE4-4F65-B928-8E22987DFDBD
:END:

An AST form which can be assigned to.

#+transclude: [[file:noir/compiler/noirc_frontend/src/ast/statement.rs::571][LValue enum]] :lines 571-577 :src fundamental

* Template

Constructed grammar from investigating Noir compiler frontend.

#+begin_src js :tangle grammar.js :noweb yes
const REG_ALPHABETIC = /[a-zA-Z]/
// TODO: Using this where Noir parser frontend checks for numeric which actually includes unicode stuff also, but the rest of Noir only allows ASCII so.. this is probably fine.
const REG_NUMERIC = /[0-9]/
const REG_ASCII_PUNCTUATION = /[!"#$%&'()*+,\-./:;<=>?@\[\\\]^_`\{|\}~]/

// TODO: Put this in appropriate tangle location instead of literally part of the tangle template maybe? See PrimitiveType > IntegerType.
const INTEGER_TYPES = [
    'u1',
    'u8',
    'u16',
    'u32',
    'u64',
    'u128',
    //
    'i1',
    'i8',
    'i16',
    'i32',
    'i64',
    'i128',
    //
    'Field',
]

const PRECEDENCE = {
    // Term and children.
    call: 20,
    access: 19,
    cast: 18,
    index: 17,
    // From EqualOrNotEqualExpression before it eventually calls to Term (latter thus /higher/ precedence).
    unary: 10,
    multiplicitive: 9,
    additive: 8,
    bitshift: 7,
    comparative: 6,
    bitxor: 5,
    bitand: 4,
    or: 3,
    equality: 2,
}

<<primary_attributes>>

<<secondary_attributes>>

export default grammar({
    name: 'noir',

    externals: ($) => [
        $.quote_expr_content, // Quoted content.
        $.quote_expr_unquote, // Unquote marker ($).
        //
        $._raw_str_literal_start,
        $._raw_str_literal_content,
        $._raw_str_literal_end,
        // Block comments are `extras` and can occur anywhere, so must be last in this list otherwise they will clobber other tokens we use an external scanner for.
        $._block_comment_content,
        $.__inner_block_comment_doc_style,
        $.__outer_block_comment_doc_style,
    ],

    extras: ($) => [
        /\s/,
        $.line_comment,
        $.block_comment,
    ],

    // Rule names tree-sitter will automatically inline at their callsites when generating the parser. Unlike anonymous CST nodes these will then NEVER result in a CST node.
    inline: ($) => [
        <<r("identifier_or_path")>>,
        <<r("identifier_or_path_no_turbofish")>>,
        <<r("tmp__let_to_type")>>,
    ],

    // TODO: Conflicts as-is work but is this the best way? It's mostly around Path.
    conflicts: ($) => [
        [<<r("type")>>, <<r("atom_type_expr")>>],
        [<<r("path")>>, <<r("path_no_turbofish")>>],
        // XXX: slice_expression is causing unresolved sequences error because the '&' of the slice sequence is also a character in binary expression. No attempt to set precedences worked and had to add conflict. This feels wrong.. try and fix without a conflict later?
        // [<<r("statement_kind")>>, <<r("literal")>>],
        // XXX: Temporary or required?
        [<<r("function_item_modifiers")>>, <<r("global_item_modifiers")>>],
        // XXX: Temporary or required? When adding generic_type to Type AST.
        [<<r("type")>>, <<r("generic_type")>>],
        // XXX: Had to add this when doing quote expression stuff, perhaps with an external scanner it won't be required but for now it is.
        // [r("quote")>>],
    ],

    // TODO: Need to document (for myself) keyword extraction to check we're doing it properly.
    word: ($) => $.identifier,

    rules: {
        // Noirc: Module -- top-level AST node is really Program but it immediately wraps Module.
        source_file: ($) => repeat($._module),

        // Can statement-ise anything so we'll use this as top-level.
        // _statement: ($) => choice($._expression_statement, $._declaration_statement),
        // _expression_statement: ($) => seq($._expression, ';'),
        _module: ($) => choice($._top_level_item),

        // Noirc: Module -- Since doc comments can appear anywhere, Module is Item which is ItemKind.
        _top_level_item: ($) => choice(
            <<r("attribute")>>,
            <<r("use")>>,
            <<r("mod_or_contract")>>,
            <<r("struct")>>,
            <<r("impl")>>,
            <<r("trait")>>,
            <<r("global")>>,
            <<r("type_alias")>>,
            <<r("function")>>,
        ),

        item_list: ($) => seq(
            '{',
            repeat($._top_level_item),
            '}',
        ),

        // * * * * * * * * * * * * * * * * * * * * * * * * * DECLARATIONS / DEFINITIONS / ITEMS
        <<grp__declarations>>

        // * * * * * * * * * * * * * * * * * * * * * * * * * STATEMENT KINDS (AST)
        // TODO: Consider all Noirc 'statements' except we enforce trailing semicolon where required? Or just have a statements section idk yet.
        <<grp__statements>>

        // * * * * * * * * * * * * * * * * * * * * * * * * * EXPRESSIONS
        <<grp__expressions>>

        // * * * * * * * * * * * * * * * * * * * * * * * * * TYPES
        <<grp__types>>

        // * * * * * * * * * * * * * * * * * * * * * * * * * PATTERNS
        <<grp__patterns>>

        // * * * * * * * * * * * * * * * * * * * * * * * * * TEMPLATES / MISC
        <<grp__misc>>

        // * * * * * * * * * * * * * * * * * * * * * * * * * LITERALS
        <<grp__literals>>

        self: _ => 'self',

        crate: _ => 'crate',
        dep: _ => 'dep',
        super: _ => 'super',
    },
})

// Match one or more occurrences of rule separated by sep.
function sepBy1(rule, sep) {
    return seq(rule, repeat(seq(sep, rule)))
}

// Match zero or more occurrences of rule separated by sep.
function sepBy(rule, sep) {
    return optional(sepBy1(rule, sep))
}
#+end_src


TODO: Put these aliases somewhere properly.
#+name: generic_parameters
#+begin_src js :rule _generic_parameters :arg $
alias(<<r("generics")>>, $.type_parameters)
#+end_src

#+name: generic_type_parameters
#+begin_src js :rule _generic_type_parameters :arg $
alias(<<r("generic_type_args")>>, $.type_parameters)
#+end_src

** Declarations

#+name: grp__declarations
#+begin_src js :noweb yes
<<n("item_visibility")>>
<<n("visibility")>>
<<n("attribute")>>
<<c('("use" "use_variants" "use_variants_scoped" "use_list"))>>
<<n("mod_or_contract")>>
<<c('("struct" "struct_field" "struct_field_list"))>>
<<c('("impl" "trait_impl_body" "trait_impl_type" "trait_impl_constant"))>>
<<c('("trait" "trait_tail" "trait_tail_alias" "trait_bounds" "trait_bound" "trait_body" "trait_type" "trait_constant"))>>
<<c('("global" "global_item_modifiers"))>>
<<n("type_alias")>>
<<c('("function" "function_signature" "function_item_modifiers" "function_return_type" "function_parameters" "function_parameter" "function_parameter_type"))>>
<<c('("where" "where_clause"))>>
#+end_src

** Statements

#+name: grp__statements
#+begin_src js :noweb yes
<<n("statement")>>
<<c('("break_statement" "continue_statement" "return_statement" "let_statement" "constrain_statement" "comptime_statement__let_for" "for_statement" "assign_statement" "expression_statement"))>>
#+end_src

** Expressions

#+name: grp__expressions
#+begin_src js :noweb yes
<<n("expression")>>
<<n("binary_expression")>>
<<n("array_expression")>>
<<n("slice_expression")>>
<<n("block")>>
<<c('("call_expression" "arguments" "call_arguments"))>>
<<n("for_range")>>

<<n("unary_op")>>
<<c('("generic_function" "member_access_expression" "cast_expression" "index_expression"))>>

// Ordered as at Atom.
<<n("parenthesised_expression")>>
<<n("tuple_expression")>>
<<n("unsafe_block")>>
// VariableExpression is Path (see elsewhere).
<<c('("constructor_expression" "constructor_body" "constructor_field"))>>
<<n("if_expression")>>
<<c('("lambda" "lambda_return_type" "lambda_parameters" "lambda_parameter"))>>
<<n("comptime_block")>>
<<n("unquote_expression")>>
<<n("trait_path_alias")>>
#+end_src

** Types

#+name: grp__types
#+begin_src js :noweb yes
<<n("type")>>
<<n("type_annotation")>>
<<n("type_arguments")>>
<<c('("primitive_type" "field_type" "int_type" "bool_type" "str_type" "fmt_str_type"))>>
<<c('("parentheses_type" "unit_type" "tuple_type"))>>
<<n("array_or_slice_type")>>
<<n("mutable_reference_type")>>
<<c('("function_type" "function_type_parameters" "capture_environment"))>>
// TODO: TraitAsType? AsTraitPathType?
<<c('("generics" "generic" "constrained_type"))>>
<<n("generic_type")>>
<<c('("generic_type_args" "generic_type_arg" "named_type_arg" "ordered_type_arg"))>>

// 'TypeExpressions' are limited to constant integers, variables, and basic numeric binary operators; they are a special type that is allowed in the length position of an array (and some other limited places).
// Using 'expr' in-place of 'expression' so-as-to- not conflate with _real_ expressions.
<<n("type_or_type_expr")>>
<<c('("type_expr" "binary_type_expr" "unary_type_expr" "atom_type_expr" "parenthesised_type_expr"))>>
#+end_src

** Patterns

#+name: grp__patterns
#+begin_src js :noweb yes
<<c('("pattern_or_self" "pattern" "pattern_no_mut" "pattern_mut" "self_pattern"))>>
<<n("tuple_pattern")>>
<<c('("struct_pattern" "struct_pattern_field"))>>
#+end_src

** Misc

Mostly meta-rules e.g. inlined tree-sitter rules serving as templates.

#+name: grp__misc
#+begin_src js :noweb yes

// Alias both Generic and GenericType parameters to a node of the same name.
<<c('("generic_parameters" "generic_type_parameters"))>>
<<n("tmp__let_to_type")>>
#+end_src

** Literals

#+name: grp__literals
#+begin_src js :noweb yes
<<n("literal")>>
<<n("bool")>>
<<n("int")>>
<<c('("str" "str_content" "escape_sequence"))>>
<<n("raw_str")>>
<<c('("fmt_str" "fmt_str_content"))>>
<<n("quote")>>
<<n("comment")>>
<<c('("line_comment__doc_style__inner" "line_comment__doc_style__outer" "line_comment__doc_style" "line_comment"))>>
<<c('("block_comment__doc_style" "block_comment"))>>
<<c('("path" "identifier_or_path" "path_no_turbofish" "identifier_or_path_no_turbofish" "path_identifiers"))>>
<<n("path_kind")>>
<<n("identifier")>>

// Modifiers except for visibility (in order).
<<c('("modifier_mut" "modifier_comptime" "modifier_unconstrained"))>>
#+end_src

* Tangle

Custom tangle logic for this file. The goal is to be able to refer to tree-sitter DSL snippets by a constant name which can be easily jumped to, and also to reduce the headache of tedious renaming as things change when using a strategy like this where code snippets may be located far apart in this org document.

In all cases a src-block must have a =#+name= associated which is used to refer to it. The substituted name when tangled may be specified by adding a =:rule= header to the associated src-block.


Inserts the name of the src-block it literally appears in.
#+name: self
#+begin_src emacs-lisp
(when-let* ((block-src-info (org-babel-lob--src-info block_name))
            (block-name (org-element-property :name (org-element-at-point (nth 5 block-src-info))))
            (name (or (cdr (assoc :rule (nth 2 block-src-info))) block-name)))
  (format "$.%s" name))
#+end_src


Inserts the name of given src-block parameter =block_name= refers to.
#+name: r
#+begin_src emacs-lisp :var block_name=""
;; TODO: Format an error (or better yet elisp call `error` if no block-src-info found)
(when-let* ((block-src-info (org-babel-lob--src-info block_name))
            ;; TODO: block_name fallback here error prone.
            (rule-name (or (cdr (assoc :rule (nth 2 block-src-info))) block_name)))
  (format "$.%s" rule-name))
#+end_src


Inserts the contents of given src-block parameter =block_name= with it's tangled content name, argument, and org back-links generated.
#+name: n
#+begin_src emacs-lisp :var block_name=""
;; TODO: Use format-spec instead to get $ as ($) or just use a js formatter after tangling.
(when-let* ((block-src-info (org-babel-lob--src-info block_name))
            ;; (block-src (cadr block-src-info))
            (block-src (org-babel-expand-noweb-references block-src-info))
            (rule-arg (or (cdr (assoc :arg (nth 2 block-src-info))) "_"))
            (rule-name (or (cdr (assoc :rule (nth 2 block-src-info))) block_name))
            (buff-name (buffer-name)))
  (format "\
\n// [[file:%s::%s]]
%s: %s => %s,"
          buff-name block_name
          rule-name rule-arg block-src))
#+end_src


Executes =n= for each element of given list of src-block =block_name=\s.
#+name: c
#+begin_src emacs-lisp :var block_names=""
(let (res)
  (dolist (block_name block_names res)
    ;; (message "=====> processing: %s / %s" block_name (stringp block_name))
    ;; (message "==========> %s" (org-babel-lob--src-info block_name))
    ;; (message "===> %s" (concat "$\"" block_name "\""))
    ;; (setq res (concat res "\ny" (org-sbe "n" (block_name (concat "$\"" block_name "\"")))))
    ;; (setq res (concat res "\ny" (org-sbe "n" (block_name $"attribute"))))

    ;; pp-macroexpand: (org-sbe "n" (block_name $"attribute"))
    (setq res (concat res (org-babel-execute-src-block
                                nil
                                (list "emacs-lisp" "results" `((:var . ,(format "results=n[](block_name=\"%s\")" block_name)))) '((:results . "none")))))
    ))
#+end_src


#+name: lit
#+begin_src emacs-lisp :var literal=""
(format "\"%s\"" literal)
#+end_src


Inserts the contents of the given src-block parameter =block_name=, resolving that src-block after prepending ~,ebnf_~ to given =block_name=. This is effectively a convenience function for EBNF transcluded snippets as mangling their names makes them easier to find and exclude where necessary.
#+name: ebnf
#+begin_src emacs-lisp :var block_name=""
(when-let* ((block-src-info (org-babel-lob--src-info (concat ",ebnf_" block_name)))
            (block-src (org-babel-expand-noweb-references block-src-info)))
  (concat block-src "\n"))
#+end_src


Like =c= is for =n= this is for =ebnf=.
#+name: ebnf_c
#+begin_src emacs-lisp :var block_names=""
(let (res)
  (dolist (block_name block_names res)
    (setq res (concat res (org-babel-execute-src-block
                           nil
                           (list "emacs-lisp" "results" `((:var . ,(format "results=ebnf[](block_name=\"%s\")" block_name))))
                           '((:results . "none")))))
    ))
#+end_src

Simple conversion of Noirc EBNF style to W3C EBNF style required for railroad diagram generator as well as removing Rust-specific syntax items (i.e. doc comments prefix).
#+name: ebnf_preformat
#+begin_src emacs-lisp :var block_name=""
(when-let* ((block-src-info (org-babel-lob--src-info block_name))
            (block-src (org-babel-expand-noweb-references block-src-info)))
  (with-temp-buffer
    (insert block-src)

    ;; Remove leading ///
    (goto-char (point-min))
    (while (re-search-forward "^///\s?" nil t)
      (replace-match ""))

    ;; Replace rule assignment = with ::=
    (goto-char (point-min))
    (while (re-search-forward "\s=\s" nil t)
      (replace-match " ::= "))

    (buffer-string)))
#+end_src

* Railroad

Noirc EBNF grammar documentation gathered and tangled for construction of a railroad diagram.

#+begin_src fundamental :tangle noir_railroad.ebnf :noweb yes
<<ebnf_preformat("railroad_collect")>>
#+end_src

Collect them all here so we can process (do a bunch of regex replacements) just once. Also we use a nasty prefix on the named code blocks so we can still jump to them with =C-c C-v g= even though using noweb-ref would be simpler we wouldn't be able to do the jumping as easily.

#+name: railroad_collect
#+begin_src fundamental :noweb yes
<<ebnf("program")>>
<<ebnf("module")>>

<<ebnf("inner_doc_comments")>>
<<ebnf("outer_doc_comments")>>

<<ebnf("item")>>
<<ebnf("item_visibility")>>
<<ebnf("item_kind")>>
// TODO: InnerAttribute, Attributes, Modifiers
<<ebnf("use")>>
<<ebnf("mod_or_contract")>>
// TODO: Struct, Impl
<<ebnf("trait")>>
<<ebnf("trait_body")>>
<<ebnf("global")>>
// TODO: TypeAlias
<<ebnf("function")>>

<<ebnf("function_parameters")>>

// Generic type parameters.
<<ebnf_c('("generic_type_args" "generic_type_args_list" "generic_type_arg" "named_type_arg" "ordered_type_arg"))>>

<<ebnf("literal")>>

<<ebnf("path")>>
<<ebnf("path_no_turbofish")>>
<<ebnf("path_kind")>>
<<ebnf("turbofish")>>

<<ebnf("identifier")>>
<<ebnf("bool")>>
#+end_src
