=====
Break
=====

global foo1 = { break; };

---

(source_file
  (global_item
    name: (identifier)
    (block
      (break_statement)))
)


========
Continue
========

global foo1 = { continue; };

---

(source_file
  (global_item
    name: (identifier)
    (block
      (continue_statement)))
)


======
Return
======

global foo1 = { return; };
global foo2 = { return 123; };

---

(source_file
  (global_item
    name: (identifier)
    (block
      (return_statement)))
  (global_item
    name: (identifier)
    (block
      (return_statement
        (int_literal))))
)


===
Let
===

global f1 = { let x = 123; };
global f2 = { let (x, y) = 1; };

---

(source_file
  (global_item
    name: (identifier)
    (block
      (let_statement
        pattern: (identifier)
        value: (int_literal))))
  (global_item
    name: (identifier)
    (block
      (let_statement
        pattern: (tuple_pattern
          (identifier)
          (identifier))
        value: (int_literal))))
)


=============
Let / Complex
:skip
=============

global f2 = { let mut y = { 1 + 2 }; };

---

(source_file
  (global_item
    name: (identifier)
    (block
      (let_statement
        pattern: (identifier)
        value: (block
          (binary_expression
            left: (int_literal)
            right: (int_literal))))))
)


=========
Constrain
:skip
=========

global f1 = { assert(true); };
global f2 = { assert(true, 1, x); };

global f3 = { assert_eq(true); };
global f3 = { assert_eq("foo", "bar", "lorem"); };

---

(source_file
  (global_item
    name: (identifier)
    (block
      (constrain_statement
        arguments: (arguments
          (bool_literal)))))
  (global_item
    name: (identifier)
    (block
      (constrain_statement
        arguments: (arguments
          (bool_literal)
          (int_literal)
          (identifier)))))

  (global_item
    name: (identifier)
    (block
      (constrain_statement
        arguments: (arguments
          (bool_literal)))))
  (global_item
    name: (identifier)
    (block
      (constrain_statement
        arguments: (arguments
          (str_literal
            (str_content))
          (str_literal
            (str_content))
          (str_literal
            (str_content))))))
)


======================
Constrain / Degenerate
======================

global f1 = { assert(); };
global f2 = { assert(,); };

---

(source_file
  (global_item
    name: (identifier)
    (block
      (constrain_statement
        arguments: (arguments))))
  (global_item
    name: (identifier)
    (block
      (constrain_statement
        arguments: (arguments))))
)
